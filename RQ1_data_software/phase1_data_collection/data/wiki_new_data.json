[
{"url": "https://wiki.ros.org/rosbridge_server", "package": "rosbridge_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lifecycle_msgs", "package": "lifecycle_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jsk_rqt_plugins", "package": "jsk_rqt_plugins", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/synthetic2d", "package": "synthetic2d", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/microxrcedds_agent_cmake_module", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosidl_cmake", "package_summary": [], "package_details": ["If you're creating additional documentation for a package or stack, feel free to structure them however you like, but please keep them within the namespace of your package (e.g. \"ros.org/wiki/my_package/more_details\")", "Once you save that page, it will have a \"Create Tutorial\" button that you can use to create new tutorial pages which will be automatically indexed and easier for users to find. Also the", "page outlines how to write a tutorial.", "If none of these cover your situation, you can create a blank page"]},
{"url": "https://wiki.ros.org/ethercat_trigger_controllers", "package_summary": ["Controllers to operate the digital output of the motor controller\n    boards and the projector board. This package has not been reviewed and\n    should be considered unstable."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_joint_trajectory_controller", "package_summary": ["Graphical frontend for interacting with joint_trajectory_controller instances."], "package_details": ["Graphical frontend for interacting with", "instances."]},
{"url": "https://wiki.ros.org/zeroconf_msgs", "package_summary": ["General ros communications used by the various zeroconf implementations."], "package_details": ["Messages supporting the", "and", "stacks."]},
{"url": "https://wiki.ros.org/asr_msgs", "package_summary": ["This package contains all messages that are particular to our Active Scene Recognition - Framework at \n\t\tHumanoids and Intelligence Systems Lab (HIS), Karlsruhe Institute of Technology (KIT).\n\t  These messages make up the interfaces between the different collaborating components of this system.\n\t  They are of critical importance and structured by the ROS communication capabilities."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"asr_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/asr_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/pmb2_controller_configuration_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ocl", "package_summary": ["This package contains standard components for the Orocos Toolchain"], "package_details": ["Read the", "for detailed information on how to use the deployer."]},
{"url": "https://wiki.ros.org/lanelet2_routing", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/multisense", "package_summary": ["multisense catkin driver"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_gripper_sensor_controller", "package_summary": ["The pr2_gripper_sensor_controller package is a real-time controller that integrates signals from the PR2 hand-mounted accelerometer and finger-mounted pressure sensors with motor control of the gripper joint to do highly responsive sensing and low-latency closed-loop control."], "package_details": ["The", "package is a real-time controller that is intended to support the", "interface and allow it to:", "The", "package continuously publishes several messages defined in the", "package, which are intended for use in the action servers of", "and not for normal user usage, but can provide useful information for more advanced users.", "The", "two important PR2 sensors to be available:", "A simple test to check if these sensors exist is to run the command", "and check to make sure the", "and", "fields are present.", "If you are not using a prebuilt installation you may have to compile the", "package. Since the", "package is a real-time controller, it is important to remember to compile the package", "launching your robot, otherwise it will fail to register and load correctly with", ". Compiling can be done simply by typing:", "Or by building any of the higher-level packages (such as", "which depend on this package)", "launching your robot.", "See the", "launch instructions, which will automatically launch the", "package for both the left and right PR2 grippers. Specific left/right launch files are available in the", "package, but it is unecessary for the end user to launch them independently."]},
{"url": "https://wiki.ros.org/combined_robot_hw", "package_summary": ["Combined Robot HW class."], "package_details": ["High-resolution version can be found", ".", "A short summary of CombinedRobotHW can be found in", "ROScon 2016 talk."]},
{"url": "https://wiki.ros.org/turtlebot3_description", "package_summary": ["3D models of the TurtleBot3 for simulation and visualization"], "package_details": []},
{"url": "https://wiki.ros.org/pluginlib", "package_summary": ["The pluginlib package provides tools for writing and dynamically loading plugins using the ROS build infrastructure.\n    To work, these tools require plugin providers to register their plugins in the package.xml of their package."], "package_details": []},
{"url": "https://wiki.ros.org/pluginlib", "package": "pluginlib", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_description", "package": "turtlebot3_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/launch_ros", "package": "launch_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lanelet2_projection", "package": "lanelet2_projection", "package_summary": ["Lanelet2 projection library for lat/lon to local x/y conversion"], "package_details": []},
{"url": "https://wiki.ros.org/interactive_marker_tutorials", "package": "interactive_marker_tutorials", "package_summary": ["The interactive_marker_tutorials package"], "package_details": ["See", "for the tutorials based on this package."]},
{"url": "https://wiki.ros.org/rosauth", "package": "rosauth", "package_summary": ["Server Side tools for Authorization and Authentication of ROS Clients"], "package_details": ["The rosbridge server is responsible for calling the /authenticate service on a request of the client. This can be done using the authenticate method of roslibjs:"]},
{"url": "https://wiki.ros.org/rc_genicam_api", "package": "rc_genicam_api", "package_summary": ["GenICam/GigE Vision Convenience Layer.\n\n      This package combines the Roboception convenience layer for images with the\n      GenICam reference implementation and a GigE Vision transport layer. It is a\n      self contained package that permits configuration and image streaming of\n      GenICam / GigE Vision 2.0 compatible cameras like the Roboception rc_visard.\n\n      This package also provides some tools that can be called from the command line\n      for discovering cameras, changing their configuration and streaming images.\n      Although the tools are meant to be useful when working in a shell or in a\n      script, their main purpose is to serve as example on how to use the API for\n      reading and setting parameters, streaming and synchronizing images.\n\n      See LICENSE.md for licensing terms of the different parts."], "package_details": ["All three options can be seen in the output of", ".", "If the given ID contains a colon (i.e.", "), the part before the (first)", "colon is interpreted as interface ID and the part after the first colon is", "treated as device ID. This is the format that", "shows. A device", "with the given ID is only sought on the specified interface. This can be", "useful if there are several ways to reach a device from a host computer,", "e.g. via wireless and wired network connection, but a certain connection", "type (e.g. wired) is preferred due to higher bandwidth and lower latency.", "Examples:", ",", "or", "The", "script performs some simple checks and should be run while or after streaming images via GigE Vision.", "These values can be changed during runtime with", "or written to", "for persistence across reboots.", "If the number of UDP", "increases while streaming, increasing the socket receive buffer size usually fixes the problem.", "Check the", "or", "Check with", "and increase the values if needed:"]},
{"url": "https://wiki.ros.org/nav_2d_utils", "package": "nav_2d_utils", "package_summary": ["A handful of useful utility functions for nav_core2 packages."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_py_console", "package": "rqt_py_console", "package_summary": ["rqt_py_console is a Python GUI plugin providing an interactive Python console."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_pr2_startup", "package": "jsk_pr2_startup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sick_scan", "package": "sick_scan", "package_summary": ["A ROS driver for the SICK TiM and SICK MRS series of lidars.\n    This package is based on the original sick_tim-repository of Martin G\u00fcnther et al."], "package_details": ["ROS packages for SICK laser scaners. This driver provides the measurement data as", "and", "data. The use of", "data is recommended.", "The", "data should only be used for debugging purposes. They provide the raw data for each scan plane in a different coordinate frame. Due to the geometry of the scanning planes of the MRS1104 there is no coordinate transformation between the scan planes that can be described by", "messages, therefore no", "messages are published. That is why the", "data should be used."]},
{"url": "https://wiki.ros.org/moveit_ros_benchmarks", "package": "moveit_ros_benchmarks", "package_summary": ["Enhanced tools for benchmarks in MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/novatel_msgs", "package": "novatel_msgs", "package_summary": ["ROS messages which represent raw Novatel SPAN data."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"novatel_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/novatel_msgs/manifest.yaml", "These messages are the low-level binary interface between a NovAtel SPAN unit and ROS. Typical use cases should not require working with these messages.", "Please see the related package,", "."]},
{"url": "https://wiki.ros.org/moveit_planners_chomp", "package": "moveit_planners_chomp", "package_summary": ["The interface for using CHOMP within MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_map", "package": "mrpt_map", "package_summary": ["The mrpt_map is able to publish a mrpt map as ros occupancy grid like the map_server"], "package_details": ["The", "node publishes (static, prebuilt) metric maps stored in MRPT formats:", "or", ".", "Most ROS packages expect the map to be a unique occupancy grid map. This node supports those simple maps, plus all other", "."]},
{"url": "https://wiki.ros.org/rosflight_pkgs", "package": "rosflight_pkgs", "package_summary": ["ROS interface for the ROSflight autpilot stack"], "package_details": []},
{"url": "https://wiki.ros.org/velodyne_laserscan", "package": "velodyne_laserscan", "package_summary": ["Extract a single ring of a Velodyne PointCloud2 and publish it as a LaserScan message"], "package_details": []},
{"url": "https://wiki.ros.org/swri_image_util", "package": "swri_image_util", "package_summary": ["swri_image_util"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_mechanism_controllers", "package": "pr2_mechanism_controllers", "package_summary": ["The pr2_mechanism_controllers package contains realtime\n    controllers that are meant for specific mechanisms of the PR2."], "package_details": ["At the present time, the controllers in this stack are not intended for direct use. The controllers should be used via their", "interfaces, e.g.,", ",", ",", ", and", ".    The", "library is stable."]},
{"url": "https://wiki.ros.org/qt_gui_cpp", "package": "qt_gui_cpp", "package_summary": ["qt_gui_cpp provides the foundation for C++-bindings for qt_gui and creates bindings for every generator available.\n    At least one specific binding must be available in order to use C++-plugins."], "package_details": []},
{"url": "https://wiki.ros.org/agni_tf_tools", "package": "agni_tf_tools", "package_summary": ["This package provides a gui program as well as a rviz plugin to publish static transforms.\n  Both support the transformation between various Euler angle representations.\n  The rviz plugin also allows to configure the transform with an interactive marker."], "package_details": ["Dependent on the order of rotation axes, there are different sets of Euler angles. One common set is roll-pitch-yaw (the default in ROS), which corresponds to rotations about x, y, and z axes w.r.t. the fixed frame. To specify Euler angles w.r.t. a different set or order of axes, simply specify the desired order instead of rpy. For example,", "will rotate by 30\u00b0 about the y axis, then by 50\u00b0 about the x axis, and finally by 70\u00b0 about the y axis. In order to transform a given Euler angle representation into another one, simply enter the desired axes order - replacing the whole text field including the angular values.", "To specify whether rotations should be performed w.r.t. the", "tatic or the moving /", "otationg frame (corresponding to left resp. right matrix multiplication), it's possible to prefix the axes order by \"", "\" or \"", "\". Omitting the prefix, corresponds to \"", "\" or right matrix multiplication.", "The rviz plugin also supports frame transformations. If you want to compute the entered transform w.r.t. another parent frame, simply enable the checkbox \"", "\" and subsequently change the", ". If the checkbox is not ticked, changing the parent frame doesn't change the relative transform, but moves the interactive marker.", "The entered transform is published as soon as a empty frame names are provided and the \"", "\" checkbox is enabled."]},
{"url": "https://wiki.ros.org/wfov_camera_msgs", "package": "wfov_camera_msgs", "package_summary": ["Messages related to the Point Grey camera driver."], "package_details": []},
{"url": "https://wiki.ros.org/py_trees_ros", "package": "py_trees_ros", "package_summary": ["Ros extensions and behaviours for py_trees."], "package_details": ["Get started at the", "."]},
{"url": "https://wiki.ros.org/ps3joy", "package": "ps3joy", "package_summary": ["Playstation 3 SIXAXIS or DUAL SHOCK 3 joystick driver.\n    Driver for the Sony PlayStation 3 SIXAXIS or DUAL SHOCK 3\n    joysticks. In its current state, this driver is not compatible\n    with the use of other Bluetooth HID devices. The driver listens\n    for a connection on the HID ports, starts the joystick\n    streaming data, and passes the data to the Linux uinput device\n    so that it shows up as a normal joystick."], "package_details": ["is known to work with Ubuntu 12.10, Ubuntu 12.04, Ubuntu Jaunty 9.04, and Ubuntu Hardy 8.04. To make it work with Ubuntu Karmic 9.10, you will have to follow these", ".", "also exposes the joystick's three-axis accelerometer and the single-axis gyroscope:", "This driver exists because Linux's native support for the PS3 joystick is unreliable, and does not give access to the joystick's accelerometers and gyroscope. This driver solves both problems. However in its current form,", ". In future releases, we plan to allow first non-HID and later any bluetooth device to coexist with this driver. If you have a need for such functionality, let it be known.", "The", "is a good starting point for how to use this package.", "This is the same for", "and", ".", "Or you could write a sudo script for sourcing ROS and starting ps3joy_node; I use", "to automatically start the", "after booting and a ROS-check.", "There is", ".", "With these #defines you can access the PS3 buttons within the", "without worrying about magic numbers:"]},
{"url": "https://wiki.ros.org/libsiftfast", "package": "libsiftfast", "package_summary": ["Library to compute SIFT features"], "package_details": []},
{"url": "https://wiki.ros.org/yocs_velocity_smoother", "package": "yocs_velocity_smoother", "package_summary": ["Bound incoming velocity messages according to robot velocity and acceleration limits."], "package_details": []},
{"url": "https://wiki.ros.org/map_msgs", "package": "map_msgs", "package_summary": ["This package defines messages commonly used in mapping packages."], "package_details": ["This package provides a preliminary implementation of messages defined in the work-in-progress REP 129. For more information, please have a look at the", "."]},
{"url": "https://wiki.ros.org/julius", "package": "julius", "package_summary": ["julius: Open-Source Large Vocabulary CSR Engine (http://julius.sourceforge.jp/index.php)"], "package_details": []},
{"url": "https://wiki.ros.org/controller_manager_msgs", "package": "controller_manager_msgs", "package_summary": ["Messages and services for the controller manager."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_3rdparty", "package": "jsk_3rdparty", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/rcdiscover", "package": "rcdiscover", "package_summary": ["This package contains tools for the discovery of Roboception devices via GigE Vision."], "package_details": []},
{"url": "https://wiki.ros.org/urg_c", "package": "urg_c", "package_summary": ["The urg_c package"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3", "package": "turtlebot3", "package_summary": ["ROS packages for the Turtlebot3 (meta package)"], "package_details": ["is a new generation mobile robot that is modular, compact and customizable. Let\u2019s explore ROS and create exciting applications for education, research and product development. The goal of", "is to drastically reduce the size and lower the price of the platform without sacrificing capability, functionality, and quality. Optional parts such as chassis, computers and sensors are available, and", "can be customized in various ways.", "is willing to be in the center of the maker movement by applying the latest technical advances of the SBC(Single Board Computer), the Depth sensor and 3D printing technology."]},
{"url": "https://wiki.ros.org/rqt_gui_py", "package": "rqt_gui_py", "package_summary": ["rqt_gui_py enables GUI plugins to use the Python client library for ROS."], "package_details": []},
{"url": "https://wiki.ros.org/pr2eus_openrave", "package": "pr2eus_openrave", "package_summary": [], "package_details": ["and", "Documentation is available", ".", "Use trac to report", "or", "."]},
{"url": "https://wiki.ros.org/moveit_planners_ompl", "package": "moveit_planners_ompl", "package_summary": ["MoveIt interface to OMPL"], "package_details": []},
{"url": "https://wiki.ros.org/sr_ethercat_hand_config", "package": "sr_ethercat_hand_config", "package_summary": ["sr_ethercat_hand_config contains the different yaml files storing the parameters used on the etherCAT hand."], "package_details": []},
{"url": "https://wiki.ros.org/lidar_camera_calibration", "package": "lidar_camera_calibration", "package_summary": [], "package_details": ["We maintain a very detailed README and other information regarding the lidar_camera_calibration package at the", "repo for the package. For more information regarding setting up lidar_camera_calibration, detailed usage, package capabilities and tutorials, please visit the", "repository at", ".", "For technical information please visit:"]},
{"url": "https://wiki.ros.org/xdot", "package": "xdot", "package_summary": [], "package_details": ["Please see", "and", "for more information."]},
{"url": "https://wiki.ros.org/roslisp_utilities", "package": "roslisp_utilities", "package_summary": ["Some utility functionality to interact with ROS using roslisp."], "package_details": []},
{"url": "https://wiki.ros.org/moveit_ros_planning", "package": "moveit_ros_planning", "package_summary": ["Planning components of MoveIt that use ROS"], "package_details": []},
{"url": "https://wiki.ros.org/teleop_tools_msgs", "package": "teleop_tools_msgs", "package_summary": ["The teleop_tools_msgs package"], "package_details": []},
{"url": "https://wiki.ros.org/rqt_logger_level", "package": "rqt_logger_level", "package_summary": ["rqt_logger_level provides a GUI plugin for configuring the logger level of ROS nodes.", "rqt_logger_level takes over `wx`-based tool [[rxloggerlevel]]."], "package_details": ["is an application for adjusting the logger level of ros nodes"]},
{"url": "https://wiki.ros.org/mbf_msgs", "package": "mbf_msgs", "package_summary": ["The move_base_flex messages package providing the action definition files for the action GetPath, ExePath, Recovery and MoveBase. The action servers providing these action are implemented in", "."], "package_details": []},
{"url": "https://wiki.ros.org/seed_r7_robot_interface", "package": "seed_r7_robot_interface", "package_summary": ["The seed_r7_robot_interface package"], "package_details": []},
{"url": "https://wiki.ros.org/moveit_plugins", "package": "moveit_plugins", "package_summary": ["Metapackage for MoveIt plugins."], "package_details": []},
{"url": "https://wiki.ros.org/joystick_interrupt", "package": "joystick_interrupt", "package_summary": ["Interrupt cmd_vel by joystick input"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_tools", "package": "jsk_tools", "package_summary": [], "package_details": ["Documentation is available", "."]},
{"url": "https://wiki.ros.org/pmb2_gazebo", "package": "pmb2_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ira_laser_tools", "package": "ira_laser_tools", "package_summary": ["The ira_laser_tools package. These nodes are meant to provide some utils for lasers, like listen to different laser scan sources and merge them in a single scan or generate virtual laser scans from a pointcloud."], "package_details": ["The documentation is at the moment very brief, for any question please contact us at", "or", "Paper link:"]},
{"url": "https://wiki.ros.org/stomp_core", "package": "stomp_core", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_tutorials", "package": "mrpt_tutorials", "package_summary": ["Example files used as tutorials for MRPT ROS packages"], "package_details": ["comprises demo files for", "."]},
{"url": "https://wiki.ros.org/phidgets_ik", "package": "phidgets_ik", "package_summary": ["Driver for the Phidgets InterfaceKit devices"], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_localization", "package": "mrpt_localization", "package_summary": ["Package for robot 2D self-localization using dynamic or static (MRPT or ROS) maps.\n\tThe interface is similar to amcl (https://wiki.ros.org/amcl)\n   but supports different particle-filter algorithms, several grid maps at\n   different heights, range-only localization, etc."], "package_details": ["The", "node wraps MRPT particle-filter localization algorithms through a ROS interface. See demo launch-file and tutorials above."]},
{"url": "https://wiki.ros.org/pmb2_controller_configuration", "package": "pmb2_controller_configuration", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/yocs_waypoints_navi", "package": "yocs_waypoints_navi", "package_summary": ["Simple tool for waypoints navigation with two functions:", "* Command the robot to go to a goal by passing through a series of waypoints.", "* Command the robot to constantly loop through a series of waypoints, useful for patrol."], "package_details": []},
{"url": "https://wiki.ros.org/zeroconf_avahi", "package": "zeroconf_avahi", "package_summary": [], "package_details": ["are used to discover the appearance and disappearance of all", "services belong to a specific service type (e.g. _ros-master._tcp). The usual process is to add a listener and then sit back and wait for the callbacks (either c++ or ros subscription) to arrive signifying addition or removal of the specified services.", "are zeroconf services you wish to publish on the network. They require a name, service type, port and description. If there is a name collision,", "this package and avahi will rename the service so that it is unique for the lifetime of the current connection.", "This package provides implementations for", "on top of linux's", ". There are two implementations:", "The c++ library can be manipulated directly through the", "class whereas the", "provides similar handles through ros topics, services and parameters exposed by the.", "Both the c++ and node implementations operate on two entities,", "and", ".", "If you're using the library, it should be relatively straightforward - simply follow the", "class documentation. There is also an example in", ".", "Alternatively, using the ros node can be done in a variety of ways, refer to the", ".", "See the example on static configuration for an illustration of the usage of the", "and", "parameters:"]},
{"url": "https://wiki.ros.org/urg_node", "package": "urg_node", "package_summary": ["urg_node"], "package_details": [":", ":", "Image credit:", "Allow Unsafe Settings Option is not available, please consider using the legacy", "for UTM-30LX with certain configurations.  (Or provide a", "to add support for unsafe_settings.)", "The", "program can be used to get information about a hokuyo laser scanner. Each of them can be invoked in a human readable way:", "The", "program can be used to get the hardware ID of a Hokuyo device given its port. Combined with udev, this allows a consistent device name to be given to each device, even if the order in which they are plugged in varies. On the PR2 we use the following udev rule:"]},
{"url": "https://wiki.ros.org/ur_dashboard_msgs", "package": "ur_dashboard_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rospatlite", "package": "rospatlite", "package_summary": ["rospatlite"], "package_details": ["is a ROS driver for patlite Signal Tower NHx series."]},
{"url": "https://wiki.ros.org/image_view2", "package": "image_view2", "package_summary": [], "package_details": ["Documentation: See"]},
{"url": "https://wiki.ros.org/transmission_interface", "package": "transmission_interface", "package_summary": ["Transmission Interface."], "package_details": ["contains data structures for representing mechanical transmissions, and  methods for propagating position, velocity and effort variables between  actuator and joint spaces.", "In the same spirit as the", "package, this package wraps existing raw data (eg. current actuator  position, reference joint command, etc.) under a consistent interface.  By not imposing a specific layout on the raw data, it becomes easier to  support arbitrary hardware drivers to software control.", "The", "is", "used by controllers themselves (it does not implement a", ") but instead operates before or after the controllers update, in the read() and write() methods (or equivalents) of the robot abstraction.", "See the", "page,", "and the", "for more information."]},
{"url": "https://wiki.ros.org/zbar_ros", "package": "zbar_ros", "package_summary": ["Lightweight ROS wrapper for Zbar barcode/qrcode reader library (http://zbar.sourceforge\n    .net/)"], "package_details": ["This package is a lightweight wrapper around the", "barcode processing library. It provides a node and a nodelet with equivalent interface. The", "topic is a lazy subscription that is active only when the", "topic has a client.", "Same API as node, available as", "."]},
{"url": "https://wiki.ros.org/pr2_controllers_msgs", "package": "pr2_controllers_msgs", "package_summary": ["Messages, services, and actions used in the pr2_controllers stack."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"pr2_controllers_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/pr2_controllers_msgs/manifest.yaml", "This package seems to be replaced by the PR2-agnostic package", ", stated by", "."]},
{"url": "https://wiki.ros.org/pr2_bringup_tests", "package": "pr2_bringup_tests", "package_summary": ["Complete functionality tests for PR2. Contains utilities designed to test and verify devices, mechanicals and sensors."], "package_details": ["- Information qualifying the mechanical calibration of newly built robots"]},
{"url": "https://wiki.ros.org/yocs_controllers", "package": "yocs_controllers", "package_summary": ["Library for various controller types and algorithms"], "package_details": []},
{"url": "https://wiki.ros.org/ur_robot_driver", "package": "ur_robot_driver", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For robots with Polyscope", "or older, please see whether", "is sufficient.", "Make sure the controller runs", "or newer for CB3, or", "or newer for e-Series controllers.", "Most documentation is handled inside the Githhub", "files."]},
{"url": "https://wiki.ros.org/joint_state_publisher_gui", "package": "joint_state_publisher_gui", "package_summary": ["This package contains a GUI tool for setting and publishing joint state values for a given URDF."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_calibration", "package": "jsk_calibration", "package_summary": ["The jsk_calibration package"], "package_details": []},
{"url": "https://wiki.ros.org/yocs_ar_pair_tracking", "package": "yocs_ar_pair_tracking", "package_summary": ["The AR pair tracking package"], "package_details": ["explains what to configure."]},
{"url": "https://wiki.ros.org/qt_build", "package": "qt_build", "package_summary": ["Currently just maintains a cmake api for simplifying the building of qt apps within the ros framework."], "package_details": []},
{"url": "https://wiki.ros.org/sicktoolbox", "package": "sicktoolbox", "package_summary": [], "package_details": ["Please see the", "package to use this library with ROS."]},
{"url": "https://wiki.ros.org/mrpt1", "package": "mrpt1", "package_summary": ["Mobile Robot Programming Toolkit (MRPT) version 1.5.x"], "package_details": ["The", "package provides the C++ libraries for MRPT 1.5.x, required in distributions where the official packages are older."]},
{"url": "https://wiki.ros.org/rqt_bag", "package": "rqt_bag", "package_summary": ["rqt_bag provides a GUI plugin for displaying and replaying ROS bag files."], "package_details": [", which is deprecated since", ".", "is an application for recording and managing bag files. Primary features:", "can be extended via a plugin mechanism.  Core plugins are contained in the", "package available in the", "metapackage.", "Don't forget to use simulation time when republishing from a bag file:", "currently has a proof-of-concept plugin API, which is used in the", "package.", "and select from", "-->", "-->", ".", "Or simply the following (with this you can't open", "with other rqt tools).", "Right-click on the name of the topic you want to publish, then select", "(as in the image below).", "The messages are shown at the timestamp stored in the bag file.  This timestamp may differ from the message's", "timestamp (if any), e.g.", "stores the time the message was received.", "For details on common message views such as images and plotting, see", "."]},
{"url": "https://wiki.ros.org/actionlib_lisp", "package": "actionlib_lisp", "package_summary": ["actionlib_lisp is a native implementation of the famous actionlib\n   in Common Lisp. It provides a client and a simple server."], "package_details": ["actionlib_lisp is a native implementation of", "in Common Lisp. It provides a simple server and a client. In contrast to the implementations of actionlib in C++ and Python which provide a simple action client/server and a complex one, the lisp equivalent provides only one server and client implementation. The server is similar to the simple action server and the client is a little bit more powerful than the simple action client but not as complex as the complex C++ equivalent."]},
{"url": "https://wiki.ros.org/mini_maxwell", "package": "mini_maxwell", "package_summary": ["mini_maxwell"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_perception", "package": "jsk_perception", "package_summary": ["ROS nodes and nodelets for 2-D image perception."], "package_details": []},
{"url": "https://wiki.ros.org/ros_controllers", "package": "ros_controllers", "package_summary": ["Library of ros controllers"], "package_details": ["See", "for more information."]},
{"url": "https://wiki.ros.org/pr2_self_test", "package": "pr2_self_test", "package_summary": ["The pr2_self_test package"], "package_details": []},
{"url": "https://wiki.ros.org/message_generation", "package": "message_generation", "package_summary": ["Package modeling the build-time dependencies for generating language bindings of messages."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_publisher", "package": "rqt_publisher", "package_summary": ["rqt_publisher provides a GUI plugin for publishing arbitrary messages with fixed or computed field values."], "package_details": []},
{"url": "https://wiki.ros.org/pilz_control", "package": "pilz_control", "package_summary": ["This package provides a specialized joint_trajectory_controller that can be moved into holding state via service call.\n  No further trajectories will be accepted/followed in this state."], "package_details": []},
{"url": "https://wiki.ros.org/xsens_driver", "package": "xsens_driver", "package_summary": ["ROS Driver for XSens MT/MTi/MTi-G devices."], "package_details": ["is a Python module that is both a library to communicate to devices through the", "class, and a standalone script to configure such a device.", "Note that you can use the module in an interactive session to diagnose or configure the device with a bit more flexibility.", "Changing the baudrate to values other than 115200 might not work for some devices (despite mentioned in the vendor documentation) and might require the emergency procedure to recover communication with the device.", "This package provides a driver for the third and fourth generation of Xsens IMU devices. The driver is in two parts, a small implementation of most of the MT protocol in Python and a", ". It works both on serial and USB interfaces.", "These MT* devices can store their configuration and will retrieve it at each boot and then stream data according to this configuration. The node only forwards the data streamed onto ROS topics. In order to configure your device, you can use the", "script (or the vendor tool on Windows).", "Compared to the other MTi drivers (", "and", "), this one can handle other configurations than the default and the GPS module of the MTi-G. It is also a clean rewrite of the communication protocol easier to maintain (and possibly extend) than the old vendor based multi-layered architecture.", "The ROS node is a wrapper around the", "class to publish the data that the IMU streams. It can publish the following topics, depending on the configuration of the device (topics are only advertised when there is data to publish):", "It also publishes", "information.", "If the IMU is set to raw mode, the values in of the", ",", "and", "topics are the 16 bits output of the AD converters.", "The covariance information in the", "message are filled with default values from the MTx/MTi/MTi-G documentation but may not be exact; it also does not correspond to the covariance of the internal XKF.", "It might be necessary to add the user to the", "group so that the node can communicate with the device."]},
{"url": "https://wiki.ros.org/xbot_talker", "package": "xbot_talker", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_reconfigure", "package": "rqt_reconfigure", "package_summary": ["This rqt plugin succeeds former dynamic_reconfigure's GUI\n    (reconfigure_gui), and provides the way to view and edit the parameters\n    that are accessible via dynamic_reconfigure.", "(12/27/2012) In the future, arbitrary parameters that are not associated\n    with any nodes (which are not handled by dynamic_reconfigure) might\n    become handled.\n    However, currently as the name indicates, this pkg solely is dependent\n    on dynamic_reconfigure that allows access to only those params latched\n    to nodes."], "package_details": ["To launch reconfigure_gui in Groovy, run:", "You can also launch the", "via", ":", "Generally speaking, try isolating GUI and non-GUI issue.", "'s", "are helpful for doing that.", "(", ")", "If nothing returned then the issue is your", "itself, not", "."]},
{"url": "https://wiki.ros.org/dynamic_edt_3d", "package": "dynamic_edt_3d", "package_summary": ["The dynamicEDT3D library implements an inrementally updatable Euclidean distance transform (EDT) in 3D. It comes with a wrapper to use the OctoMap 3D representation and hooks into the change detection of the OctoMap library to propagate changes to the EDT."], "package_details": []},
{"url": "https://wiki.ros.org/roseus_tutorials", "package": "roseus_tutorials", "package_summary": ["roseus_tutorials"], "package_details": ["Documentation is available"]},
{"url": "https://wiki.ros.org/openrtm_tools", "package": "openrtm_tools", "package_summary": ["The openrtm_tools package"], "package_details": []},
{"url": "https://wiki.ros.org/rosconsole_bridge", "package": "rosconsole_bridge", "package_summary": ["rosconsole_bridge is a package used in conjunction with console_bridge and rosconsole for connecting console_bridge-based logging to rosconsole-based logging."], "package_details": ["is a package used in conjunction with", "and", "for connecting", "-based logging to", "-based logging.", "If you have an application or library that is utilizing", "for logging, the logging information will be written to stdout. Applications/libraries that utilize", "do not follow this behavior, but rather write their output to both stdout (depending on log level) as well as the ROS topic /rosout.", "If you have a console_bridge application or library, you can have its output be written to /rosout by simply having your package depend on rosconsole_bridge. Additionally, a call to REGISTER_ROSCONOLE_BRIDGE has to be added to the ROS node. (See", ")."]},
{"url": "https://wiki.ros.org/pmb2_robot", "package": "pmb2_robot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav_2d_msgs", "package": "nav_2d_msgs", "package_summary": ["Basic message types for two dimensional navigation, extending from geometry_msgs::Pose2D."], "package_details": []},
{"url": "https://wiki.ros.org/lanelet2_io", "package": "lanelet2_io", "package_summary": ["Parser/Writer module for lanelet2"], "package_details": []},
{"url": "https://wiki.ros.org/seed_r7_navigation", "package": "seed_r7_navigation", "package_summary": ["The seed_r7_navigation package"], "package_details": []},
{"url": "https://wiki.ros.org/force_torque_sensor_controller", "package": "force_torque_sensor_controller", "package_summary": ["Controller to publish state of force-torque sensors"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/turtlebot3_slam", "package": "turtlebot3_slam", "package_summary": ["The turtlebot3_slam package provides roslaunch scripts for starting the SLAM"], "package_details": []},
{"url": "https://wiki.ros.org/rosgraph_msgs", "package": "rosgraph_msgs", "package_summary": ["Messages relating to the ROS Computation Graph. These are generally considered to be low-level messages that end users do not interact with."], "package_details": ["contains message relating to the ROS Computation Graph. Most users are not expected to interact with messages in this package, and it is strongly advised against.  These messages are generally wrapped in higher level APIs.", "is the underlying message data structure for logging to", ". If you use the client API methods in", "and", ", you will be protected against any future revisions to this message.", "is used for simulated", "in ROS. Only nodes that provide simulated time sources are expected to use this message.", "is used by", "and", "for publishing statistics on topic connections on /statistics. See", "for more information.", "Prior to Diamondback, these messages were in the", "package.  They were migrated to this package as part of", "."]},
{"url": "https://wiki.ros.org/safe_teleop_base", "package": "safe_teleop_base", "package_summary": ["This package provides automatic collision avoidance and is intended to be used for safer teleoperation of a robot base."], "package_details": ["(", ", default: 2.5)", "This node takes as input commands for a robot base and outputs the nearest safe commands. The core functionality has some similarities to", ".", "Many of the parameters are identical to those of the", "package."]},
{"url": "https://wiki.ros.org/gripper_action_controller", "package": "gripper_action_controller", "package_summary": ["The gripper_action_controller package"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/jackal_tutorials", "package": "jackal_tutorials", "package_summary": ["Jackal's tutorials."], "package_details": ["Please see the generated tutorial content", "."]},
{"url": "https://wiki.ros.org/rqt_service_caller", "package": "rqt_service_caller", "package_summary": ["rqt_service_caller provides a GUI plugin for calling arbitrary services."], "package_details": []},
{"url": "https://wiki.ros.org/visp_ros", "package": "visp_ros", "package_summary": ["An extension of ViSP library that interfaces ROS into usual ViSP classes and a basket of generic ros nodes based on ViSP."], "package_details": ["is an extension of", "library developed by Inria", "team. While ViSP is independent to ROS, in", "we benefit from ROS features.", "contains a library:", "contains also a set of ROS nodes that allow to control specific hardware such as for the moment:", "contains also a tutorial that shows how to simulate a Franka Panda robot using", ".", ".", "To illustrate", "behavior let us focus on a visual servoing example.", "Using", "allows to completely separate the code that is specific to the material (frame grabber, robot) from the one that does the visual servoing.", "In", "we introduce a new class named vpROSGrabber that is able to subscribe to an image topic. This class can be used to replace any ViSP grabber. We also introduce vpROSRobot that is able to publish cmd_vel velocities on a given topic.", "This", "highlights vpROSGrabber usage.", "Using", "allows to do visual servoing with the Parrot Bebop 2 drone.", "The following video shows an example.", "This", "explains how to proceed.", "Using", "makes possible to simulate a Franka robot in position, velocity and force control. All the rendering and sensing is done through", "while the geometric and dynamic model is handled in", ". Communication between", "and", "is done using ROS.", "The simulation is a physical simulation with a model that has been accurately identified from a real Franka robot. All the details are in the", ":", "If you are using this simulator we would appreciate that you cite this", ".", "There is a tutorial that explains how to start with this simulator to implement an image-based or position-based visual-servoing, or also an impedance controller, but right now this tutorial doesn't appear in visp_ros", ". To generate this tutorial from source code we suggest to", "described in", "section using rosdoc_lite to generate the package Doxygen documentation.", "The tutorial", "explains how to build and install", "in a catkin workspace.", "You may also find installation instructions", "."]},
{"url": "https://wiki.ros.org/jsk_recognition", "package": "jsk_recognition", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/volksbot_driver", "package": "volksbot_driver", "package_summary": ["Driver for the Volksbot robot."], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/xacro", "package": "xacro", "package_summary": ["Xacro (XML Macros)\n\n    Xacro is an XML macro language. With xacro, you can construct shorter and more readable XML files by using macros that expand to larger XML expressions."], "package_details": [": Properties are local if defined inside of a", ". See", ".", ":", ": The more powerful evaluation capabilities in ROS Jade allow for much more complex expression. Virtually any python expression that evaluates to a Boolean is feasible:", ": Since ROS Indigo, it is also possible to define defaults like so:", "Comments in front of macros will be removed during processing.", "They are considered to be related to the macro (e.g. explaining the macro). If you want to keep a comment in the final document, separate it with an empty line from the macro.", "Macro parameters can have default values:", "Often, you need to pass external variables into local macro params (as above for x). To ease this task, you can employ the ^ syntax:", "Properties and macros defined within a macro are local to this macro, i.e. not visible outside. Using the optional attribute", ", a property definition can be exported to the parent scope of a macro (or the global scope).", "Properties can be dictionaries or lists too - manually declared with python syntax, like so:", ": While this cmake code provides full control over the target name and build order, there is a conveniency macro too:", ": In order to add elements or attributes with a dynamically defined name, you can use the special xacro tags", "and", ":", ":", ":", "This package is most useful when working with large XML documents such as robot descriptions.  It is heavily used in packages such as the", ".  See for example,", "for how xacro is used to simplify urdf files. See", ", for an example showing the use of the advanced features (python evaluation, yaml integration) introduced in Jade.", "Many of the features highlighted as \"New in Jade\" below are also accessible from Indigo. To use them, the", "flag is required. This flag is discussed", ", and for some background information see this", ". Put simply, this flag is used to trigger Jade-enabled xacro processing on Indigo.", "Since ROS Jade, Xacro employs", "to evaluate expressions enclosed in dollared-braces,", ". This allows for more complex arithmetic expressions. Functions and constants from the", "math module (e.g.", "and trigonometric functions) are available for use. Examples:", "Xacro allows you to use certain rospack commands with dollared-parentheses (", ").", "Xacro currently supports most of the rospack commands that roslaunch supports using", "(with the exception of", ", see", "). Arguments need to be specified on the command line using the", "syntax.", "In xacro files,", "is a _global_ dictionary accessible from within any included file or macro.", "You can include other xacro files using the", "tag:", "The file \"other_file.xacro\", will be included and expanded by xacro.", ": Relative filenames are interpreted relative to the currently processed file.", ": When including files within a macro, not the macro-defining but the macro-calling file is the one that processes the include! $(cwd) explicitly allows to access files in the current working directory.", "or loaded from", "files like so:", "If you want the generated files to have a", "extension it is possible to provide input files terminating with", ", the", "suffix will be removed by the CMake function. This results in files with a", "extension.", "Usage example for", ":", "Classicly, xacro first loads all includes, then processes all property and macro definitions and finally instantiates macros and evaluates expressions. Thus,", ". Additionally, the conditional tags, <if> and <unless>, have no effect on macro or property definitions nor the inclusion of additional files.", "Since ROS Jade, xacro provides the command-line option", ", that allows to process the whole document in read order. Hence the latest definition of a property or macro", ", will be used. This is a much more intuitive evaluation process that allows for some nice new features as well:", "If there are any differences shown, you should check and adapt your xacro file. A common reason will be the late loading of calibration data (as properties). In this case, simply move them up front, i.e. before usage. To facilitate search for wrongly placed property definitions, you can run xacro with option", ". If there are any problematic properties, they will be listed on stderr:", "Using the command-line option", "or", "one can increase verbosity level to log all defintions of properties.", "By recursively calling a macro, it is also possible to unroll a loop and generate multiple similar XML snippets for a list of", ":", "To suppress the legacy interpretation of sloppy xacro tags and allow their usage in the target XML, you can use the command line option", "."]},
{"url": "https://wiki.ros.org/mrpt_rawlog", "package": "mrpt_rawlog", "package_summary": ["This package provides nodes to record and play MRPT rawlogs."], "package_details": ["See", "online.", "See", "online."]},
{"url": "https://wiki.ros.org/yocs_cmd_vel_mux", "package": "yocs_cmd_vel_mux", "package_summary": ["A multiplexer for command velocity inputs. Arbitrates incoming cmd_vel messages from several topics,\n     allowing one topic at a time to command the robot, based on priorities. It also deallocates current\n     allowed topic if no messages are received after a configured timeout. All topics, together with their\n     priority and timeout are configured through a YAML file, that can be reload at runtime."], "package_details": []},
{"url": "https://wiki.ros.org/mbf_utility", "package": "mbf_utility", "package_summary": ["The mbf_utility package"], "package_details": []},
{"url": "https://wiki.ros.org/voice_text", "package": "voice_text", "package_summary": ["voice_text (www.voicetext.jp)"], "package_details": []},
{"url": "https://wiki.ros.org/checkerboard_detector", "package": "checkerboard_detector", "package_summary": ["Uses opencv to find checkboards and compute their 6D poses with respect to the image. Requires the image to be calibrated.", "Parameters:"], "package_details": []},
{"url": "https://wiki.ros.org/sophus", "package": "sophus", "package_summary": ["C++ implementation of Lie Groups using Eigen."], "package_details": ["This is a ros 3rd party package that provides Hauke Strasdat's", "library.", "See the", "."]},
{"url": "https://wiki.ros.org/phidgets_drivers", "package": "phidgets_drivers", "package_summary": ["API and ROS drivers for Phidgets devices"], "package_details": ["Please see the", "documentation for an example on how to implement new types of Phidgets.", "For installing from source, it is best to follow the instructions in the README.md file in the", "."]},
{"url": "https://wiki.ros.org/libcmt", "package": "libcmt", "package_summary": ["libCMT ROS Wrapper"], "package_details": []},
{"url": "https://wiki.ros.org/pi_tracker", "package": "pi_tracker", "package_summary": [], "package_details": ["Tracker command requires one or more services from each node it commands.  In its current form, the tracker command node sends simple string commands to control nodes via their", "service.  For example, sending the command \"STOP\" to the", "node (see below) tells the base to stop moving."]},
{"url": "https://wiki.ros.org/rc_dynamics_api", "package": "rc_dynamics_api", "package_summary": ["The rc_dynamics_api provides an API for easy handling of the dynamic-state data\n      streams provided by Roboception's stereo camera with self-localization.\n      See http://rc-visard.com\n\n      Dynamic-state estimates of the rc_visard relate to its self-localization and\n      ego-motion estimation. These states refer to rc_visard's current pose,\n      velocity, or acceleration and are published on demand via several data streams.\n      For a complete list and descriptions of these dynamics states and the\n      respective data streams please refer to rc_visard's user manual."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_web", "package": "rqt_web", "package_summary": ["rqt_web is a simple web content viewer for rqt. Users can show web content in Qt-based window by specifying its URL."], "package_details": []},
{"url": "https://wiki.ros.org/webkit_dependency", "package": "webkit_dependency", "package_summary": ["This encapsulates the WebKit dependency for a specific ROS distribution and its Qt version"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_teleop_joy", "package": "jsk_teleop_joy", "package_summary": ["jsk_teleop_joy"], "package_details": []},
{"url": "https://wiki.ros.org/safe_teleop_pr2", "package": "safe_teleop_pr2", "package_summary": ["Launch files for running safe_teleop_base on pr2"], "package_details": []},
{"url": "https://wiki.ros.org/laser_assembler", "package": "laser_assembler", "package_summary": ["Provides nodes to assemble point clouds from either LaserScan or PointCloud messages"], "package_details": ["Laser Rangefinder sensors (such as Hokuyo's", ") generally output a stream of scans, where each scan is a set of range readings of detected objects (in polar coordinates) in the plane of the sensor.", "Many robotic systems, like PR2's tilting laser platform, articulate a laser rangefinder in order to get a 3D view of the world. The", "package provides nodes that listen to streams of scans and then assemble them into a larger 3D Cartesian coordinate (XYZ) point cloud.", "The ROS API of this package is considered stable. We don't foresee making any large changes to", "anytime soon.", "The", "subscribes to", "messages on the", "topic.  These scans are processed by the Projector and Transformer, which project the scan into Cartesian space and then transform it into the", ". This results in a", "that can be added to the rolling buffer. Clouds in the rolling buffer are then assembled on service calls.", "Note that the Transformer automatically receives", "data without any user intervention.", "The", "looks very similar to the", ", except that the projection step is skipped, since the input clouds are already in Cartesian coordinates.", "The main interaction with the assemblers is via ROS services. The", "and", "both provide the", "service, which is documented below.", "NOTE: For laser_pipeline releases < 0.5.0, this service is called", ".", "Launch an assembler operating on", "messages in the base_link frame, with a buffer of 400 scans.", "Launch an assembler operating on", "messages in the", "frame, with a buffer of 400 scans.", "As of laser_pipeline 0.4.0. A large part of the laser_assembler's ROS API was deprecated. The API reference for the deprecated API is available on the", "page."]},
{"url": "https://wiki.ros.org/position_controllers", "package": "position_controllers", "package_summary": ["position_controllers"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/yocs_joyop", "package": "yocs_joyop", "package_summary": ["Joystick teleoperation for your robot robot core"], "package_details": []},
{"url": "https://wiki.ros.org/moveit_core", "package": "moveit_core", "package_summary": ["Core libraries used by MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/rqt_top", "package": "rqt_top", "package_summary": ["RQT plugin for monitoring ROS processes."], "package_details": ["Originally made as", "."]},
{"url": "https://wiki.ros.org/pilz_testutils", "package": "pilz_testutils", "package_summary": ["This package contains testing utilities used by Pilz packages."], "package_details": ["For package documentation please see the", "."]},
{"url": "https://wiki.ros.org/libpointmatcher", "package": "libpointmatcher", "package_summary": ["libpointmatcher is a modular ICP library, useful for robotics and computer vision."], "package_details": ["Tutorials on how to use libpointmatcher can be found", "."]},
{"url": "https://wiki.ros.org/nlopt", "package": "nlopt", "package_summary": ["nlopt"], "package_details": []},
{"url": "https://wiki.ros.org/roslisp_common", "package": "roslisp_common", "package_summary": ["Common libraries to control ROS based robots. This stack contains\n    an implementation of actionlib (client and server) in Common Lisp,\n    a transformation library and an implementation of tf in Common\n    Lisp."], "package_details": ["Contains commonly used libraries for", ", including Lisp implementations of", "and", "."]},
{"url": "https://wiki.ros.org/lanelet2_examples", "package": "lanelet2_examples", "package_summary": ["Examples for working with Lanelet2"], "package_details": []},
{"url": "https://wiki.ros.org/lanelet2_python", "package": "lanelet2_python", "package_summary": ["Python bindings for lanelet2"], "package_details": []},
{"url": "https://wiki.ros.org/opt_camera", "package": "opt_camera", "package_summary": ["opt_camera"], "package_details": []},
{"url": "https://wiki.ros.org/ackermann_steering_controller", "package": "ackermann_steering_controller", "package_summary": ["Controller for a steer drive mobile base."], "package_details": ["(", ")", "(", ")", "(", ", default: 50.0)", "(", ", default: base_link)", "(", ", default: 1.0)", "(", ", default: false)", "(", ")", "(", ", default: 10)", "An example of using the packages can be seen in", ".", "The controller inherits", "to work with wheel joints through a", "interface for a linear wheel and a", "interface for a front steer wheel, which is the the most basic configuration for the ackermann steering driving mechanism.", "If you want", "to show states of robot's actual joint interfaces'", "through", "and", ", you need to convert the two interfaces of", "to your robot's specific ones via", "or RobotHWSim (generally used for", "). This is because the controller only update it's basic interfaces mentioned in the previous section.", "The controller main input is a", "topic in the namespace of the controller.", "An example for usage of", "with", "can be grabbed from", ".", "We developped a general RobotHWSim plugin for usage of", ". You can get the plugin from", "and also see an example of application on", ".", "We also provide a recovery behavior plugin of", "specifically desigined for ackermann steering mechanism base robots in", ". Feel free to see", "to learn how to use it."]},
{"url": "https://wiki.ros.org/pilz_industrial_motion", "package": "pilz_industrial_motion", "package_summary": ["The pilz_industrial_motion package"], "package_details": ["For package documentation please see the", "."]},
{"url": "https://wiki.ros.org/interactive_markers", "package": "interactive_markers", "package_summary": ["3D interactive marker communication library for RViz and similar tools."], "package_details": ["Use GitHub to", ". [", "]", "The tutorials can be found in", ". For an overview an further links, see", ".", "An app that uses interactive markers for controlling the PR2 is", "."]},
{"url": "https://wiki.ros.org/tts", "package": "tts", "package_summary": ["Package enabling a robot to speak with a human voice by providing a Text-To-Speech ROS service"], "package_details": [": Amazon Polly is a service that turns text into lifelike speech, allowing you to create applications that talk,", "and build entirely new categories of speech-enabled products. Amazon Polly is a Text-to-Speech service that uses advanced deep learning technologies to synthesize speech that sounds like a human voice.", "With dozens of lifelike voices across a variety of languages, you can select the ideal voice and build speech-enabled applications that work in many different countries.", ":", "The", "ROS node enables a robot to speak with a human voice by providing a Text-To-Speech service.", "Out of the box this package listens to a speech topic, submits text to the Amazon Polly cloud service to generate an audio stream file,", "retrieves the audio stream from Amazon Polly, and plays the audio stream via the default output device.", "The nodes can be configured to use different voices as well as custom lexicons and SSML tags which enable you to control aspects of speech,", "such as pronunciation, volume, pitch, speed rate, etc. A", "with this node,", "and more details on speech customization are available within the", ".", "The source code is released under an", "."]},
{"url": "https://wiki.ros.org/mrpt_icp_slam_2d", "package": "mrpt_icp_slam_2d", "package_summary": ["mrpt_icp_slam_2d contains a wrapper on MRPT's 2D ICP-SLAM algorithms."], "package_details": ["The sections below describe the API of this package which allows ICP-based SLAM in 2D", ".", "The SLAM algorithm is a simple", "using ICP to align 2D laser scans to the map, which can be either a", "or an", ". [For now, only point maps]", "Using this technique allows building", ", as long as errors do not grow excessively before closing any long loop. Building larger maps requires more advanced SLAM techniques. However, this simple icp-slam algorithm is an efficient and well-tested method which suffices for many practical situations.", "The ROS node", "is a wrapper for the C++ class", ",  part of MRPT. Thus, check out the documentation of that class for further  details.", "This node has been designed to provide an interface similar to that of", "for the convenience of users which already knew that package.", "For the convention on coordinate frames see", ".", "Using", "requires a horizontally-mounted, fixed, laser range-finder. Odometry is optional.", "The", "node will attempt to transform each incoming scan  into the", "(odometry)", "frame.  See the \"", "\"  for more on required transforms.", "In order to use mrpt_icp_slam_2d package it is necessary to install the last", "build and the", "(see also the", ") ."]},
{"url": "https://wiki.ros.org/jsk_pr2eus", "package": "jsk_pr2eus", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/oculusprime", "package": "oculusprime", "package_summary": [], "package_details": ["Please see"]},
{"url": "https://wiki.ros.org/yocs_math_toolkit", "package": "yocs_math_toolkit", "package_summary": ["Math toolkit for Yujin open control system. This package is intended to contain common use functions,\n    mostly for simple mathematics but also for tf-related conversions.\n    By no means it pretends to be an efficient and robust, widely used math library, but a play ground where\n    to put common code that is typically repeated in many robot control programs."], "package_details": []},
{"url": "https://wiki.ros.org/skeleton_markers", "package": "skeleton_markers", "package_summary": [], "package_details": ["To make this package work with ROS Indigo, you will need the Kinect drivers for Ubuntu 14.04.  The following instructions were taken from", ".  The steps below are for a 64-bit system.  Use the 32-bit files for a 32-bit system.", "Use the", "file:"]},
{"url": "https://wiki.ros.org/rqt_pose_view", "package": "rqt_pose_view", "package_summary": ["rqt_pose_view provides a GUI plugin for visualizing 3D poses."], "package_details": []},
{"url": "https://wiki.ros.org/julius_ros", "package": "julius_ros", "package_summary": ["The julius_ros package"], "package_details": []},
{"url": "https://wiki.ros.org/urdf_tutorial", "package": "urdf_tutorial", "package_summary": ["This package contains a number of URDF tutorials."], "package_details": ["This package is intended to be used in conjunction with the", "."]},
{"url": "https://wiki.ros.org/moveit_ros_visualization", "package": "moveit_ros_visualization", "package_summary": ["Components of MoveIt that offer visualization"], "package_details": []},
{"url": "https://wiki.ros.org/librealsense", "package": "librealsense", "package_summary": [], "package_details": ["is a cross-platform library (Linux, OSX, Windows) for capturing data from the Intel\u00ae", "\u2122 R200, F200, and SR300 cameras. This effort was initiated to better support researchers, creative coders, and app developers in domains such as robotics, virtual reality, and the internet of things. Several often-requested features of", "\u2122 devices are implemented in this project, including multi-camera capture.", "requires patches to the", "loadable kernel module to support various cameras. Intel\u00ae", "\u2122 R200 camera support is upstreamed in the 4.4.x linux kernel, but older kernels and all other Intel\u00ae", "\u2122 cameras require patches.", "Developer kits containing the necessary hardware to use this library are", ". This project is separate from the production software stack available in the", ", namely that this library only encompasses camera capture functionality without additional computer vision algorithms.", "Update your", "file and/or", "to uncomment (or add) the", "entries for all of the entries for the", "repositories. Below is an", "for ubuntu 16.04 (Xenial).", "The library is a ROS Debian packaging of the more generic cross-platform library. The packaging and release is maintained by the team supporting the various ROS", "packages. Please", "concerning this package to the realsense_camera", "Issues.", "For updated details on this library see the", "."]},
{"url": "https://wiki.ros.org/sr_config", "package": "sr_config", "package_summary": ["sr_config"], "package_details": ["- Contains the configuration files for a specific hand/customer installation."]},
{"url": "https://wiki.ros.org/kobuki_dock_drive", "package": "kobuki_dock_drive", "package_summary": ["Dock driving library for Kobuki. Users owning a docking station for Kobuki \n\t    can use this tool to develop autonomous docking drive algorithms."], "package_details": []},
{"url": "https://wiki.ros.org/random_numbers", "package": "random_numbers", "package_summary": ["This  library contains wrappers for generating floating point values, integers, quaternions using boost libraries.\n\n  The constructor of the wrapper is guaranteed to be thread safe and initialize its random number generator to a random seed.\n  Seeds are obtained using a separate and different random number generator."], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_simulator", "package": "turtlebot_simulator", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jsk_robot", "package": "jsk_robot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/hardware_interface", "package": "hardware_interface", "package_summary": ["Hardware Interface base class."], "package_details": ["See the", "page and the", "for more information."]},
{"url": "https://wiki.ros.org/phidgets_high_speed_encoder", "package": "phidgets_high_speed_encoder", "package_summary": ["Driver for the Phidgets high speed encoder devices"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_network_tools", "package": "jsk_network_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jsk_roseus", "package": "jsk_roseus", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/swri_console_util", "package": "swri_console_util", "package_summary": ["swri_console_util"], "package_details": []},
{"url": "https://wiki.ros.org/jackal_msgs", "package": "jackal_msgs", "package_summary": ["Messages exclusive to Jackal, especially for representing low-level motor commands and sensors."], "package_details": ["These messages are the low-level interface between", "'s ARM MCU and integrated PC. Most users of Jackal should be able to use standard ROS interfaces (eg.", ",", ") to command and monitor the robot. Possible exceptions are:"]},
{"url": "https://wiki.ros.org/moveit_ros_control_interface", "package": "moveit_ros_control_interface", "package_summary": ["ros_control controller manager interface for MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/moveit_simple_controller_manager", "package": "moveit_simple_controller_manager", "package_summary": ["A generic, simple controller manager plugin for MoveIt."], "package_details": []},
{"url": "https://wiki.ros.org/task_compiler", "package": "task_compiler", "package_summary": ["task_compiler\n\n     Compiler that translate task description in PDDL (Planning Domain Description Language) to SMACH (state machine based execution and coordination system) description."], "package_details": []},
{"url": "https://wiki.ros.org/pilz_extensions", "package": "pilz_extensions", "package_summary": ["The pilz_extensions package. Here are classes extending the functionality of other packages.\n  On the long run these extensions should become pull requests on the respective packages."], "package_details": []},
{"url": "https://wiki.ros.org/kinesis_video_msgs", "package": "kinesis_video_msgs", "package_summary": ["Messages for transmitting video frames to Kinesis Video Streams"], "package_details": []},
{"url": "https://wiki.ros.org/resized_image_transport", "package": "resized_image_transport", "package_summary": ["ROS nodes to publish resized images."], "package_details": []},
{"url": "https://wiki.ros.org/zeroconf_avahi_demos", "package": "zeroconf_avahi_demos", "package_summary": [], "package_details": ["for getting the launchers up and running with some scripts."]},
{"url": "https://wiki.ros.org/jsk_tilt_laser", "package": "jsk_tilt_laser", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/costmap_queue", "package": "costmap_queue", "package_summary": ["Tool for iterating through the cells of a costmap to find the closest distance to a subset of cells."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_bag_plugins", "package": "rqt_bag_plugins", "package_summary": ["rqt_bag provides a GUI plugin for displaying and replaying ROS bag files."], "package_details": ["To access these plugins, launch the", "GUI tool (see", "for details), right-click on the timeline of the desired topic select a view type from the context menu.", "The following plugins are currently provided for", ":", "The image view displays raw image data for", "and", "messages:", "The plot view displays a time series plot of numeric fields in a ROS message. The view inherits from the", "code base, so all plotting options are the same as with", "."]},
{"url": "https://wiki.ros.org/prbt_support", "package": "prbt_support", "package_summary": ["Mechanical, kinematic and visual description\n  of the Pilz light weight arm PRBT."], "package_details": []},
{"url": "https://wiki.ros.org/lanelet2_validation", "package": "lanelet2_validation", "package_summary": ["Package for sanitizing lanelet maps"], "package_details": ["To test a map, simply run", ", or better", ", where lat/lon is an origin close to your map data. The tool will output errors and warnings that were found in your map.", "For advanced usage like running only a fraction of the tests, try", "."]},
{"url": "https://wiki.ros.org/dynamic_tf_publisher", "package": "dynamic_tf_publisher", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jsk_robot_startup", "package": "jsk_robot_startup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt", "package": "rqt", "package_summary": ["rqt is a Qt-based framework for GUI development for ROS. It consists of three parts/metapackages"], "package_details": ["(also builds against fuerte)", "is a software framework of", "that implements the various GUI tools in the form of plugins. One can run all the existing GUI tools as dockable windows within rqt! The tools can still run in a traditional standalone method, but rqt makes it easier to manage all the various windows on the screen at one moment.", "supercedes the former GUI tools of ROS", ", which now is deprecated since ROS", ".", "consists of three (+1)", ":", "You can run any", "tools/plugins easily by:", "Users can create their own plugins for rqt with either", "or", ".", "(as of Feb 2013) have already been created and more are slated for development.", "There's a policy for the development repositories of", "and", "(", "):"]},
{"url": "https://wiki.ros.org/rviz_python_tutorial", "package": "rviz_python_tutorial", "package_summary": ["Tutorials showing how to call into rviz internals from python scripts."], "package_details": []},
{"url": "https://wiki.ros.org/imu_sensor_controller", "package": "imu_sensor_controller", "package_summary": ["Controller to publish state of IMU sensors"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/youbot_gazebo_worlds", "package": "youbot_gazebo_worlds", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rtmbuild", "package": "rtmbuild", "package_summary": ["Build scripts for OpenRTM and OpenHRP"], "package_details": []},
{"url": "https://wiki.ros.org/joint_trajectory_controller", "package": "joint_trajectory_controller", "package_summary": ["Controller for executing joint-space trajectories on a group of joints."], "package_details": ["Even when a goal has been aborted, the controller will still attempt to execute the trajectory as best as possible.", "The controller is templated to work with multiple hardware interface types.  Currently joints with", ",", "and", "interfaces are supported. For position-controlled joints, desired positions are simply forwarded to the joints; while for velocity (effort) joints, the position+velocity trajectory following error is mapped to velocity (effort) commands through a PID loop. Example controller configurations can be found", ".", "There are two mechanisms for sending trajectories to the controller: by means of the", "or the", ". Both use the", "message to specify trajectories, and require specifying values for", "the controller joints (as opposed to only a subset) if allow_partial_joints_goal is not set to True.", "The primary way to send trajectories is through the", ", and should be favored when execution monitoring is desired. Action goals allow to specify not only the trajectory to execute, but also (optionally) path and goal tolerances. When no tolerances are specified, the defaults given in the parameter server are used (see", "below). If tolerances are violated during trajectory execution, the action goal is aborted and the client is notified.", "The", "is a fire-and-forget alternative. Use this interface if you don't care about execution monitoring. The controller's path and goal tolerance specification is", "used in this case, as there is no mechanism to notify the sender about tolerance violations. Note that although some degree of monitoring is available through the", "service and", "topic (see", "below), it is much more cumbersome to realize than with the action interface.", "Only one action goal can be active at any moment, or none if the topic interface is used. Path and goal tolerances are checked", "for the trajectory segments of the active goal.", "Sending an", "message from the", "(not the action interface) will stop the execution of all queued trajectories and enter position hold mode. The", "parameter controls the duration of the stop motion.", "Joint trajectory messages allow to specify the time at which a new trajectory should start executing by means of the header timestamp, where zero time (the default) means", ".", "The arrival of a new trajectory command does", "mean that the controller will completely discard the currently running trajectory and substitute it with the new one. Rather, the controller will take the useful parts of both and combine them appropriately. Please refer to the", "page for a detailed description of this behavior.", "The controller exposes a", "interface in the", "namespace of the controller. See the action definition for more information on what to send."]},
{"url": "https://wiki.ros.org/mavros_extras", "package": "mavros_extras", "package_summary": ["Extra nodes and plugins for", "."], "package_details": ["only.", "Require", "package, use", ".", "This package provides additional nodes and plugins not included to", ".", "All utilities provides <util> --help and <util> <command> --help information.", "Extra set of communication plugins loaded by", "."]},
{"url": "https://wiki.ros.org/rosflight_firmware", "package": "rosflight_firmware", "package_summary": ["Firmware library for software-in-the-loop of the ROSflight ROS stack"], "package_details": ["This package provides a ROS wrapper for the", ", and also provides a board implementation with UDP serial communication functionality. These are used by the", "package for software-in-the-loop simulation."]},
{"url": "https://wiki.ros.org/py_trees_msgs", "package": "py_trees_msgs", "package_summary": ["Messages used by py_trees_ros and some extras for the mock demos/tests."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_srv", "package": "rqt_srv", "package_summary": ["A Python GUI plugin for introspecting available ROS message types.\n  Note that the srvs available through this plugin is the ones that are stored\n  on your machine, not on the ROS core your rqt instance connects to."], "package_details": []},
{"url": "https://wiki.ros.org/velodyne_msgs", "package": "velodyne_msgs", "package_summary": ["ROS message definitions for Velodyne 3D LIDARs."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"velodyne_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/velodyne_msgs/manifest.yaml", "This package collects all ROS messages that are specific to Velodyne 3D LIDARs, simplifying the dependencies between", "stack components and their users.", "It also provides bag migration scripts for translating old captured data to the latest format using the", "command."]},
{"url": "https://wiki.ros.org/yocs_virtual_sensor", "package": "yocs_virtual_sensor", "package_summary": ["Virtual sensor that uses semantic map information to \"see\" obstacles undetectable by robot sensors.\n      \n      Current implementation cannot read obstacles from YAML files. Until this feature gets implemented, we\n      use auxiliary scripts to read and publish files' content. Data directory contains some example files."], "package_details": []},
{"url": "https://wiki.ros.org/bayesian_belief_networks", "package": "bayesian_belief_networks", "package_summary": ["The bayesian_belief_networks package form https://github.com/eBay/bayesian-belief-networks, Authored by Neville Newey, Anzar Afaq, Copyright 2013 eBay Software Foundation"], "package_details": []},
{"url": "https://wiki.ros.org/nav2_bringup", "package": "nav2_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roslisp", "package": "roslisp", "package_summary": ["Lisp client library for ROS, the Robot Operating System."], "package_details": ["See the", "for a guide to roslisp's features.", "Roslisp is part of the stable ROS core distribution, and follows the", ".", "See the", "for future changes.", "Roslisp is based on the", "version of Common Lisp. It is defined as a system dependency in the roslisp ROS package."]},
{"url": "https://wiki.ros.org/rosbridge_library", "package": "rosbridge_library", "package_summary": ["The core rosbridge package, responsible for interpreting JSON and performing\n    the appropriate ROS action, like subscribe, publish, call service, and\n    interact with params."], "package_details": ["Rosbridge library is a Python library responsible for taking JSON strings and converting them to ROS messages, and vice versa. Rosbridge library is meant to be used as a library for transport layer packages. For example, the rosbridge_server package creates a", "connection and uses the rosbridge library to handle the JSON to ROS conversion."]},
{"url": "https://wiki.ros.org/seed_r7_typef_moveit_config", "package": "seed_r7_typef_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the SEED-Noid-Mover-typeF with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/qt_gui", "package": "qt_gui", "package_summary": ["qt_gui provides the infrastructure for an integrated graphical user interface based on Qt.\n    It is extensible with Python- and C++-based plugins (implemented in separate packages) which can contribute arbitrary widgets.\n    It requires either PyQt or PySide bindings."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_joint_trajectory_plot", "package": "rqt_joint_trajectory_plot", "package_summary": ["The rqt_joint_trajectory_plot package"], "package_details": ["This package is to plot", "message and", "action in real time.", "Then launch", "!", "Now you can control the UR5 using", ".", "Then run rqt and add", "plugin. Choose the trajectory topic."]},
{"url": "https://wiki.ros.org/librealsense2", "package": "librealsense2", "package_summary": ["Library for controlling and capturing data from the Intel(R) RealSense(TM) D400 devices."], "package_details": ["is a cross-platform library (Linux, OSX, Windows) for capturing data from the Intel\u00ae", "\u2122 SR300 and D400 cameras. It allows depth and color streaming, and provides intrinsic and extrinsic calibration information. The library also offers synthetic streams (pointcloud, depth aligned to color and vise-versa), and a built-in support for record and playback of streaming sessions.", "This effort was initiated to better support researchers, creative coders, and app developers in domains such as robotics, virtual reality, and the internet of things. Several often-requested features of", "\u2122 devices are implemented in this project, including multi-camera capture.", "The Intel\u00ae", "\u2122 D415 and D435 cameras are", ".", "Installation instructions can be found", ".", "The library is a ROS Debian packaging of the more generic cross-platform library. The packaging and release is maintained by the team supporting the various ROS", "packages. Please", "concerning this package to the realsense2_camera", "Issues.", "For updated details on this library see the", "."]},
{"url": "https://wiki.ros.org/jsk_common", "package": "jsk_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_ros_warehouse", "package": "moveit_ros_warehouse", "package_summary": ["Components of MoveIt connecting to MongoDB"], "package_details": []},
{"url": "https://wiki.ros.org/astra_camera", "package": "astra_camera", "package_summary": ["Drivers for Orbbec Astra Devices."], "package_details": ["If you didn't add source $YOUR_WORKSPACE/devel/setup.bash to your .bashrc, remember to source it when open a new terminal", "This package provides multiple", "for users to get useful information and set up devices. To know more about using these services, please check", "."]},
{"url": "https://wiki.ros.org/swri_yaml_util", "package": "swri_yaml_util", "package_summary": ["Provides wrappers around the yaml-cpp library for various utility functions\n    and to abstract out the API changes made to yaml-cpp between ubuntu:precise\n    and ubuntu:trusty."], "package_details": []},
{"url": "https://wiki.ros.org/wireless_msgs", "package": "wireless_msgs", "package_summary": ["Messages for describing a wireless network such as bitrate, essid, and link quality."], "package_details": []},
{"url": "https://wiki.ros.org/mavros", "package": "mavros", "package_summary": ["MAVROS -- MAVLink extendable communication node for ROS\n    with proxy for Ground Control Station."], "package_details": ["only.", "Main node can be extended by plugins (see", "). See also", "package.", "If you unsure what firmware your FCU runs start apm.launch and see", ".", "Starting from 0.11 mavros knows string representation for autopilot mavlink enum.", "For older you shall manually find autopilot type value in mavlink documentation.", "All utilities provides", "and", "information.", "Supported custom modes listed at", ".", "Standard set of communication plugins loaded by", ".", "Note: this list for", "version.", "Older versions:", ",", ",", ",", ",", ",", ",", "."]},
{"url": "https://wiki.ros.org/jackal_control", "package": "jackal_control", "package_summary": ["Controllers for Jackal"], "package_details": ["'s mobility is controlled by", "."]},
{"url": "https://wiki.ros.org/joint_qualification_controllers", "package": "joint_qualification_controllers", "package_summary": ["Controllers used in PR2 hardware testing. For testing counterbalance of PR2, and for internal WG use."], "package_details": []},
{"url": "https://wiki.ros.org/moveit", "package": "moveit", "package_summary": ["Meta package that contains all essential package of MoveIt. Until Summer 2016 MoveIt had been developed over multiple repositories, where developers' usability and maintenance effort was non-trivial. See", "."], "package_details": ["All documentation for", "is on the", "."]},
{"url": "https://wiki.ros.org/jackal_navigation", "package": "jackal_navigation", "package_summary": ["Launch files and code for autonomous navigation of the Jackal"], "package_details": ["The jackal_navigation package contains configuration and launch files for running", "on", ".", "For usage, please see", "."]},
{"url": "https://wiki.ros.org/velocity_controllers", "package": "velocity_controllers", "package_summary": ["velocity_controllers"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/jsk_baxter_startup", "package": "jsk_baxter_startup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/velodyne_driver", "package": "velodyne_driver", "package_summary": ["ROS device driver for Velodyne 3D LIDARs."], "package_details": [": the", "parameter now expects an exact name: \"VLP16\", \"32C\", \"32E\", \"64E\", \"64E_S2\", \"64E_S2.1\", or \"64E_S3\", and generates the correct packet rates for them.", ": The VLP-16 (\"Puck\") model is now supported.", ": The VLP-32C (\"Ultra Puck\") model is now supported.", ": The HDL-64E S3 model is now supported.", "This package provides basic device handling for Velodyne 3D LIDARs. For a list of all supported models refer to the", "section.", "The driver publishes device-dependent", "data. The", "package provides nodes and nodelets to convert those data into more-convenient", "messages.", "The", "describes the evolution of these interfaces.", "Read the Velodyne HDL-64E (default) input socket as fast as possible. Publish each complete revolution to", ".", "Read the Velodyne Velodyne HDL-32E input socket as fast as possible. Publish each complete revolution to", ".", "Read previously captured Velodyne packets from dump.pcap file. Publish messages to", "at approximately 10 Hz rate. Dump files can be grabbed by", ", Velodyne's DSR software,", ",", ",", ", or the", "command.", "The", "command dumps raw data from the Velodyne LIDAR in PCAP format. It is a shell script wrapper providing some obscure options for the powerful", "command.", "Other methods of acquiring PCAP data include using", "directly,", ", Velodyne's DSR software, and programming with", ".", "Dump Velodyne packets from the", "interface to a series of files named", ",", ", etc. Each file will be about 100MB. The time span that a single 100MB file covers depends on packet size and sampling rate of a particular model (for VLP-16 that is about 100 seconds worth of packets). Type", "when finished.", "Start a", "process running the driver nodelet. Other nodelets using the same nodelet manager process will have zero-copy access to the raw data messages the driver publishes.", "Start a", "process for a Velodyne HDL-32E.", "Start a driver nodelet with input from", ", in the current directory. The", "provides a full path name, as required for", "."]},
{"url": "https://wiki.ros.org/ypspur_ros", "package": "ypspur_ros", "package_summary": ["ROS wrapper for the mobile robot control platform YP-Spur"], "package_details": []},
{"url": "https://wiki.ros.org/rqt_runtime_monitor", "package": "rqt_runtime_monitor", "package_summary": ["rqt_runtime_monitor provides a GUI plugin viewing DiagnosticsArray messages."], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_navigation", "package": "mrpt_navigation", "package_summary": ["Tools related to the Mobile Robot Programming Toolkit (MRPT).\n    Refer to https://wiki.ros.org/mrpt_navigation for further documentation."], "package_details": [": This wiki refers to the obsolete ROS 1 mrpt_navigation package.", "The documentation for the latest ROS 2 versions is here:", "Use GitHub to", ". [", "]", "See also:", "."]},
{"url": "https://wiki.ros.org/rqt_controller_manager", "package": "rqt_controller_manager", "package_summary": ["Graphical frontend for interacting with the controller manager."], "package_details": []},
{"url": "https://wiki.ros.org/serial", "package": "serial", "package_summary": ["Serial is a cross-platform, simple to use library for using serial ports on computers.\n    This library provides a C++, object oriented interface for interacting with RS-232\n    like devices on Linux and Windows."], "package_details": ["The serial package is documented on its website:"]},
{"url": "https://wiki.ros.org/jackal_robot", "package": "jackal_robot", "package_summary": [], "package_details": ["Metapackage capturing software to be installed on", "."]},
{"url": "https://wiki.ros.org/librviz_tutorial", "package": "librviz_tutorial", "package_summary": ["Tutorial showing how to compile your own C++ program with RViz displays and features."], "package_details": ["Please see the", "page."]},
{"url": "https://wiki.ros.org/yocs_ar_marker_tracking", "package": "yocs_ar_marker_tracking", "package_summary": ["Collecting, tracking and generating statistics for ar markers from ar_track_alvar."], "package_details": []},
{"url": "https://wiki.ros.org/hrpsys_tools", "package": "hrpsys_tools", "package_summary": ["The hrpsys_tools package"], "package_details": []},
{"url": "https://wiki.ros.org/stomp_plugins", "package": "stomp_plugins", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_reactivenav2d", "package": "mrpt_reactivenav2d", "package_summary": ["Reactive navigation for 2D robots using MRPT navigation algorithms (TP-Space)"], "package_details": ["After installing", "and", ", run:"]},
{"url": "https://wiki.ros.org/yumi_moveit_config", "package": "yumi_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xv_11_laser_driver", "package": "xv_11_laser_driver", "package_summary": ["Neato XV-11 Laser Driver. This driver works with the laser when it is removed from the XV-11 Robot as opposed to reading scans from the Neato's USB port."], "package_details": ["is a C++ library for reading the data from the XV11's laser and packing that data into a", ". As a standalone library, it has no ROS API."]},
{"url": "https://wiki.ros.org/ff", "package": "ff", "package_summary": ["ff: pddl planner. see http://www.loria.fr/~hoffmanj/ff.html"], "package_details": []},
{"url": "https://wiki.ros.org/plotjuggler", "package": "plotjuggler", "package_summary": ["PlotJuggler: juggle with data"], "package_details": ["Find out more here:"]},
{"url": "https://wiki.ros.org/single_joint_position_action", "package": "single_joint_position_action", "package_summary": ["The single joint position action is a node that provides an action\n  interface for commanding a trajectory to move a joint to a particular\n  position. The action reports success when the joint reaches the desired\n  position."], "package_details": ["See also", ", which is used by this action.", "You can find an example of using the single joint position action on the PR2 in the", ".", "The joint trajectory action provides an action server (see", ") that takes in goals of the type", "."]},
{"url": "https://wiki.ros.org/controller_manager_tests", "package": "controller_manager_tests", "package_summary": ["Tests for the controller manager."], "package_details": []},
{"url": "https://wiki.ros.org/web_video_server", "package": "web_video_server", "package_summary": ["HTTP Streaming of ROS Image Topics in Multiple Formats"], "package_details": ["(", ", default: original width)", "(", ", default: 95)", "(", ", default: mjpeg)", "(", ", default: 95)", "(", ", default: 100000)", "Several parameters can be configure via the video stream URL - Example:", "More information on the quality and profile parameter of the VP8 codec can be found here:", "Rate at which", "subscribes a image topic depends on the publisher's publish rate. With a fast publish rate, a client host may unintentionally get busy.", "As of version 0.2.1,", "does not come with a feature to control the rate at which the frontend subscribes to an image topic. You can work this around on your client.", "One way is to republish the image topic with a lower rate. You can use", ".", "View compressed stream at:", "Source code is available at", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/moveit_ros_planning_interface", "package": "moveit_ros_planning_interface", "package_summary": ["Components of MoveIt that offer simpler interfaces to planning and execution"], "package_details": []},
{"url": "https://wiki.ros.org/leap_motion", "package": "leap_motion", "package_summary": ["ROS driver for the Leap Motion gesture sensor"], "package_details": ["is a ROS wrapper for interfacing with the Leap Motion 3D gesture sensor API (", "). For the most up to date information you can check our Github repository", "."]},
{"url": "https://wiki.ros.org/laser_proc", "package": "laser_proc", "package_summary": ["laser_proc"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_head_action", "package": "pr2_head_action", "package_summary": ["The PR2 head action is a node that provides an action interface for\n  pointing the head of the PR2.  It passes trajectory goals to the\n  controller, and reports success when they have finished executing."], "package_details": ["See", "for information on the controller that the head action communicates with.", "An example of using the head action on the PR2 can be found in the", ".", "The joint trajectory action provides an action server (see", ") that takes in goals of the type", ".  It reports success when the head is pointed at the target."]},
{"url": "https://wiki.ros.org/jackal_description", "package": "jackal_description", "package_summary": ["URDF robot description for Jackal"], "package_details": ["This package provides a", "model of", ". For an example launchfile to use in visualizing this model, see", ".", "Jackal has a suite of optional payloads called accessories. These payloads can be enabled and placed on Jackal using environment variables specified at the time the", "is rendered to URDF. Available accessory vars are:", "As an alternative to individually specifying each accessory, some fixed configurations are provided in the package. These can be specified using the", "arg to", ", and are intended especially as a convenience for simulation launch.", "Please see", "for more information on simulating Jackal."]},
{"url": "https://wiki.ros.org/xpp_examples", "package": "xpp_examples", "package_summary": ["Examples of how to use the xpp framework."], "package_details": []},
{"url": "https://wiki.ros.org/qwt_dependency", "package": "qwt_dependency", "package_summary": ["This encapsulates the Qwt dependency for a specific ROS distribution and its Qt version"], "package_details": []},
{"url": "https://wiki.ros.org/um7", "package": "um7", "package_summary": ["The um7 package provides a C++ implementation of the CH Robotics serial protocol, and a\n    corresponding ROS node for publishing standard ROS orientation topics from a UM7."], "package_details": ["the \"port\" assignment actually defaults to \"/dev/ttyUSB0\", so if your sensor is on that port, the parameter setting shown above is unnecessary.", "if you get a \"Couldn't find executable named um7_driver below /opt/ros/$ROS_DISTRO/share/um7\" message, try restarting linux.  I don't know why; but it has happened to me a couple times.  It should only happen on the first attempt to run.", "To clarify data polarities, I will describe them in terms of aircraft motion.  NU/ND is aircraft nose up (as in climbing or nose down as in descent.   RWD/LWD is right wing down as in an aircraft turning to the right in flight; left wing down to turn to the left.  NR/NL is nose right as if the aircraft is turning right on the ground, and nose left for turn to the left."]},
{"url": "https://wiki.ros.org/libuvc_ros", "package": "libuvc_ros", "package_summary": ["libuvc_ros metapackage"], "package_details": []},
{"url": "https://wiki.ros.org/marker_rviz_plugin", "package": "marker_rviz_plugin", "package_summary": ["The marker_rviz_plugin package contains RViz plugins to visualize messages of the marker_msgs package using RViz."], "package_details": []},
{"url": "https://wiki.ros.org/downward", "package": "downward", "package_summary": ["fast downward: PDDL Planner (http://www.fast-downward.org)"], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_graphslam_2d", "package": "mrpt_graphslam_2d", "package_summary": ["Implement graphSLAM using the mrpt-graphslam library, in an online fashion\n  \tby directly reading measurements off ROS Topics."], "package_details": ["mrpt_graphslam_2d provides support for running either single-robot or multi-robot pose-only graphSLAM, using simulated data (e.g. from Gazebo) or in a real-time setup. Algorithm practically utilises the", "to execute graphSLAM, using the ROS communication mechanisms and the", "stack.", "Information on how to use the algorithm for either simulation or real-time usage is provided in the Appendix of", "Additional support for running real-time graphSLAM with either one or with multiple agents is provided in the", "ROS package. The latter provides launchfiles and generic scripts for setting up common tasks in real robot agents (setting up sensor data acquisition processes, processes for starting robot motors etc.) Package is specialized for the robots and equipment of the", "of the", "but can be easily extended to suppport different platforms, sensors etc.", "Additional support for running simulations in Gazebo is provided in the", "ROS package", "See", "Package also contains sample datasets, along with the corresponding roslaunch files for easy execution, for both the single- and multi-robot SLAM cases. For more on this see the", ".", "Use the", "tool to generate the complete API of this package:", "*", "*", "*"]},
{"url": "https://wiki.ros.org/youbot_gazebo_robot", "package": "youbot_gazebo_robot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_ekf_slam_3d", "package": "mrpt_ekf_slam_3d", "package_summary": ["This package is a wrapper for the implementation of EKF-based SLAM with range-bearing sensors, odometry, a full 6D robot pose, and 3D landmarks."], "package_details": ["The ROS node mrpt_ekf_slam_3d is a wrapper for the C++ class", ", part of MRPT. Thus, check out the documentation of that class for further details.", "For the convention on coordinate frames see", ".", "In order to use mrpt_ekf_slam_3d package it is necessary to install the last", "build and the", "(see also the", ") ."]},
{"url": "https://wiki.ros.org/warehouse_ros", "package": "warehouse_ros", "package_summary": ["Persistent storage of ROS messages"], "package_details": []},
{"url": "https://wiki.ros.org/roseus", "package": "roseus", "package_summary": ["EusLisp client for ROS Robot Operating System."], "package_details": ["See", "for tutorials, also you may look at", "packages for example codes.", "Please send bug report to", "."]},
{"url": "https://wiki.ros.org/moveit_ros_manipulation", "package": "moveit_ros_manipulation", "package_summary": ["Components of MoveIt used for manipulation"], "package_details": []},
{"url": "https://wiki.ros.org/sick_safetyscanners", "package": "sick_safetyscanners", "package_summary": ["Provides an Interface to read the sensor output of a SICK\n  Safety Scanner"], "package_details": ["In the following instructions, replace", "with the name of your ROS distro (e.g.,", ").", "In case of technical support please open a new issue. Under"]},
{"url": "https://wiki.ros.org/pilz_robot_programming", "package": "pilz_robot_programming", "package_summary": ["An Easy to use API to execute standard industrial robot commands like Ptp, Lin, Circ and Sequence using Moveit."], "package_details": ["For package documentation please see the", "."]},
{"url": "https://wiki.ros.org/moveit_setup_assistant", "package": "moveit_setup_assistant", "package_summary": ["Generates a configuration package that makes it easy to use MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/ros_base", "package": "ros_base", "package_summary": ["A metapackage which extends ros_core and includes other basic non-robot tools like actionlib, dynamic reconfigure, nodelets, and pluginlib."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_image_view", "package": "rqt_image_view", "package_summary": ["rqt_image_view provides a GUI plugin for displaying images using image_transport."], "package_details": ["is an", "version of", "(however, as of Mar 2015, they are separately implemented and there's no dependency in-between each package. See", "for more info).", "allows you to open multiple", "windows and dock into a single window like this."]},
{"url": "https://wiki.ros.org/qt_gui_app", "package": "qt_gui_app", "package_summary": ["qt_gui_app provides the main to start an instance of the integrated graphical user interface provided by qt_gui."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_topic_tools", "package": "jsk_topic_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosdoc_lite", "package": "rosdoc_lite", "package_summary": ["This ROS package wraps documentation tools like doxygen, sphinx,\n    and epydoc, making it convenient to generate ROS package\n    documentation.\n\n    It also generates online documentation for the ROS wiki."], "package_details": ["is a simple program that runs an external documentation tool, like", ",", ", or", ", on a single ROS", ". It was built as a light-weight replacement to the", "tool and uses the same", "file format to assist in porting. We recommend trying", "instead of attempting to setup those tools manually, as it provides shortcuts for configuring those tools and can also import additional ROS information. Configuring your package to be documented by", "also has the additional benefit of allowing your package to be indexed for inclusion on the ROS wiki.", "makes a best effort at providing good default settings to these tools, and in some cases allows these settings to be customized further.", "is used as part of an automated process for updating documentation on ros.org. It is frequently run on repositories that have", "files listed in the", "repository, with the resulting documentation linked to in the \"Code API\" link of many packages' on", ".", "contains some additional functionality for generating machine-readable documentation files, as well as", "/", "documentation, that are used by the ros.org wiki system and elsewhere. This functionality is mainly only of use to those maintaining documentation Web sites.", ":", ": Epydoc's \"introspection\" capability currently breaks when trying to process some ros python modules, so this feature should not be enabled in a custom epydoc config file.", "provides support for cross-referencing with external", "documentation using tag files. For more information on using tag files with", "to link to external documentation, see this", ".", "can be passed a yaml file containing a list of tagfiles with the", "option. This yaml file should contain a list of dictionaries, where each dictionary has the following standard keys:", "is automatically run for packages in repositories that have rosinstall files listed in the", "repository. The resulting documentation is uploaded to", "and is linked in the \"Code API\" links that you see on various package pages, like", ".", "See also:", ",", ", and", "By default,", "will use", "to generate the documentation for a package. If you wish to use another tool, like", "or", ", you must use a rosdoc configuration file. This is described below.  For C/C++, only Doxygen is advised.", "The documentation that is generated will depend on which tool is used, as each tool behaves differently.  For example, Doxygen will extract API details from all source files found in the package (see", "for more).", "You can use", "to generate local copies of documentation. When you run the", "command, it will generate documentation into the 'doc' folder of the local directory.", "In order to enable the rosdoc configuration file, simply have a", "file in the root of your package. If you wish to name it something else, you must place the following tag in the", "section of the", ", but this behavior is old:", "Here is an example from the", "package, which performs both C++ and Python API documentation:", "The \"doxygen\" builder will enable running", "on a package. As Doxygen is the default builder for any package, it is only necessary to configure this option if:", "The \"epydoc\" builder will enable running", "on a package.", "The \"sphinx\" builder will enable running", "on a package.", "The \"external\" builder specifies that you wish to link to externally generated documentation.", "will generate a landing page with the link to the specified URL.", "To generate a tag file during a documentation run, simply pass the", "option to rosdoc lite with a path to the desired location of the tagfile. For example:", "Running", "with this file to get cross references might look something like this:", "Even if", "is automatically generated for your package, we recommend regularly running", "on your own computer to verify what your documentation looks like before checking it in.", "It is also used to generate the data for the", ",", "and", "wiki macros that you see on many of the ros.org wiki pages.", "The", "tool itself is stable, though it has many internal features and functionality that are changed to support the documentation needs of", ". In the future, the", "tool will hopefully be evolved to better support the configuration requirements of the documentation tools it invokes (i.e. Doxygen).", "The code API of", "should", "be used as it is an internal library that is frequently changed."]},
{"url": "https://wiki.ros.org/controller_interface", "package": "controller_interface", "package_summary": ["Interface base class for controllers."], "package_details": ["See the", "page and the", "for more information."]},
{"url": "https://wiki.ros.org/slic", "package": "slic", "package_summary": ["SLIC-Superpizel ROS Wrapper\n  This file contains the class elements of the class Slic. This class is an\n  implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,\n  vol. 34, num. 11, pp. 2274-2282].\n\n  This implementation is created for the specific purpose of creating\n  over-segmentations in an OpenCV-based environment."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_apc", "package": "jsk_apc", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/urdf_geometry_parser", "package": "urdf_geometry_parser", "package_summary": ["Extract geometry value of a vehicle from urdf."], "package_details": []},
{"url": "https://wiki.ros.org/pilz_msgs", "package": "pilz_msgs", "package_summary": ["The pilz_msgs package"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_controllers", "package": "pr2_controllers", "package_summary": ["Contains the controllers that run in realtime on the PR2 and supporting packages."], "package_details": ["The", "stack has the components which must run in the realtime loop of the PR2, components which communicate with the realtime controllers, and a few supporting packages.  Realtime controllers run in the", "at a guaranteed update rate and are used for moving the mechanism and triggering sensing components.  The supporting nodes provide a more user-friendly interface to the realtime components, often providing notification on success or failure of commands.", "A full set of controllers and supporting nodes has been configured to come up on the PR2 by default.  See", "for instruction on how to use them.", "Report new issues on"]},
{"url": "https://wiki.ros.org/dwb_critics", "package": "dwb_critics", "package_summary": ["Implementations for dwb_local_planner TrajectoryCritic interface"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_visualization", "package": "jsk_visualization", "package_summary": [], "package_details": ["Document:"]},
{"url": "https://wiki.ros.org/rqt_msg", "package": "rqt_msg", "package_summary": ["A Python GUI plugin for introspecting available ROS message types.\n  Note that the msgs available through this plugin is the ones that are stored\n  on your machine, not on the ROS core your rqt instance connects to."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_shell", "package": "rqt_shell", "package_summary": ["rqt_shell is a Python GUI plugin providing an interactive shell."], "package_details": []},
{"url": "https://wiki.ros.org/ros_environment", "package": "ros_environment", "package_summary": ["The package provides the environment variables `ROS_VERSION`, `ROS_DISTRO`, `ROS_PACKAGE_PATH`, and `ROS_ETC_DIR`."], "package_details": []},
{"url": "https://wiki.ros.org/staro_moveit_config", "package": "staro_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/velodyne_pointcloud", "package": "velodyne_pointcloud", "package_summary": ["Point cloud conversions for Velodyne 3D LIDARs."], "package_details": [": the default", "value is now 0.9 meters.", ": a new pair of parameters", "and", "may be used to reduce the output point cloud to a subset of angular directions. By default, every angle is included in the point cloud. Setting", "to", "radians will limit the output to 90 degrees around the forward direction of the device (from -45 degrees to +45). Also setting", "to", "would return output only from the device's rear facing, instead. Similarly, setting", "to", "would limit output to 90 degrees around the right facing in the XY plane of the device frame of reference.", "This package provides point cloud conversions for Velodyne 3D LIDARs. For a list of all supported models refer to the", "section.", "The", "describes the evolution of these interfaces.", "Continuously convert raw Velodyne packets into", "messages.", "This launch file runs the cloud nodelet in the same process with the device driver.", "The full path name of the calibration file", "be provided. This example uses one of the package test files for calibration.", "Continuously convert raw Velodyne packets into", "messages.", "Transform raw Velodyne packets into", "messages into the", "frame.", "This launch file runs the transform nodelet in the same process with the device driver.", "The full path name of the calibration file", "be provided. This example uses one of the package test files.", "Transform raw Velodyne packets into", "messages into the", "frame.", "Transform raw Velodyne packets into", "messages into the", "frame.", "In two separate terminal windows, start a", "process running the driver nodelet and the cloud nodelet, which will have zero-copy access to the raw data messages the driver publishes.", "Start a driver nodelet with input from", ", in the current directory. The", "provides a full path name, as required for", ". In another terminal, start the transform nodelet, to publish the data points transformed into the /odom frame of reference.", "Start a", "process for a Velodyne HDL-32E. This script runs both the driver and the point cloud conversion, providing the standard HDL-32E calibration.", "Start another", "for the Velodyne HDL-32E, but provide a PCAP dump file as input.", "This script generates a YAML calibration file for use by this package from the", "file that was provided by Velodyne with the device.", "Read", "from the current directory, writing the required calibration data to", ".", "Save generated 32E calibration data in", "."]},
{"url": "https://wiki.ros.org/robot_mechanism_controllers", "package": "robot_mechanism_controllers", "package_summary": ["Generic Mechanism Controller Library"], "package_details": ["The controllers in this package should not be used directly.  The controllers should instead by used via their", "interfaces, e.g.,", ",", ",", ", and", "."]},
{"url": "https://wiki.ros.org/teleop_twist_keyboard", "package": "teleop_twist_keyboard", "package_summary": ["Generic keyboard teleop for twist robots."], "package_details": []},
{"url": "https://wiki.ros.org/mapviz", "package": "mapviz", "package_summary": ["mapviz"], "package_details": ["Mapviz is a ROS-based visualization tool with a plug-in system similar to", "focused on visualization 2D data.", "See", "for a list of existing plugins."]},
{"url": "https://wiki.ros.org/prbt_ikfast_manipulator_plugin", "package": "prbt_ikfast_manipulator_plugin", "package_summary": ["The prbt_ikfast_manipulator_plugin package"], "package_details": []},
{"url": "https://wiki.ros.org/youbot_driver", "package": "youbot_driver", "package_summary": [], "package_details": ["This package contains the drivers for the Kuka youBot. This is required for", ". It is recommended to use", "instead of this package for any real application.", "Install the debian package using", ":", "This will install the code, set the permissions of the binaries, copy the config files to a set location, and install the", "rules for the Hokuyo sensor.", "You must set the environment variable YOUBOT_CONFIG_FOLDER_LOCATION to point to the config folder before running the package. The debian install will have put it at /opt/ros/groovy/etc/youbot_driver/config/, so set the variable to that.", "If you do not wish to do this every time you start a new terminal, you can put that line in", "in the home directory,", ". That way, the variable will be defined for every terminal you start.", "To install from source, get the package from the git repository in the typical way. First, create a folder for the package within the", "folder of your catkin workspace.", "to the folder, then do", "The binaries need to have the proper capabilites to run. If they do not have the right permissions, they will be unable to communicate over Ethercat, and the drivers will not run. To set the capabilities to their proper values, use", "on each binary:", "If you do not wish to do this every time you start a new terminal, you can put that line in", "in the home directory,", ". That way, the variable will be defined for every terminal you start.", "Finally, you should also install the", "rules for the Hokuyo sensor. These are important for any other youBot packages which use the Hokuyo, such as", ". These rules do two things whenever you plug in the Hokuyo:", "To install the rules, copy the", "file from the udev_rules folder included in the source to /etc/udev/rules.d/", "If you wish to confirm that the rules work, run", "and plug in the Hokuyo. The output should reflect the fact that the port has been given read and write access and a symbolic link in", "was created. You may also do", "It is recommended to use", "instead of this package for any actual application.", "You can test the base, arm, and gripper motors by running the base_arm_gripper_test. Be sure to have the robot off the ground because it will move around some while testing the base.", "If this fails with the message that there was no socket connection on", "or", ", go into the", "config file and change", "to", "or", "."]},
{"url": "https://wiki.ros.org/summit_xl_gazebo", "package": "summit_xl_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mav_comm", "package": "mav_comm", "package_summary": ["Contains messages and services for MAV communication"], "package_details": ["Use GitHub to", ". [", "]", "ROS communication meta-package for Micro Aerial Vehicles (MAV) containing", "."]},
{"url": "https://wiki.ros.org/vision_msgs", "package": "vision_msgs", "package_summary": ["Messages for interfacing with various computer vision pipelines, such as\n    object detectors."], "package_details": []},
{"url": "https://wiki.ros.org/message_filters", "package": "message_filters", "package_summary": ["A set of message filters which take in messages and may output those messages at a later time, based on the conditions that filter needs met."], "package_details": ["is a utility library for use with", "and", ". It collects commonly used message \"filtering\" algorithms into a common space.  A message filter is defined as something which a message arrives into and may or may not be spit back out of at a later point in time.", "is most useful for cases where you want to determine which filters to apply at runtime rather than compile-time.", "All message filters follow the same pattern for connecting inputs and outputs.  Inputs are connected either through the filter's constructor or through the", "method.  Outputs are connected through the", "method.", "For example, given two filters", "and", "where", "'s output is compatible with", "'s input, connecting foo to bar could be (in C++):", "The signature of", "is dependent on the definition of", ".", "You can register multiple callbacks with the", "method.  They will get called in the order they are registered.", "See also:", "The", "filter is simply a wrapper around a ROS subscription that provides a source for other filters.  The", "filter cannot connect to another filter's output, instead it uses a ROS topic as its input.", "See also:", ",", "The", "filter synchronizes incoming channels by the timestamps contained in their headers, and outputs them in the form of a single callback that takes the same number of channels.  The C++ implementation can synchronize up to 9 channels.", "(Note: In this particular case you could use the", "class from", ", which essentially wraps the filtering code above.)", "See also:", "The", "filter guarantees that messages will be called in temporal order according to their header's timestamp.  The", "is constructed with a specific delay which specifies how long to queue up messages before passing them through.  A callback for a message is never invoked until the messages' time stamp is out of date by at least delay. However, for all messages which are out of date by at least the delay, their callback are invoked and guaranteed to be in temporal order. If a message arrives from a time prior to a message which has already had its callback invoked, it is thrown away.", "See also:", "Given a stream of messages, the most recent N messages are cached in a ring buffer, from which time intervals of the cache can then be retrieved by the client. The timestamp of a message is determined from its", "field.", "In this example, the", "stores the last 100 messages received on", ", and", "is called on the addition of every new message. The user can then make calls like", "to extract part of the cache.", "The", "filter synchronizes incoming channels by the timestamps contained in their headers, and outputs them in the form of a single callback that takes the same number of channels.  The C++ implementation can synchronize up to 9 channels.", "The", "filter is templated on a policy that determines how to synchronize the channels.  There are currently two policies:", "and", ".", "The", "policy requires messages to have exactly the same timestamp in order to match.  Your callback is only called if a message has been received on all specified channels with the same exact timestamp. The timestamp is read from the", "field of all messages (which is required for this policy).", "The", "policy uses", "to match messages based on their timestamp.", "See also:", "The", "filter allows you to dynamically chain together multiple single-input/single-output (simple) filters.  As filters are added to it they are automatically connected together in the order they were added.  It also allows you to retrieve added filters by index.", "It is possible to pass bare pointers in.  These will", "be automatically deleted when Chain is destructed."]},
{"url": "https://wiki.ros.org/rqt_gui", "package": "rqt_gui", "package_summary": ["rqt_gui provides the main to start an instance of the ROS integrated graphical user interface provided by qt_gui."], "package_details": ["upon using multiple", "plugins has following advantages:"]},
{"url": "https://wiki.ros.org/octomap", "package": "octomap", "package_summary": ["The OctoMap library implements a 3D occupancy grid mapping approach, providing data structures and mapping algorithms in C++. The map implementation is based on an octree. See\n  http://octomap.github.io for details."], "package_details": ["General information about OctoMap is available at", "and in the publication", "by A. Hornung, K. M. Wurm, M. Bennewitz, C. Stachniss, and W. Burgard (Autonomous Robots Journal, 2013).", "Please cite our paper if you use OctoMap in your research.", "Doxygen documentation based on the latest OctoMap release is available", ".", "If you want to use OctoMap in ROS,", "and", "provide messages, wrappers and conversion methods.", "provides map building and serving capabilities. A visualization tool is available at", ".", "Report bugs or request features", ". For questions and discussions, use the mailing list at"]},
{"url": "https://wiki.ros.org/slam_toolbox", "package": "slam_toolbox", "package_summary": ["This package provides a sped up improved slam karto with updated SDK and visualization and modification toolsets"], "package_details": ["The Slam Toolbox package incorporates information from laser scanners in the form of a", "message and TF transforms from odom->base link, and creates a map 2D map of a space. This package will allow you to fully serialize the data and pose-graph of the SLAM map to be reloaded to continue mapping, localize, merge, or otherwise manipulate. We allow for SLAM Toolbox to be run in synchronous (process all valid sensor measurements, regardless of lag) and asynchronous (process valid sensors measurements on an as-possible basis) modes.", "You can find a paper about this work", ".", "More information, ROS API, demos, and resources are given in the", "page."]},
{"url": "https://wiki.ros.org/industrial_ci", "package": "industrial_ci", "package_summary": [], "package_details": ["See", "."]},
{"url": "https://wiki.ros.org/ximea_camera", "package": "ximea_camera", "package_summary": [], "package_details": [", which is of ROS message type", ". This message carries all of the camera specific calibration information.", ", which of of ROS message type", ". This message carries the image data.", "This package is working in ROS Indigo. For a working package in ROS Melodic see", "This software requires the Ximea Linux Software Package. See", "for details."]},
{"url": "https://wiki.ros.org/swri_console", "package": "swri_console", "package_summary": ["A rosout GUI viewer developed at Southwest Research Insititute as an\n     alternative to rqt_console."], "package_details": []},
{"url": "https://wiki.ros.org/tf2_web_republisher", "package": "tf2_web_republisher", "package_summary": [], "package_details": ["The tf2_web_republisher package can be used to throttle and precompute tf transform information to be sent to via the", "to a", "web client.", "The tf2_web_republisher is developed as part of the", "effort.", "For more information and examples visit", "Source code is available at", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/safe_teleop_stage", "package": "safe_teleop_stage", "package_summary": ["Launch files for running safe_teleop_base on pr2"], "package_details": []},
{"url": "https://wiki.ros.org/joy_listener", "package": "joy_listener", "package_summary": ["Translates joy msgs"], "package_details": []},
{"url": "https://wiki.ros.org/ros_numpy", "package": "ros_numpy", "package_summary": ["A collection of conversion function for extracting numpy arrays from messages"], "package_details": ["See the", "on github for a quick usage summary."]},
{"url": "https://wiki.ros.org/turtlebot3_navigation", "package": "turtlebot3_navigation", "package_summary": ["The turtlebot3_navigation provides roslaunch scripts for starting the navigation."], "package_details": ["This package provides parameters from", "in", "directory."]},
{"url": "https://wiki.ros.org/xpp_quadrotor", "package": "xpp_quadrotor", "package_summary": ["The URDF file for a quadrotor to be used with the xpp packages and a \n    simple rviz publisher of quadrotor tfs.\n     \n    Adapted from Daniel Mellinger, Nathan Michael, Vijay Kumar, \n    \"Trajectory Generation and Control for Precise Aggressive Maneuvers\n    with Quadrotors\"."], "package_details": []},
{"url": "https://wiki.ros.org/rosabridge", "package": "rosabridge", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/yocs_keyop", "package": "yocs_keyop", "package_summary": ["Keyboard teleoperation for your robot"], "package_details": []},
{"url": "https://wiki.ros.org/rqt_plot", "package": "rqt_plot", "package_summary": ["rqt_plot provides a GUI plugin visualizing numeric values in a 2D plot using different plotting backends."], "package_details": [".", "curve is not supported either.", "Also if you're on Ubuntu and like to know the most recommended plotting result, simply get a", "file of", ", which is not available via", ". And run it by something like:", "There are two ways to give the topic names to", "as explained in following sections. In both ways, topics that are set in previous run is resumed (as far as the program was shut down without error).", "Type in the \"Topic\" input field the full path of the topic name, and press \"+\" button.", "The input value should be the full path to the value, not only the topic name. E.g., in above case the topic", "is a member \"x\" in a published topic \"/turtle1/pose\", which is defined as", ".", "New short example to show this; say you want to plot a topic called position", "of", "topic, which is a type of", "message. This can be plotted by", ". Possiblly you can figure out this plot name by following steps like this:", "Currently", "has three plotting backend options (", ") which can be configured using the setting dialog available via the gear icon in the window title bar:", "By default, backend option is chosen in the order above; the first one found on your system gets used (eg. if your system has", "but not", ", your", "runs with the", ").", "See", "."]},
{"url": "https://wiki.ros.org/rqt_graph", "package": "rqt_graph", "package_summary": ["rqt_graph provides a GUI plugin for visualizing the ROS\n      computation graph.", "Its components are made generic so that other packages\n      where you want to achieve graph representation can depend upon this pkg\n      (use", "to find out\n      the pkgs that depend. rqt_dep itself depends on rqt_graph too)."], "package_details": ["is the successor of", ".", "and", "can measure certain statistics for every topic connection (see", "for more details. This has to be enabled beforehand through:", "Note: rqt_graph currently does not automatically update the statistics annotations. You have to hit the", "button to update them."]},
{"url": "https://wiki.ros.org/ros_control", "package": "ros_control", "package_summary": ["A set of packages that include controller interfaces, controller managers, transmissions and hardware_interfaces."], "package_details": ["The ros_control packages are a rewrite of the", "packages to make controllers generic to all robots beyond just the PR2.", "A high-level overview of the project can be found in the ROScon 2014 talk entitled", "(", ",", ").", "A short summary of CombinedRobotHW can be found in", "ROScon 2016 talk.", "Additional documentation is available at the", "A list of available controller plugins, contained in", ", as of this writing. You can of course create your own and are not limited to the below list.", "Also refer to the", "of the hardware_interface and the", ".", "From the above it can be seen that power remains constant between input and output. Complementary", "(first part will do).", "See", ".", "Transmission-specific code (not robot-specific) implementing bidirectional (actuator <-> joint) effort and flow maps under a uniform interface shared across transmission types. This is hardware-interface-agnostic. A list of available transmission types as of this writing:", "See", "The", "contains data structures for representing joint limits, methods for populating them from common formats such as URDF and rosparam, and methods for enforcing limits on different kinds of joint commands.", "The joint_limits_interface is not used by controllers themselves (it does not implement a", ") but instead operates after the controllers have updated, in the", "method (or equivalent) of the robot abstraction. Enforcing limits will", "the commands set by the controllers, it does not operate on a separate raw data buffer.", "See", "Or on Ubuntu and other platforms from source. To ease installing from source a", "file is provided:", "Not exactly a roadmap, but this", "contains discussion and proposed solutions to allow ros_control to better accommodate more complex control setups and address shortcomings in the current implementation.", "A", "exists with a mailing list for discussing ros_control issues and features. You are encouraged to join and help with ros_control's development!"]},
{"url": "https://wiki.ros.org/rqt_gui_cpp", "package": "rqt_gui_cpp", "package_summary": ["rqt_gui_cpp enables GUI plugins to use the C++ client library for ROS."], "package_details": []},
{"url": "https://wiki.ros.org/rosflight_sim", "package": "rosflight_sim", "package_summary": ["Software-in-the-loop (SIL) simulator for the ROSflight firmware"], "package_details": ["This package provides a Gazebo plugin for software-in-the-loop (SIL) simulations with the", "."]},
{"url": "https://wiki.ros.org/mrpt_local_obstacles", "package": "mrpt_local_obstacles", "package_summary": ["Maintains a local obstacle map (point cloud,\n   voxels or occupancy grid) from recent sensor readings within a\n   configurable time window."], "package_details": ["This demo requires", ". It simulates one robot with 2 laser scanners and builds and publish the local obstacle maps to", ":"]},
{"url": "https://wiki.ros.org/rqt_common_plugins", "package": "rqt_common_plugins", "package_summary": ["rqt_common_plugins metapackage provides ROS backend graphical tools suite that can be used on/off of robot runtime.", "To run any rqt plugins, just type in a single command \"rqt\", then select any plugins you want from the GUI that launches afterwards.", "rqt consists of three following metapackages:"], "package_details": [".", "See", "."]},
{"url": "https://wiki.ros.org/kinesis_video_streamer", "package": "kinesis_video_streamer", "package_summary": ["Kinesis Video Streams producer node"], "package_details": [": Amazon Kinesis Video Streams makes it easy to securely stream video from connected", "devices to AWS for analytics, machine learning (ML), playback, and other processing. Kinesis Video Streams automatically provisions and elastically scales all the infrastructure needed to ingest streaming video data from millions", "of devices. It also durably stores, encrypts, and indexes video data in your streams, and allows you to access your data through easy-to-use APIs. Kinesis Video Streams enables you to playback video for live and on-demand", "viewing, and quickly build applications that take advantage of computer vision and video analytics through integration with Amazon Recognition Video, and libraries for ML frameworks such as Apache Mx", "Net, Tensor", "Flow, and Open", "CV.", ": The easy-to-use Rekognition API allows you to automatically identify objects, people, text, scenes, and activities, as well as detect any inappropriate content. Developers can quickly build a searchable", "content library to optimize media workflows, enrich recommendation engines by extracting text in images, or integrate secondary authentication into existing applications to enhance end-user security. With a wide variety of use", "cases, Amazon Rekognition enables you to easily add the benefits of computer vision to your business.", ": ROS, AWS, Kinesis Video Streams", "The Amazon Kinesis Video Streams ROS package enables robots to stream video to the cloud for analytics, playback, and archival use. Out of the box, the nodes provided make it possible to encode & stream image data (e.g. video feeds and LIDAR scans)", "from a ROS \u201cImage\u201d topic to the cloud, enabling you to view the live video feed through the Kinesis Video Console, consume the stream via other applications, or perform intelligent analysis, face detection and face recognition", "using Amazon Rekognition.", "The node will transmit standard", "data from ROS topics to Kinesis Video streams, optionally encoding the images as h264 video frames along the way (using the included h264_video_encoder),", "and optionally fetches Amazon Rekognition results from corresponding Kinesis Data Streams and publishing them to local ROS topics.", "The source code is released under", "."]},
{"url": "https://wiki.ros.org/octovis", "package": "octovis", "package_summary": ["octovis is visualization tool for the OctoMap library based on Qt and libQGLViewer. See\n  http://octomap.github.io for details."], "package_details": ["octovis provides visualization for", "based on Qt and libQGLViewer.", "octovis is available in the", "debian package. As an alternative, you can download the package yourself from", "and compile it with the library stand-alone or against a locally installed", "library.", "This will install OctoMap and octovis as stand-alone libraries with no ROS dependencies, so they can be also used in a non-ROS setting.", "Use GitHub to", ". For questions and discussions, check the", "."]},
{"url": "https://wiki.ros.org/jackal_base", "package": "jackal_base", "package_summary": [], "package_details": ["This package contains the primary binary which runs on", ", providing the", "-based comms to the MCU, as well as diagnostic support, and other basic services."]},
{"url": "https://wiki.ros.org/mavros_msgs", "package": "mavros_msgs", "package_summary": ["mavros_msgs defines messages for", "."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"mavros_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/mavros_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/pgm_learner", "package": "pgm_learner", "package_summary": ["Parameter/Structure Estimation and Inference for Bayesian Belief Network"], "package_details": []},
{"url": "https://wiki.ros.org/rosbaglive", "package": "rosbaglive", "package_summary": ["Plays rosbags as though they were happening NOW."], "package_details": []},
{"url": "https://wiki.ros.org/mbf_abstract_core", "package": "mbf_abstract_core", "package_summary": ["This package provides common interfaces for navigation specific robot actions. It contains the AbstractPlanner, AbstractController and AbstractRecovery plugin interfaces. This interfaces have to be implemented by the plugins to make the plugin available for Move Base Flex. The abstract classes provides a meaningful interface enabling the planners, controllers and recovery behaviors to return information, e.g. why something went wrong. Derivided interfaces can, for example, provide methods to initialize the planner, controller or recovery with map representations like costmap_2d, grid_map or other representations."], "package_details": []},
{"url": "https://wiki.ros.org/laser_geometry", "package": "laser_geometry", "package_summary": ["This package contains a class for converting from a 2D laser scan as defined by\n    sensor_msgs/LaserScan into a point cloud as defined by sensor_msgs/PointCloud\n    or sensor_msgs/PointCloud2. In particular, it contains functionality to account\n    for the skew resulting from moving robots or tilting laser scanners."], "package_details": ["To convert a", "to a", "To convert a", "to a", "in the base_link frame, using a high fidelity transform:", "The laser_geometry package contains a single C++ class:", ".  There is no ROS API.", "This class has two relevant functions for transforming from", "to", "or", ".", "Both of these functions have a final optional argument that augments the", "which is created to include extra channels.  These channels may include intensities, distances, timestamps, the index or thew viewpoint from the original laser array.", "There is a simple Python implementation here (", ").", "The method", "does the simplest possible projection of the laser.  Each ray is simply projected out along the appropriate angle according to:", "The appropriate sine and cosine values are cached, making this a very efficient operation.  However, the generated", "is in the same frame as the original", ". While this has the advantage that it does not require an instance of a", "or message notifier, it does not hold up in situations where the laser is moving and skew needs to be accounted for.", "Please consult the", "for full usage details.", "The", "method does a more advanced projection, but requires that you have set up a", "transform listener. (If you are unfamiliar with", ", it is recommended you go through the", "first.)", "Because the stamp of a", "is the time of the", "measurement, one cannot simply wait for a transform", "to target_frame at this stamp. Instead one also has to wait for a transform at the", "measurement of the scan.", "Please consult the", "for full usage details.", "The method", "projects a single laser scan from a linear array into a 3D", ". The generated cloud will be in the same frame as the original laser scan."]},
{"url": "https://wiki.ros.org/xpp_vis", "package": "xpp_vis", "package_summary": ["Visualization for the XPP Motion Framework."], "package_details": []},
{"url": "https://wiki.ros.org/xpp", "package": "xpp", "package_summary": ["Visualization of motion-plans for legged robots. It draws support areas, \n    contact forces and motion trajectories in RVIZ and displays URDFs for \n    specific robots, including a one-legged, a two-legged hopper and", ". \n    Example motions were generated by", "."], "package_details": ["Also you can always clone the repo into your catkin workspace and build from source, as described", ".", "The more involved example trajectories shown have been generated with", ", an optimizer for legged robot motions. However, simple motion plans can also be generated by hand as shown below. This example is taken from", ". Run it using", "Then simply right-click on", "and", "->", ".", "Or load the rosbag in", "To visualize your own URDF is very easy to setup. A minimal example to follow can be seen here:", ".", "We would be happy to see a", "to add your robot. Apart from benefitting the open-source community, this also adds publicity and visibility to you / your lab. The ROS page you can then design for your robot could look similar to this:", ".", "This software has been used in the following", ":", "Please post any questions you have at", "using the tag", "."]},
{"url": "https://wiki.ros.org/naoqi_driver", "package": "naoqi_driver", "package_summary": ["Driver module between Aldebaran's NAOqiOS and ROS. It publishes all sensor and actuator data as well as basic diagnostic for battery, temperature. It subscribes also to RVIZ simple goal and cmd_vel for teleop."], "package_details": ["This package provides a bridge between ROS and", ". It is the officially supported by  Aldebaran. The package is based on C++ implementation of the former python edition", ".", "All documentation can be found on", "."]},
{"url": "https://wiki.ros.org/cl_transforms", "package": "cl_transforms", "package_summary": ["Homogeneous transform library for Common Lisp."], "package_details": []},
{"url": "https://wiki.ros.org/zeroconf_jmdns_suite", "package": "zeroconf_jmdns_suite", "package_summary": [], "package_details": ["This package compiles the", "sources and includes a convenience class for interfacing jmdns with ros. Jmdns is a 100% java implementation of the", "standard.", "It is currently being used and tested for android devices, however it is perfectly ok to use (and we may extend it more fully later) for pc implementations.", "Jmdns has a multi-homed interface (JmmDNS) which could almost be used directly, but it is still experimental - there are a few catches, broken api and a bit of black magic. To make the library easier to use and to interface it with ros, it also provides", "class.", "This package also includes three demo programs in", ", to help quickly experiment with this package."]},
{"url": "https://wiki.ros.org/yocs_safety_controller", "package": "yocs_safety_controller", "package_summary": ["A controller ensuring the safe operation of your robot.\n\n    The SafetyController listens to ranger readings in order to stop (and move back), if obstacles get to close.\n\n    This controller can be enabled/disabled."], "package_details": []},
{"url": "https://wiki.ros.org/dwb_plugins", "package": "dwb_plugins", "package_summary": ["Standard implementations of the GoalChecker\n      and TrajectoryGenerators for dwb_local_planner"], "package_details": []},
{"url": "https://wiki.ros.org/qt_gui_py_common", "package": "qt_gui_py_common", "package_summary": ["qt_gui_py_common provides common functionality for GUI plugins written in Python."], "package_details": []},
{"url": "https://wiki.ros.org/openrtm_ros_bridge", "package": "openrtm_ros_bridge", "package_summary": ["openrtm_ros_bridge package provides basic functionalities to bind\n    two robotics framework:", "and ROS.", "By using this package, you can write your ROS packages that communicate with your\n    non-ROS robots that run on OpenRTM.\n  \t\t\n    For communicating with the robots that run on hrpsys, you can use", "package."], "package_details": ["Documentation is available", "."]},
{"url": "https://wiki.ros.org/joint_state_publisher", "package": "joint_state_publisher", "package_summary": ["This package contains a tool for setting and publishing joint state values for a given URDF."], "package_details": ["This package publishes", "messages for a robot.  The package reads the", "parameter from the", ", finds all of the non-fixed joints and publishes a JointState message with all those joints defined.", "This package can be used in conjunction with the", "node to also publish transforms for all joint states.", "There are four possible sources for the value of each JointState:", "Set the", "parameter, see below.", "This is can be specified through the", "parameter or the", "tag in the", ".", "The default value is zero. If zero is not a permissible value", "is used. To override the default value for some joints, use the", "parameter. An example YAML file is seen below.", "The following YAML snippets show examples of how to set the", "and the", "parameters using YAML syntax. These can be loaded to the parameter server using the", "in a launch file."]},
{"url": "https://wiki.ros.org/pr2_counterbalance_check", "package": "pr2_counterbalance_check", "package_summary": ["pr2_counterbalance_check"], "package_details": ["The", "package contains utilities for checking the counterbalance of the PR2. It is used by the production testing systems, and can be run onboard a PR2."]},
{"url": "https://wiki.ros.org/jsk_interactive_marker", "package": "jsk_interactive_marker", "package_summary": ["jsk interactive markers"], "package_details": []},
{"url": "https://wiki.ros.org/pmb2_description", "package": "pmb2_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/visualization_tutorials", "package": "visualization_tutorials", "package_summary": ["Metapackage referencing tutorials related to rviz and visualization."], "package_details": ["This is the stack that provides the code for the"]},
{"url": "https://wiki.ros.org/video_stream_opencv", "package": "video_stream_opencv", "package_summary": ["The video_stream_opencv package contains a node to publish a video stream (the protocols that\n    opencv supports are supported, including rtsp, webcams on /dev/video and video files) in ROS image topics, it supports camera info and basic image flipping (horizontal, vertical or both) capabilities, also adjusting publishing rate."], "package_details": ["A package to view video streams based on the", ", easy way to publish on a ROS Image topic (including camera info) usb cams, ethernet cameras, video streams or video files. It also supports flipping of images and fps throttling.", "Example usages in launch folder (only the argument", "is mandatory):", "So if you want the very latest image published from a camera, set", "to 1,", "to the max the camera allows and", "to that same max.", "If you want to publish all images (don't drop any and you don't mind some possible delay from real time), set", "big enough for your case (1000?),", "and", "to whatever FPS it has.", "If you want to test quickly if your desired input may work with this node you can use a simple python script called", "which just tries to open the video resource (no ROS involved, just copy the file to your computer and try).", "Just do any of those:"]},
{"url": "https://wiki.ros.org/pmb2_simulation", "package": "pmb2_simulation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xmlrpcpp", "package": "xmlrpcpp", "package_summary": ["XmlRpc++ is a C++ implementation of the XML-RPC protocol. This version is\n    heavily modified from the package available on SourceForge in order to\n    support roscpp's threading model. As such, we are maintaining our\n    own fork."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_calibration_controllers", "package": "pr2_calibration_controllers", "package_summary": ["The pr2_calibration_controllers package contains the controllers\n     used to bring all the joints in the PR2 to a calibrated state."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_rviz_plugins", "package": "jsk_rviz_plugins", "package_summary": ["The jsk_rviz_plugins package"], "package_details": ["Document:"]},
{"url": "https://wiki.ros.org/mavlink", "package": "mavlink", "package_summary": ["MAVLink message marshaling library.\n  This package provides C-headers and C++11 library\n  for both 1.0 and 2.0 versions of protocol.\n\n  For pymavlink use separate install via rosdep (python-pymavlink)."], "package_details": []},
{"url": "https://wiki.ros.org/rosflight", "package": "rosflight", "package_summary": ["Package for interfacing to the ROSflight autopilot firmware over MAVLink"], "package_details": ["ROSflight provides a simple, low-latency interface between a flight controller running the ROSflight firmware and ROS. ROSflight can stream both sensor data and motor commands at high speed. ROSflight is written to work with a variety of airframes, including multirotor and fixed-wing aircraft. The ROSflight package provided the interface for autopilots, but does not include any control code. For examples of autopilots using ROSflight, see", "or", ". For documentation on the firmware, see", "."]},
{"url": "https://wiki.ros.org/multi_object_tracking_lidar", "package": "multi_object_tracking_lidar", "package_summary": ["ROS package for Multiple objects detection, tracking and classification from LIDAR scans/point-clouds"], "package_details": ["(", ")", "PCL based ROS package to Detect/Cluster --> Track --> Classify static and dynamic objects in real-time from LIDAR scans implemented in C++.", "Follow the steps below to use this (", ") package:", "If all went well, the ROS node should be up and running! As long as you have the point clouds published on to the", "rostopic, you should see outputs from this node published onto the", ",", ",", ", \u2026,", "topics along with the markers on", "topic which you can visualize using RViz.", "1."]},
{"url": "https://wiki.ros.org/jsk_pepper_startup", "package": "jsk_pepper_startup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_robot_monitor", "package": "rqt_robot_monitor", "package_summary": ["rqt_robot_monitor displays diagnostics_agg topics messages that\n   are published by", ".\n   rqt_robot_monitor is a direct port to rqt of", ". All\n   diagnostics are fall into one of three tree panes depending on the status of\n   diagnostics (normal, warning, error/stale). Status are shown in trees to\n   represent their hierarchy. Worse status dominates the higher level status."], "package_details": []},
{"url": "https://wiki.ros.org/pepper_meshes", "package": "pepper_meshes", "package_summary": ["meshes for the Aldebaran Robotics Pepper"], "package_details": []},
{"url": "https://wiki.ros.org/joystick_drivers", "package": "joystick_drivers", "package_summary": ["This metapackage depends on packages for interfacing common\n    joysticks and human input devices with ROS."], "package_details": ["For example, if you are using ROS", "distro:", "The following git command can be used for installation in your", "folder:"]},
{"url": "https://wiki.ros.org/sbg_driver", "package": "sbg_driver", "package_summary": ["ROS driver package for communication with the SBG navigation systems."], "package_details": ["and edit", "accordingly or (recommended) define a", "rule (e.g. pointing to /dev/sbg)"]},
{"url": "https://wiki.ros.org/mbf_abstract_nav", "package": "mbf_abstract_nav", "package_summary": ["The mbf_abstract_nav package contains the abstract navigation server implementation of Move Base Flex (MBF). The abstract navigation server is not bound to any map representation. It provides the actions for planning, controlling and recovering. MBF loads all defined plugins at the program start. Therefor, it loads all plugins which are defined in the lists *planners*, *controllers* and *recovery_behaviors*. Each list holds a pair of a *name* and a *type*. The *type* defines which kind of plugin to load. The *name* defines under which name the plugin should be callable by the actions."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_console", "package": "rqt_console", "package_summary": ["rqt_console provides a GUI plugin for displaying and filtering ROS messages."], "package_details": ["is a viewer in the", "package that displays messages being published to", ".  It collects messages over time, and lets you view them in more detail, as well as allowing you to filter messages by various means.", "Sending messages to", "is done differently in each client library:", ",", "Assuming you have ROS installed, you can invoke", "by just typing:", "The list view shows all of the messages, updating in real time as they arrive.  The list displays all the information in the", "message broadcast on", ":", "There are two operations you can use on the items in the list.  A", "will bring up all the information about that message in a separate box.", "A", "will pop up a menu allowing you to filter the list based on some aspect of the selected message", "See the", "page. It will help you use", "to publish error, info and debug messages and view them in rqt_console."]},
{"url": "https://wiki.ros.org/json_transport", "package": "json_transport", "package_summary": ["JSON transport for ROS"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_gripper_action", "package": "pr2_gripper_action", "package_summary": ["The pr2_gripper_action provides an action interface for using the\n  gripper. Users can specify what position to move to (while limiting the\n  force) and the action will report success when the position is reached or\n  failure when the gripper cannot move any longer."], "package_details": ["Users interested in grasping more delicate objects may want to checkout the alternative", "package.", "You can see an example of using the pr2 gripper action on the PR2 in the", ".", "The", "provides more context on how the", "and how", "."]},
{"url": "https://wiki.ros.org/novatel_gps_driver", "package": "novatel_gps_driver", "package_summary": ["Driver for NovAtel receivers"], "package_details": []},
{"url": "https://wiki.ros.org/pilz_industrial_motion_testutils", "package": "pilz_industrial_motion_testutils", "package_summary": ["Helper scripts and functionality to test industrial motion generation"], "package_details": []},
{"url": "https://wiki.ros.org/pcl_ros", "package": "pcl_ros", "package_summary": ["PCL (Point Cloud Library) ROS interface stack. PCL-ROS is the preferred\n  bridge for 3D applications involving n-D Point Clouds and 3D geometry\n  processing in ROS."], "package_details": ["includes several", "packaged as ROS nodelets. These links provide details for using those interfaces:", "extends the ROS", "to support message passing with", "native data types. Simply add the following include to your ROS node source code:", "This header allows you to publish and subscribe", "objects as ROS messages. These appear to ROS as", "messages, offering seamless interoperability with non-PCL-using ROS nodes. For example, you may publish a", "in one of your nodes and visualize it in", "using a", ". It works by hooking into the", "infrastructure.", "The old format", "is not supported in PCL.", "You may publish PCL point clouds using the standard", ":", "You may likewise subscribe to PCL point clouds using the standard", ":", "Read messages from the", "topic in", ", saving a PCD file for each message into the", "subdirectory.", "Read the point cloud in <cloud.pcd> and publish it in ROS image messages at 5Hz.", "Subscribe to the", "topic and republish each message on the", "topic.", "To view the images created by the previous command, use", ".", "Publish the contents of", "once in the", "frame of reference.", "Publish the contents of", "approximately ten times a second in the", "frame of reference.", "Subscribe to the", "topic and save each message in the current directory. File names look like", ", the exact names depending on the message time stamps.", "Set the", "parameter in the current namespace, save messages to files with names like", ".", "We have more examples on", "page"]},
{"url": "https://wiki.ros.org/zivid_camera", "package": "zivid_camera", "package_summary": ["Driver for using the Zivid 3D cameras in ROS."], "package_details": ["For more information about the zivid_camera ROS driver, read the", "."]},
{"url": "https://wiki.ros.org/joint_limits_interface", "package": "joint_limits_interface", "package_summary": ["Interface for enforcing joint limits."], "package_details": ["See the", "page and the", "for more information."]},
{"url": "https://wiki.ros.org/jackal_bringup", "package": "jackal_bringup", "package_summary": [], "package_details": ["See", "for information on Jackal configurations."]},
{"url": "https://wiki.ros.org/virtual_force_publisher", "package": "virtual_force_publisher", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libuvc_camera", "package": "libuvc_camera", "package_summary": ["USB Video Class camera driver"], "package_details": ["This package provides a ROS interface for digital cameras meeting the USB Video Class standard (UVC) using", ". Most webcams are UVC-compliant.", "Under Linux, the user that runs camera_node must have write permissions to the", "device that corresponds to the camera. You may run the node as root:", "However, use of", "rules is recommended. In", ", to give every user camera access:", "Alternatively, set", "to grant access for any user in that group.", "You may need to disable your operating system's builtin USB video or audio drivers. On Linux, the", "and", "modules conflict with libuvc. Try unloading them with", "and consider blacklisting them -- e.g., add the lines", "and", "to an", "file. (Applications that don't use libuvc will be unable to stream from the camera.)"]},
{"url": "https://wiki.ros.org/multi_map_server", "package": "multi_map_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_slam", "package": "mrpt_slam", "package_summary": ["mrpt_slam"], "package_details": ["See also:", ","]},
{"url": "https://wiki.ros.org/moveit_ros_perception", "package": "moveit_ros_perception", "package_summary": ["Components of MoveIt connecting to perception"], "package_details": []},
{"url": "https://wiki.ros.org/youbot_simulation", "package": "youbot_simulation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/imagesift", "package": "imagesift", "package_summary": ["For every image, computes its sift features and send a new message with the image, its intrinsic parameters, and the features.\n    Parameters include:\n    display - shows the image on the local computer"], "package_details": []},
{"url": "https://wiki.ros.org/cl_utils", "package": "cl_utils", "package_summary": ["Common Lisp utility libraries"], "package_details": []},
{"url": "https://wiki.ros.org/joy_mouse", "package": "joy_mouse", "package_summary": ["The joy_mouse package"], "package_details": []},
{"url": "https://wiki.ros.org/moveit_planners", "package": "moveit_planners", "package_summary": ["Metapacakge that installs all available planners for MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/move_base_msgs", "package": "move_base_msgs", "package_summary": ["Holds the action description and relevant messages for the move_base package."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"move_base_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/move_base_msgs/manifest.yaml", "This package contains the messages used to communicate with the", "node. These messages are auto-generated from the", "action specification. For more information on actions see", ", for more information on the", "node see", ".", "The", "is the goal that the navigation stack attempts to achieve. The", "given as feedback is the current position of the base in the world as reported by", ". For the", "node, the", "is projected into the XY plane with the Z axis pointing up when attempting to achieve a goal."]},
{"url": "https://wiki.ros.org/mbf_simple_nav", "package": "mbf_simple_nav", "package_summary": ["The mbf_simple_nav package contains a simple navigation server implementation of Move Base Flex (MBF). The simple navigation server is bound to no map representation. It provides actions for planning, controlling and recovering. MBF loads all defined plugins which are defined in the lists *planners*, *controllers* and *recovery_behaviors*. Each list holds a pair of a *name* and a *type*. The *type* defines which kind of plugin to load. The *name* defines under which name the plugin should be callable by the actions. \n\n        It tries to load the defined plugins which implements the defined interfaces in", "."], "package_details": []},
{"url": "https://wiki.ros.org/py_trees", "package": "py_trees", "package_summary": ["Pythonic implementation of behaviour trees."], "package_details": ["Get started at the", "for the project.", "If using this in ROS 1, see also", ",", ","]},
{"url": "https://wiki.ros.org/vision_opencv", "package": "vision_opencv", "package_summary": ["Packages for interfacing ROS with OpenCV, a library of programming functions for real time computer vision."], "package_details": ["The", "stack provides packaging of the popular OpenCV library for ROS. For information about the OpenCV library, please see the OpenCV main page at", "links to complete documentation for OpenCV, as well as other OpenCV resources (like the bug tracker on", ")", "In order to use ROS with OpenCV, please see the", "package.", "Since Indigo, there is a package for OpenCV3. Information about it is detailed at", "."]},
{"url": "https://wiki.ros.org/xbot_safety_controller", "package": "xbot_safety_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pointgrey_camera_driver", "package": "pointgrey_camera_driver", "package_summary": ["Point Grey camera driver based on libflycapture2."], "package_details": ["When multiple Point Grey cameras are in use at a time, specify the serial number given by", ":", "Until better documentation is produced, please see the", "file for the available parameters.", "When using Point Grey's GigE cameras, you may experience an issue with dropped packets which results in", "being thrown by the FlyCapture2 SDK. You can adjust the receive buffer settings in Linux using", "to correct this. See", "for more details.", "Similarly, multiple USB cameras may require raising the amount of memory allocated to the USB subsystem.  The usbcore variable", "should be set suitably large.", "describes two common ways of setting it, via the kernel command line (edit", "), or module loading (", "for current session, or adding", "to an appropriate", "file).  It should also be settable at runtime via"]},
{"url": "https://wiki.ros.org/roslint", "package": "roslint", "package_summary": ["CMake lint commands for ROS packages.\n\n    The lint commands perform static checking of Python or C++ source\n    code for errors and standards compliance."], "package_details": ["You might also check", "for checking package configuration.", "Add a", "dependency on roslint to your package's", ":", "In your package's", "file, include roslint as one of your catkin component dependencies:", "Then, invoke the roslint functions from your", ", eg:", "To run roslint against your package you must invoke catkin_make with your package's roslint target. For example, for a package named", "you would run:", "Each", "function create a catkin build target called", ", which runs all specified lint operations for the package. Each additionally creates (if it does not yet exist) a master", "target, which depends on all other", "targets.", "To fix basic whitespace issues in C++, try using", ". Example invocation within your package:", "For similar fixes in Python, try", ". Example:"]},
{"url": "https://wiki.ros.org/easy_markers", "package": "easy_markers", "package_summary": ["Python library to assist in publishing markers easily"], "package_details": []},
{"url": "https://wiki.ros.org/image_geometry", "package": "image_geometry", "package_summary": ["`image_geometry` contains C++ and Python libraries for interpreting images\n    geometrically. It interfaces the calibration parameters in sensor_msgs/CameraInfo\n    messages with OpenCV functions such as image rectification, much as cv_bridge\n    interfaces ROS sensor_msgs/Image with OpenCV data types."], "package_details": ["contains Python and C++ libraries that simplifies interpreting images geometrically using the parameters from", ". Although", "contains all the information required to rectify a raw image and project points onto it,", ", since performing these operations correctly over the space of all camera options can be non-trivial.", "The camera parameters in", "are for a full-resolution image; region-of-interest alone significantly complicates the creation of rectification maps and requires adjusting the projection matrix. Adding options such as subsampling (binning) to", "would further complicate the correct interpretation of the corresponding Images. Using", "simplifies and future-proofs imaging code.", "The", "classes are written to be used in an", "/", "message callback similar to", ".", "In order to maintain invariance, the", "classes offer read-only access to specific parameters and matrices. Setting a", "can only be performed with full information using the", "functions.", "Please see the", "documentation.", "Please see the", "documentation."]},
{"url": "https://wiki.ros.org/jsk_pcl_ros", "package": "jsk_pcl_ros", "package_summary": ["ROS nodelets for pointcloud perception."], "package_details": ["Documentation is available", ".", "Use github issue to report", "or", "."]},
{"url": "https://wiki.ros.org/peppereus", "package": "peppereus", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/combined_robot_hw_tests", "package": "combined_robot_hw_tests", "package_summary": ["Tests for the combined Robot HW class."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_baxter_desktop", "package": "jsk_baxter_desktop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qt_create", "package": "qt_create", "package_summary": ["Provides templates and scripts for creating qt-ros packages (similar to roscreate-pkg)."], "package_details": []},
{"url": "https://wiki.ros.org/action/show/ROSARIA?action=show&redirect=rosaria", "package": "ROSARIA?action=show&redirect=rosaria", "package_summary": [], "package_details": ["Instructions on downloading, building and getting started with", "is covered in", ".", "To build and install", ", first install the ARIA library from Adept", "at", ".  (If no longer available, a modified fork of ARIA is also available by cloning or forking the git repository at", ").", "Then obtain the source code to", "from", ", and build using catkin.  See", "for full instructions.", "Video walkthroughs are available at", ".", "Bugs and requests can be added and tracked here:", "Development is discussed and planned via the", "These topics are by default provided under a", "topic namespace or prefix.   You can remap these to different names if desired (see", ",", "and", "for information).", "ROS topics are channels by which other nodes can communicate with ROSARIA by sending or reading messages. For more information on ROS topics, see", "and", ".", "ROS services are channels by which other nodes can cause specific events to occur on the robot via ROSARIA.  For more information on services, see", "and", ".", "Parameters are used to configure the behavior of the RosAria node during initial startup of the node, such as how to connect to the robot controller.  They may be set on the command line when running", "or in a launch file when using", ".  Parameters are stored by the ROS parameter server. See also", ",", ",", "and", ".", "Some parameters can also be dynamically changed using", "."]},
{"url": "https://wiki.ros.org/key_teleop", "package": "key_teleop", "package_summary": ["A text-based interface to send a robot movement commands"], "package_details": []},
{"url": "https://wiki.ros.org/apriltag_ros", "package": "apriltag_ros", "package_summary": ["A ROS wrapper of the AprilTag 3 visual fiducial detection\n    algorithm. Provides full access to the core AprilTag 3 algorithm's\n    customizations and makes the tag detection image and detected tags' poses\n    available over ROS topics (including tf). The core AprilTag 3 algorithm is\n    extended to allow the detection of tag bundles and a bundle calibration\n    script is provided (bundle detection is more accurate than single tag\n    detection). Continuous (camera image stream) and single image detector nodes\n    are available."], "package_details": ["The behavior of the ROS wrapper is fully defined by the two configuration files", "(which defines the tags and tag bundles to look for) and", "(which configures the core AprilTag 2 algorithm itself). Then, the following topics are output:", "The", "teach you how to operate the wrapper. The main idea is to fill out", "with the standalone tags and tag bundles which you would like to detect (bundles potentially require a calibration process) and", "with the wrapper and AprilTag 2 core parameters. Then, you simply run the continuous or single image detector. The tutorials walk you through how to do this.", "While this ROS wrapper is original code originating from the author's master thesis, the core AprilTag 2 algorithm in", "is wholly the work of the", "at The University of Michigan. If you use this package, please kindly cite:"]},
{"url": "https://wiki.ros.org/effort_controllers", "package": "effort_controllers", "package_summary": ["effort_controllers"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/wu_ros_tools", "package": "wu_ros_tools", "package_summary": ["A collection of tools for making a variety of generic ROS-related tasks easier."], "package_details": []},
{"url": "https://wiki.ros.org/xpp_hyq", "package": "xpp_hyq", "package_summary": ["HyQ-robot specific functions for visualization in the  XPP Motion Framework.\n    \n    These include inverse kinematics as well as urdf files for a one-legged,\n    two-legged and four legged robot with", "legs.\n        \n    The dynamic model can be found", ".  \n    \n    See also", "."], "package_details": ["The Robot \"HyQ\" from the", ".", "(Picture credit to Agnese Abrusci)"]},
{"url": "https://wiki.ros.org/turtlebot_stdr", "package": "turtlebot_stdr", "package_summary": [], "package_details": ["]]", "This package contains launchers, maps and world descriptions for the", "simulation with", ".", "Refer to the", "for help on how to run."]},
{"url": "https://wiki.ros.org/opencv_tests", "package": "opencv_tests", "package_summary": ["Tests the enumerants of the ROS Image message, and functionally tests the Python and C++ implementations of CvBridge."], "package_details": ["Package opencv_test tests the enumerants of the ROS Image message, and functionally tests the Python and C++ implementations of CvBridge."]},
{"url": "https://wiki.ros.org/rqt_dep", "package": "rqt_dep", "package_summary": ["rqt_dep provides a GUI plugin for visualizing the ROS dependency graph."], "package_details": ["As of version 0.4.1, only the packages in", "can be inquired on", "."]},
{"url": "https://wiki.ros.org/turtlebot_stage", "package": "turtlebot_stage", "package_summary": [], "package_details": ["Tutorial link for now:", "Install the turtlebot package as described in the turtlebot", "and source the setup.bash to your needs.", "How to change things you can find in the", "."]},
{"url": "https://wiki.ros.org/dwb_msgs", "package": "dwb_msgs", "package_summary": ["Message/Service definitions specifically for the dwb_local_planner"], "package_details": []},
{"url": "https://wiki.ros.org/swri_nodelet", "package": "swri_nodelet", "package_summary": ["This package provides a simple script to write simple launch files\n    that can easily switch between running nodelets together or as\n    standalone nodes."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_action", "package": "rqt_action", "package_summary": ["rqt_action provides a feature to introspect all available ROS\n  action (from actionlib) types. By utilizing rqt_msg, the output format is\n  unified with it and rqt_srv. Note that the actions shown on this plugin\n  is the ones that are stored on your machine, not on the ROS core your rqt\n  instance connects to."], "package_details": []},
{"url": "https://wiki.ros.org/prbt_moveit_config", "package": "prbt_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the prbt with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/teleop_tools", "package": "teleop_tools", "package_summary": ["A set of generic teleoperation tools for any robot."], "package_details": []},
{"url": "https://wiki.ros.org/rqt_robot_steering", "package": "rqt_robot_steering", "package_summary": ["rqt_robot_steering provides a GUI plugin for steering a robot using Twist messages."], "package_details": ["This tool starts publishing", "message as soon as it's launched.", "As noted,", "publishes", "as a name of", "by default. This name may vary per robot/application; e.g.", "also publishes", "but as", "(see", ". So, type that name into the topic field at the top of", "GUI and it gets applied immediately.", "To verify, use also", "(or run from commandline", ") to see if the topics", "are actually published."]},
{"url": "https://wiki.ros.org/yocs_msgs", "package": "yocs_msgs", "package_summary": ["Yujin's Open Control System messages, services and actions"], "package_details": []},
{"url": "https://wiki.ros.org/webots_ros2", "package": "webots_ros2", "package_summary": [], "package_details": ["is a package that provides the necessary interfaces to simulate a robot in the", "open-source 3D robots simulator. It integrates with ROS2 using ROS2 messages, services, and actions.", "Please visit the", "that contains the following sections:", "Supported by OpenDR - Open Deep Learning Toolkit for Robotics.", "More information:"]},
{"url": "https://wiki.ros.org/swri_rospy", "package": "swri_rospy", "package_summary": ["This package provides added functionality on top of rospy, including a\n  single-threaded callback queue."], "package_details": []},
{"url": "https://wiki.ros.org/rosnode_rtc", "package": "rosnode_rtc", "package_summary": ["This package gives transparency between RTM and ROS.\n\n     rtmros-data-bridge.py is a RT-Component for dataport/topic.\n     This automatically convert ROS/topic into RTM/dataport."], "package_details": ["Documentation is available", "."]},
{"url": "https://wiki.ros.org/zeroconf_avahi_suite", "package": "zeroconf_avahi_suite", "package_summary": [], "package_details": ["For more detailed notes, refer to the relevant", "."]},
{"url": "https://wiki.ros.org/phidgets_api", "package": "phidgets_api", "package_summary": ["A C++ Wrapper for the Phidgets C API"], "package_details": ["The", "package contains a C++ API built on top of the", "package.", "The package provides a base", "class, from which all other Phidgets inherit. Currently, we have implemented classes for the following devices:", "* IMU sensor (", ")", "* IR sensor (", ")", "We first define the Imu class, which is inherited from the base", "class:", "The", "class has a", ", which is a special handle for the Phidget Spatial device. Different devices will have different handle types.", "The", "and", "functions implement sepcific calls to the IMU device using the C API. The data handler function receives spatial data events.", "The", "is a static callback function which forwards the data to the correct", "class instance.", "Finally, the virtual", "function is the one which is called back when Spatial data arrives. In this example, the function just prints out a message. However, you can create a class which inherits from the", "class and overwrites this behavior.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/wireless_watcher", "package": "wireless_watcher", "package_summary": ["A Python-based which publishes connection information about a linux wireless interface."], "package_details": []},
{"url": "https://wiki.ros.org/assimp_devel", "package": "assimp_devel", "package_summary": ["assimp library"], "package_details": []},
{"url": "https://wiki.ros.org/joint_state_controller", "package": "joint_state_controller", "package_summary": ["Controller to publish joint state"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/teleop_twist_joy", "package": "teleop_twist_joy", "package_summary": ["Generic joystick teleop for twist robots."], "package_details": ["The purpose of this package is to provide a generic facility for tele-operating Twist-based ROS robots with a standard joystick. Examples of such platforms include", ",", ", and", ".", "This node provides no rate limiting or autorepeat functionality. It is expected that you take advantage of the features built into", "for this.", "The teleop translation functionality is embeddable, if you'd like to compile it into a larger \"base\" node for your robot. See the", "class for details or", "for an example."]},
{"url": "https://wiki.ros.org/turtlebot3_bringup", "package": "turtlebot3_bringup", "package_summary": ["roslaunch scripts for starting the TurtleBot3"], "package_details": []},
{"url": "https://wiki.ros.org/moveit_ros_robot_interaction", "package": "moveit_ros_robot_interaction", "package_summary": ["Components of MoveIt that offer interaction via interactive markers"], "package_details": []},
{"url": "https://wiki.ros.org/controller_manager", "package": "controller_manager", "package_summary": ["The controller manager."], "package_details": ["allows developers to switch controllers at run time, but it is not so convenient when you want to switch from a group of controllers to another for some special purposes. The", "script makes this easy if such groups are defined in ROS parameter", ". It knows all controllers involved, and then controllers that need to be stopped and started when it switches from one group to another. Therefore, different groups can share some controllers.", "The", "provides a", "-compatible loop to control a robot mechanism, which is represented by a", "instance (see the", "package).  The", "provides the infrastructure to load, unload, start and stop controllers.", "When loading a controller, the", "will use the controller name as the root for all controller specific parameters, most importantly,", "which identifies which plugin to load.", "You can interact with the", "from the command line, using the", "script. To interact with a specific controller, use:", "To automatically load and start a set of controllers at once, and automatically stop and unload those same controllers at once, use the", "tool:", "To automatically stop a set of controllers, and restart them later, you can use the", "tool:", "The listed controllers will be", ", but not unloaded. Once spawner is shut down, the controllers will be restarted.", "An example of", "parameter:", "To run the", "script::", "You could run", "to start controllers from within a launch file. However, the controller would then stay up even after the launch file is taken down. Instead, use the", "tool to automatically load, start, stop and unload a controller from within a launch file. When you start", ", it will load and start the controller. When you stop", "(when the launch file is taken down) it will stop and unload the controller. Your launch file would look something like this:", "The", "is a rqt plugin that allows to graphically load, unload, start and stop controllers, as well as to display information about loaded controllers."]},
{"url": "https://wiki.ros.org/spacenav_node", "package": "spacenav_node", "package_summary": ["ROS interface to the 3Dconnexion SpaceNavigator 6DOF joystick."], "package_details": ["This package should support any hardware that is supported by the upstream", "package."]},
{"url": "https://wiki.ros.org/ffha", "package": "ffha", "package_summary": ["ffha: PDDL Planner (http://ipc.informatik.uni-freiburg.de)"], "package_details": []},
{"url": "https://wiki.ros.org/rosflight_msgs", "package": "rosflight_msgs", "package_summary": ["Message and service definitions for the ROSflight ROS stack"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rosflight_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/rosflight_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/forward_command_controller", "package": "forward_command_controller", "package_summary": ["forward_command_controller"], "package_details": ["See the", "page for more information."]},
{"url": "https://wiki.ros.org/libmavconn", "package": "libmavconn", "package_summary": ["MAVLink communication library.\n    This library provide unified connection handling classes\n    and URL to connection object mapper.\n\n    This library can be used in standalone programs."], "package_details": ["It is", "connection and communication library used in", "."]},
{"url": "https://wiki.ros.org/rqt_multiplot", "package": "rqt_multiplot", "package_summary": ["rqt_multiplot provides a GUI plugin for visualizing numeric values in multiple 2D plots using the Qwt plotting backend."], "package_details": []},
{"url": "https://wiki.ros.org/lgsvl_msgs", "package": "lgsvl_msgs", "package_summary": ["Message definitions for interfacing with the LGSVL Simulator for ROS and ROS 2."], "package_details": []},
{"url": "https://wiki.ros.org/action/show/LMS1xx?action=show&redirect=lms1xx", "package": "LMS1xx?action=show&redirect=lms1xx", "package_summary": ["The lms1xx package contains a basic ROS driver for the SICK LMS1xx line of LIDARs."], "package_details": ["Note that this package has been released by Clearpath Robotics as", ". You can install it on Ubuntu using apt:"]},
{"url": "https://wiki.ros.org/nmea_navsat_driver", "package": "nmea_navsat_driver", "package_summary": ["Package to parse NMEA strings and publish a very simple GPS message. Does not\n    require or use the GPSD deamon."], "package_details": ["Use GitHub to", ". [", "]", "This package provides a ROS interface for GPS devices that output compatible NMEA sentences. See the", "for details on the raw format. Of the thousands of NMEA-compatible GPS devices, we are compiling a list of", ".", "This package is compatible with the", "project as well as any other nodes that support", "and/or", ".", "This package replaces the", "package present in Fuerte and Groovy.", "To get up and running quickly, you can use the following command to start outputting your GPS data onto ROS topics. This assumes your GPS is outputting GGA NMEA sentences, is connected to", "and is communicating at 38400 baud.", "If you are using this package for the first time and encountering problems you should first check that the package installed correctly and in the right location. Then consult", ",", "and", "to see if a solution has already been identified for your problem.", "If you are having trouble with nmea_serial_driver and connecting to a serial port, ensure that the user has permission to access the port by checking to see if the user is part of the \"dialout\" group. See", "for more information."]},
{"url": "https://wiki.ros.org/kobuki_driver", "package": "kobuki_driver", "package_summary": ["C++ driver library for Kobuki:\n    Pure C++ driver library for Kobuki. This is for those who do not wish to use ROS on their systems."], "package_details": []},
{"url": "https://wiki.ros.org/ament_virtualenv", "package": "ament_virtualenv", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_commander", "package": "moveit_commander", "package_summary": ["Python interfaces to MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/yocs_rapps", "package": "yocs_rapps", "package_summary": ["Yujin open control system rapps for use with the app manager and rocon concert"], "package_details": []},
{"url": "https://wiki.ros.org/pilz_robots", "package": "pilz_robots", "package_summary": ["The metapackage"], "package_details": ["contains Moveit", "plugins for Linear, Circular and Point-To-Point movements. You can plan industrial", "motion commands respecting the joint limits with trapezoidal velocity profiles. Supported by ROSIN.", "is an easy to use API to execute standard industrial robot commands like Ptp, Lin, Circ and Sequence in a python script. Supported by ROSIN.", "allows storing one position for reuse by", ".", "contains additional description and launch files to use the Manipulator PRBT combined with a gripper.", "provide a launch file for your custom application package. If you want to use all configuration options, download this repository and use the files as template.", "Use GitHub to", ". [", "]", "We created a set of", "that walk you through using the Pilz Manipulator Module PRBT, step by step. For example you can learn how to model your own machine layout and how to test if the manipulator can reach your machine.", "For package documentation please see the", "."]},
{"url": "https://wiki.ros.org/moveit_python", "package": "moveit_python", "package_summary": ["A pure-python interaface to the MoveIt! ROS API."], "package_details": []},
{"url": "https://wiki.ros.org/mav_msgs", "package": "mav_msgs", "package_summary": ["Package containing messages for communicating with rotary wing MAVs"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"mav_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/mav_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/hrpsys_ros_bridge", "package": "hrpsys_ros_bridge", "package_summary": ["hrpsys_ros_bridge package provides basic functionalities to bind", ", a", "-based controller, and ROS.", "By using this package, you can write your ROS packages that communicate with your\n    non-ROS robots that run on hrpsys.\n  \t\t\n    For communicating with the robots that run on OpenRTM without hrpsys,\n  \tyou can use", "package."], "package_details": ["Other than API documentation being available", ", this package is missing document and your contribution is appreciated. Please contact through", ".", "In its downstream package, you might see a folder for conf files (e.g.", ") where only template files with suffix", "are stored. Once you build the package the concrete files are generated into the same folder.", "There are 3 types of conf files of which the distinction may not be very clear (", "):", "While in current design the package depends on", "that's catkinized from", "onward and not available in", ", some hacks allow the package not to separate", "(regardless it's good or not, doing so is the decision as of March 2014). This requires another hack during release process using", "as follows:"]},
{"url": "https://wiki.ros.org/moveit_kinematics", "package": "moveit_kinematics", "package_summary": ["Package for all inverse kinematics solvers in MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/prbt_hardware_support", "package": "prbt_hardware_support", "package_summary": ["Control hardware functions of the PRBT manipulator like RUN_PERMITTED for Stop1 functionality."], "package_details": []},
{"url": "https://wiki.ros.org/rtmros_common", "package": "rtmros_common", "package_summary": ["A package suite that provides all the capabilities for\n    the ROS users to connect to the robots that run on", "or RTM-based controllers."], "package_details": [": TBD", ": Wait and re-trigger", ", as recommended (", ").", ": Wait and re-trigger", ", or improve test code", ": This has been fixed in 1.0.21, please report error to", "For discussions, updates, announcements, please subscribe to the", ".", "Here are some common errors and workarounds (if found any) on either of your local machine /", "(buildfarm at ROS infra) /", ".", "This is failure in the test, in the test, happens in for example", ".", "hironx_ros_bridge/test_LArm and hironx_ros_bridge/test_RArm report errors (", ")", "When", "fails no matter what value you use in launch files, look at Environment Variables", ", which might be most likely set as", "(", "default). In that case re-define it as you want:"]},
{"url": "https://wiki.ros.org/qt_tutorials", "package": "qt_tutorials", "package_summary": ["Example qt programs, generated from code similar to that used by the roscreate-qt-pkg script and styled on roscpp_tutorials."], "package_details": ["Simple package to test/demo the", "tools. Demo features:", "Compile in place with the usual", "to generate native linux binaries or", "use rosbuild2 to build windows binaries with the mingw cross compiler (refer to", "the", "and", "tutorials)."]},
{"url": "https://wiki.ros.org/novatel_span_driver", "package": "novatel_span_driver", "package_summary": ["Python driver for NovAtel SPAN devices."], "package_details": ["NovAtel released a supported driver in early 2020. It is available here:", "The", "repository for this driver has been marked as Archived. Thus, this driver is not under active development and is not being maintained.", "This driver is specific to older OEM6 type", "products and is not supported by NovAtel.", "This is a driver for", ", especially the", ".", "This driver publishes GNSS data as a", ", and inertial navigation system (INS) data as", ". You can plot this using", ", as well as monitoring your overall system using", ":", "This driver assumes that your unit has been configured with the ethernet port enabled for TCP. There are various ways this can be set up, but the easiest is to connect to your receiver with", "(", "), using the serial or USB interface. Then, using the device's console:", "From the", "menu, select", ", which will take you through the position and orientation of the IMU relative to your vehicle's base_link, and the relative position of the GNSS antenna(s).", "Note that if you only need the console and won't need to run the SPAN setup wizard, you may bypass Novatel Connect and just use an ordinary serial console at 9600 baud. If you are configuring multiple units, you can run the SPAN wizard only once, and enter the supplied SPAN setup commands into the other devices using the console or the", "rosparam.", "You should see topics come up for", ",", ",", ",", ", etc. These will publish data once the system has acquired an initial GNSS fix.", "The source repository includes example captures from a", "mounted on a", ". To create your own captures, use", ":", "The following documents from NovAtel are helpful in understanding what this driver is about and how it works:", "If you'd like more information about", "or would like a quote for Husky equipped with SPAN, please use", "."]},
{"url": "https://wiki.ros.org/turtlebot3_teleop", "package": "turtlebot3_teleop", "package_summary": ["Provides teleoperation using keyboard for TurtleBot3."], "package_details": []},
{"url": "https://wiki.ros.org/urdf", "package": "urdf", "package_summary": [], "package_details": ["A number of different packages and components make up urdf. The following diagram attempts to explain the relationship between these components:", "In Indigo, the", "tool has moved to the", "package. You may need to run", "if you can't use", "This package contains a number of", "for robot models, sensors, scenes, etc. Each XML specification has a corresponding parser in one or more languages.", "There is large set of", "on how to build up your own robot models using the URDF specification. Check out the", "page.", "We also developed a macro language called", "to make it easier to maintain the robot description files, increase their readability, and to avoid duplication in the robot description files.", "See", "for a list of robots described by a URDF model.", "A command line tool", "check_urdf", "attempts to parse a file as a URDF description, and either prints a description of the resulting kinematic chain, or an error message.", "Note: You may need to run", ".", "Visual Studio Code has a", "that supports URDF visualization."]},
{"url": "https://wiki.ros.org/mrpt_ekf_slam_2d", "package": "mrpt_ekf_slam_2d", "package_summary": ["This package is a wrapper for the implementation of EKF-based SLAM with range-bearing sensors, odometry, and a 2D (+heading) robot pose, and 2D landmarks."], "package_details": ["The ROS node mrpt_ekf_slam_2d is a wrapper for the C++ class", ", part of MRPT. Thus, check out the documentation of that class for further details.", "For the convention on coordinate frames see", ".", "In order to use mrpt_ekf_slam_2d package it is necessary to install the last", "build and the", "(see also the", ") ."]},
{"url": "https://wiki.ros.org/trajectory_tracker", "package": "trajectory_tracker", "package_summary": ["Path following control package for wheeled mobile robot"], "package_details": []},
{"url": "https://wiki.ros.org/joy", "package": "joy", "package_summary": ["ROS driver for a generic Linux joystick.\n    The joy package contains joy_node, a node that interfaces a\n    generic Linux joystick to ROS. This node publishes a \"Joy\"\n    message, which contains the current state of each one of the\n    joystick's buttons and axes."], "package_details": ["For an example of using", "to control a teleoperation node with a joystick, see the", ".", "In some cases, multiple joysticks may control a single robot. For example, a user may use the default joystick to drive a robot, but a second user may wish to use a different kind. Since the button mappings on each joystick may be different, it will be necessary to remap buttons on one joystick so they can match. See the", "package for details.", "Most gamepads offer a force feedback function that can vibrate the gamepad. For it to work correctly, you have to specify correctly the", "parameter (on Noetic, when this parameter is empty, an autodetection algorithm tries to guess it).", "Once the force feedback device is correctly set, you can control the force feedback using the", "topic. Before trying it out, make sure the jumping gamepad on your table will not destroy anything. An example usage can look like this:", "The", "field specifies the strength of the vibrations. 0 is no vibration, 1 is maximum.", "If you do not know the correct value of the", "parameter, here are a few tips to figure it out.", "One way is to look into folder", ".", "The listing shows a few symbolic links, one of them pointing to your", "device. The symlink will end with", ". Look for a similarly named file, just ending with", ". You can either directly pass this value to", "(in this case", "), or you can follow the symbolic link to one of the", "files and set the event file as the parameter value (which would be", "in this example).", "Some gamepads will not appear in the", "listing - e.g. Xbox ONE gamepad connected via the wireless dongle and", "driver.", "You can see that I have connected a gamepad that appeared as", "with the force feedback device being", ".", "Table of index number of", ":", "Table of index number of", ":", "Table of index number of", ":", "Table of index number of", ":", "Table of index number of", ":", "Table of index number of", ":", "Table of index number of", ":"]},
{"url": "https://wiki.ros.org/moveit_experimental", "package": "moveit_experimental", "package_summary": ["Experimental packages for MoveIt!"], "package_details": ["See", "for the detail."]},
{"url": "https://wiki.ros.org/youbot_driver_ros_interface", "package": "youbot_driver_ros_interface", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/move_base_flex", "package": "move_base_flex", "package_summary": ["Move Base Flex (MBF) is a backwards-compatible replacement for move_base. MBF can use existing plugins for move_base, and provides an enhanced version of the planner, controller and recovery plugin ROS interfaces. It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin\u2019s feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. Furthermore, MBF enables the use of other map representations, e.g. meshes or grid_map\n       \n       This package is a meta package and refers to the Move Base Flex stack packages.The abstract core of MBF \u2013 without any binding to a map representation \u2013 is represented by the", "and the", ". For navigation on costmaps see", "and", "."], "package_details": ["(", ", default: 0.0)", "Use GitHub to", ". [", "]", "Move Base Flex (MBF) is a backwards-compatible replacement for move_base. MBF can use existing plugins for move_base, and provides an enhanced version of the same ROS interface. It exposes action servers for planning, controlling and recovering, providing detailed information of the current state and the plugin's feedback. An external executive logic can use MBF and its actions to perform smart and flexible navigation strategies. For example,", "has successfully deployed MBF at customer facilities to control TORU robots in highly dynamical environments. Furthermore, MBF enables the use of other map representations, e.g. meshes. The core features are:", "We have created Move Base Flex for a larger target group besides the standard developers and users of move_base and 2D navigation based on costmaps, as well as addressed move_base's limitations. Since robot navigation can be separated into planning and controlling in many cases, even for outdoor scenarios without the benefits of flat terrain, we designed MBF based on abstract planner-, controller- and recovery behavior-execution classes. To accomplish this goal, we created abstract base classes for the nav core", ",", "and", "plugin interfaces, extending the API to provide a richer and more expressive interface without breaking the current move_base plugin API. The new abstract interfaces allow plugins to return valuable information in each execution cycle, e.g. why a valid plan or a velocity command could not be computed. This information is then passed to the external executive logic through MBF planning, navigation or recovering actions\u2019 feedback and result. The planner, controller and recovery behavior execution is implemented in the abstract execution classes without binding the software implementation to 2D costmaps. In our framework,", "is just a particular implementation of a navigation system: its execution classes implement the abstract ones, bind the system to the costmaps. Thereby, the system can easily be used for other approaches, e.g. navigation on meshes or 3D occupancy grid maps. However, we provide a", "class without a binding to costmaps.", "Move Base Flex provides four actions which can be used by external executives to perform various navigation tasks and embed these into high-level applications. In the following the four actions get_path, exe_path, recovery and move_base are described in detail. The action definition files are stores here in the", "package.", "See", "See", "See", "See", "In addition to this new API, we also provide the actions, services and topics provided by", "for backwards-compatibility through the move_base legacy relay node.", "See", "for details.", "See", "for details.", "See", "for details.", "See", "for details.", "See", "for details.", "Note also that if patience runs out while planning, we will call planner's cancel method, interrupt it if it doesn't stop, and return", "Here you have a working minimal", ".", "See", "."]},
{"url": "https://wiki.ros.org/four_wheel_steering_controller", "package": "four_wheel_steering_controller", "package_summary": ["Controller for a four wheel steering mobile base."], "package_details": []},
{"url": "https://wiki.ros.org/swri_transform_util", "package": "swri_transform_util", "package_summary": ["The swri_transform_util package contains utility functions and classes for\n     transforming between coordinate frames."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_motor_diagnostic_tool", "package": "pr2_motor_diagnostic_tool", "package_summary": ["pr2_motor_diagnostic_tool"], "package_details": ["on Willow Garage blog."]},
{"url": "https://wiki.ros.org/moveit_ros_move_group", "package": "moveit_ros_move_group", "package_summary": ["The move_group node for MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/rviz_visual_tools", "package": "rviz_visual_tools", "package_summary": ["Utility functions for displaying and debugging data in Rviz via published markers"], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/pointcloud_to_laserscan", "package": "pointcloud_to_laserscan", "package_summary": ["Converts a 3D Point Cloud into a 2D laser scan. This is useful for making devices like the Kinect appear like a laser scanner for 2D-based algorithms (e.g. laser-based SLAM)."], "package_details": ["If you're trying to create a virtual laserscan from your RGBD device, and your sensor is forward-facing, you'll find", "will be much more straightforward and efficient since it operates on image data instead of bulky pointclouds. However, if your sensor is angled, or you have some other esoteric use case, you may find this node to be very helpful!", "Please check the", "for common problems, or open an", "if still unsolved.", "Same API as node, available as", "."]},
{"url": "https://wiki.ros.org/fanuc_post_processor", "package": "fanuc_post_processor", "package_summary": ["Fanuc post-processor"], "package_details": ["Documentation is here:"]},
{"url": "https://wiki.ros.org/ml_classifiers", "package": "ml_classifiers", "package_summary": [], "package_details": ["This package provides a ROS service for interfacing with various machine learning algorithms for supervised classification.  Three example classifiers are included, including a nearest neighbor and support vector machine classifier, but additional classifiers can be added easily though", ".", "ml_classifiers comes with 3 plugins built in: A \"zero\" classifier that classifies everything as class 0 no matter what, a nearest neighbor classifier, and an SVM classifier based on", ". More classifiers can be added easily though", "and by implementing the above interface."]},
{"url": "https://wiki.ros.org/moveit_ros", "package": "moveit_ros", "package_summary": ["Components of MoveIt that use ROS"], "package_details": []},
{"url": "https://wiki.ros.org/ypspur", "package": "ypspur", "package_summary": ["YP-Spur is a mobile robot motion control software with coordinate frame based commands."], "package_details": []},
{"url": "https://wiki.ros.org/raspicam_node", "package": "raspicam_node", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/swri_serial_util", "package": "swri_serial_util", "package_summary": ["swri_serial_util"], "package_details": []},
{"url": "https://wiki.ros.org/jsk_interactive", "package": "jsk_interactive", "package_summary": ["jsk_interactive"], "package_details": []},
{"url": "https://wiki.ros.org/yaml_cpp", "package": "yaml_cpp", "package_summary": [], "package_details": ["Starting in ROS Electric, Yamlcpp is installed as a", "system dependency. This means that you compile against Yamlcpp without requiring any ROS-specific build tools.", "The", "is defined in the ROS", "stack/package.  In order to get this rule, you need to edit your", "and", "as follows:", "Please see the", "for documentation."]},
{"url": "https://wiki.ros.org/urdfdom", "package": "urdfdom", "package_summary": [], "package_details": ["This is now an upstream package. Source can be found here:"]},
{"url": "https://wiki.ros.org/python_qt_binding", "package": "python_qt_binding", "package_summary": ["This stack provides Python bindings for Qt.\n    There are two providers: pyside and pyqt.  PySide is released under\n    the LGPL.  PyQt is released under the GPL.\n\n    Both the bindings and tools to build bindings are included from each\n    available provider.  For PySide, it is called \"Shiboken\".  For PyQt,\n    this is called \"SIP\".\n\n    Also provided is adapter code to make the user's Python code\n    independent of which binding provider was actually used which makes\n    it very easy to switch between these."], "package_details": ["This", "pkg is planned to become standalone (= separated from ROS). See", ". It is already available via", "."]},
{"url": "https://wiki.ros.org/teb_local_planner", "package": "teb_local_planner", "package_summary": ["The teb_local_planner package implements a plugin\n    to the base_local_planner of the 2D navigation stack.\n    The underlying method called Timed Elastic Band locally optimizes\n    the robot's trajectory with respect to trajectory execution time,\n    separation from obstacles and compliance with kinodynamic constraints at runtime."], "package_details": ["Use GitHub to", ". [", "]", "(", ", default: 0.5)", "(", ", default: 0.0)", "(", ", default: \"point\")", "(", ", default: 0.2)", "(", ", default: 0.3)", "(", ", default: 0.5)", "(", ", default: \"\")", "(", ", default: 5)", "(", ", default: true)", "(", ", default: \"odom\")", "This package implements an online optimal local trajectory planner for navigation and control of mobile robots as a plugin for the ROS", "package.", "The initial trajectory generated by a global planner is optimized during runtime w.r.t. minimizing the trajectory execution time (time-optimal objective),", "separation from obstacles and compliance with kinodynamic constraints such as satisfying maximum velocities and accelerations.", "Get started by completing the tutorials in the", "section.", "Features introduced in", "are presented in the following video (supporting car-like robots and costmap conversion).", "The teb_local_planner package allows the user to set", "in order to customize the behavior. These parameters are grouped into several categories: robot configuration, goal tolerance, trajectory configuration, obstacles, optimization, planning in distinctive topologies and miscellaneous parameters. Some of them are chosen to be compliant with the", ". Many (but not all) parameters can be modified at runtime using", ".", "The following parameters are relevant for the footprint model used for optimization (see", ").", "The following parameters are relevant only if", "plugins are desired (see tutorial):"]},
{"url": "https://wiki.ros.org/pr2eus", "package": "pr2eus", "package_summary": ["pr2eus"], "package_details": []},
{"url": "https://wiki.ros.org/stomp_moveit", "package": "stomp_moveit", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/cl_tf", "package": "cl_tf", "package_summary": ["Client implementation to use TF from Common Lisp"], "package_details": ["Implementation of", "for", "nodes."]},
{"url": "https://wiki.ros.org/rqt_py_common", "package": "rqt_py_common", "package_summary": ["rqt_py_common provides common functionality for rqt plugins written in Python.\n    Despite no plugin is provided, this package is part of the rqt_common_plugins\n    repository to keep refactoring generic functionality from these common plugins\n    into this package as easy as possible.\n\n    Functionality included in this package should cover generic ROS concepts and\n    should not introduce any special dependencies beside \"ros_base\"."], "package_details": []},
{"url": "https://wiki.ros.org/rosbridge_suite", "package": "rosbridge_suite", "package_summary": ["Rosbridge provides a JSON API to ROS functionality for non-ROS programs.\n    There are a variety of front ends that interface with rosbridge, including\n    a WebSocket server for web browsers to interact with.\n\n    Rosbridge_suite is a meta-package containing rosbridge, various front end\n    packages for rosbridge like a WebSocket package, and helper packages."], "package_details": ["The", "is a specification for sending JSON based commands to ROS (and in theory, any other robot middleware). An example of the protocol for subscribing to a topic:", "The rosbridge_suite package is a collection of packages that implement the rosbridge protocol and provides a", "transport layer.", "Source code is available at", ". Please file issues and pull requests there.", "Rosbridge is a community project and involvement is encouraged! In addition to the", "repository, check out the", "and", "."]},
{"url": "https://wiki.ros.org/rosflight_utils", "package": "rosflight_utils", "package_summary": ["Supporting utilities for ROSflight packages"], "package_details": []},
{"url": "https://wiki.ros.org/summit_xl_sim", "package": "summit_xl_sim", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation.", "This package contains the launch and configuration files to spawn the joint controllers with the ROS controller_manager. It allows to launch the joint controllers for the Summit XL (4 axes skid steering + 2 axes ptz), Summit XL OMNI (4 axes skid steering, 4 axes swerve drive), Summit X-WAM (4 axes skid steering, 4 axes swerve drive, 1 linear axis for scissor mechanism). The Summit XL simulation stack follows the gazebo_ros controller manager scheme described in", "Control the robot joints in all kinematic configurations, publishes odom topic and, if configured, also tf odom to base_link. Usually takes as input joystick commands and generates as outputs references for the gazebo controllers defined in summit_xl_control. This package permits an alternative way to control the robot motion (4 motorwheels) that by default is carried on by the Gazebo plugin (skid-steer). In the default configuration this package only controls the pan-tilt camera joints. When used as main controller of the simulated robot, this node also computes the odometry of the robot using the joint movements and a IMU and publish this odometry to /odom. The node has a flag in the yaml files that forces the publication or not of the odom->base_footprint frames, needed by the localization and mapping algorithms."]},
{"url": "https://wiki.ros.org/lanelet2_maps", "package": "lanelet2_maps", "package_summary": ["Example maps in the lanelet2-format"], "package_details": []},
{"url": "https://wiki.ros.org/ublox", "package": "ublox", "package_summary": ["Provides a ublox_gps node for u-blox GPS receivers, messages, and serialization packages for the binary UBX protocol."], "package_details": ["The driver publishes", "and", "messages. The ublox_gps package provides a node to subscribe to various u-blox messages."]},
{"url": "https://wiki.ros.org/map_server", "package": "map_server", "package_summary": ["map_server provides the", "ROS", ", which offers map data as a ROS", ". It also provides the", "command-line utility, which allows dynamically generated maps to be saved to file."], "package_details": ["retrieves map data and writes it out to", "and", ".  Use the", "option to provide a different base name for the output files. The", "and", "options take values between 0 and 100. To save different map topic set", "to your costmap topic.", "Image data is read in via", "; supported formats vary, depending on what SDL_Image provides on a specific platform.  Generally speaking, most popular image formats are widely supported.  A notable exception is that PNG is not supported on OS X.", "Given a pixel that has a COLOR value", "in the range", ", how should we interpret this value when put into the ROS message? First we convert integer", "to a floating point number", "depending on the interpretation of the", "flag from the yaml.", "This will allow you to output a full gradient of values ranging from", ". To output", ", simply use the alpha channel of a png, where any transparency will be interpreted as unknown.", "This mode will output", "for each pixel, so output values are", "."]},
{"url": "https://wiki.ros.org/tf2_eigen", "package": "tf2_eigen", "package_summary": ["tf2_eigen"], "package_details": ["Please see the", "for use."]},
{"url": "https://wiki.ros.org/pocketsphinx", "package": "pocketsphinx", "package_summary": [], "package_details": ["This package provides access to the", "speech recognizer. It uses gstreamer to automatically split the incoming audio into utterances to be recognized, and offers services to start and stop recognition.", "Currently, the recognizer", "a language model and dictionary file. These can be automatically built from a corpus of sentances using the", ". Example launch files, language models, and dictionary files can be found in the", "directory of the package. The", "example controls a mobile base using commands such as \"", "\" or \"", "\". The", "example uses some of the standard items and names from the", "@Home contest, for instance, it should recognize \"", "\" or \"", "\"."]},
{"url": "https://wiki.ros.org/katana_gazebo_plugins", "package": "katana_gazebo_plugins", "package_summary": [], "package_details": ["Currently, there is only one plugin available that simulates the gripper. See packages", "and", "for usage examples and for information on the Gazebo parameters (not documented here)."]},
{"url": "https://wiki.ros.org/rsv_balance_msgs", "package": "rsv_balance_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/state_exchanger", "package": "state_exchanger", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The state that is exchanged is read from a", "state machine.", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/network_traffic_control", "package": "network_traffic_control", "package_summary": [], "package_details": ["There are some peculiarities about the way", ", used for bandwidth control, and", ", used for latency and loss emulation, interact that affect the link emulation metrics. This section describes what the expected network emulation result is depending on the usage scenario.", "In order, to verify experimentally the theoretical projections of the", "tool, a node (", ") and an associated launch file (", ") have been created which implement the network emulation on the", "(loopback) interface and use the", "package for metric measurement.", "This node and the associated launch file live in the", "package in the", "subdirectory.", "Next, a tbf (", ") qdisc for bandwidth control is attached. Finally, if latency or loss control is enabled, a netem qdisc child is attached to the tbf qdisc.", "An", "qdisc is created on the interface and an", "interface is created. A filter is attached to the ingress qdisc that redirects matching packets to the ifb interface. A setup identical to that described for egress is then created on this ifb interface.", "The parameter of interest for netem is", "which defines the size of an internal queue in packets. If no bandwidth control is in place, then this parameter is set to a high value (1000). If there is bandwidth control then the value of this parameter is selected as a function of latency and packet size, more specifically, it is equal to the number of packets whose transfer time at link capacity is equal to the specified latency."]},
{"url": "https://wiki.ros.org/turtlebot3_autorace_camera", "package": "turtlebot3_autorace_camera", "package_summary": ["TurtleBot3 AutoRace ROS package that controls Raspberry Pi Camera, and process the image"], "package_details": ["Refer to parameters for", "with picamera. This package is provided parameters from .", "files."]},
{"url": "https://wiki.ros.org/wheeled_robin_node", "package": "wheeled_robin_node", "package_summary": [], "package_details": ["To start the", "driver node use the launch files in wheeled_robin_bringup."]},
{"url": "https://wiki.ros.org/object_recognition_msgs", "package": "object_recognition_msgs", "package_summary": ["Object_recognition_msgs contains the ROS message and the actionlib definition used in object_recognition_core"], "package_details": []},
{"url": "https://wiki.ros.org/schunk_simulated_tactile_sensors", "package": "schunk_simulated_tactile_sensors", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/schunk_sdh", "package": "schunk_sdh", "package_summary": ["This package provides an interface for operating the schunk dexterous hand (SDH), including the tactile sensors."], "package_details": ["To use this package you need a schunk dexterous hand", "with", ". Other firmware versions may work, but are not officially supported. Alternatively you can use a simulated version without any hardware, see", ".", "The installation is tested for Ubuntu 10.04, 10.10, 11.04 and 11.10 using ROS", ". If you discover problems installing them on other platforms, please", ".", "The", "package provides a configurable node for operating a schunk dexterous hand.", "This package is not intended to be used directly, but with the corresponding launch and yaml files from e.g.", "in the", "stack.", "For using only the sdh use", "All hardware configuration is done in the", "package. A sample parameter file for the sdh in \"schunk_hardware_config/sdh/config/sdh.yaml\" could look like this"]},
{"url": "https://wiki.ros.org/laser_scan_splitter", "package": "laser_scan_splitter", "package_summary": ["The laser_scan_splitter takes in a LaserScan message and splits it into a number of other LaserScan messages. Each of the resulting laser scans can be assigned an arbitrary coordinate frame, and is published on a separate topic."], "package_details": ["The", "takes in a", "message and splits it into a number of other", "messages. Each of the resulting laser scans can be assigned an arbitrary coordinate frame, and is published on a separate topic.", "You can run the", "on a pre-recorded bag file that comes with the package. First, make sure you have the", "stack downloaded and installed by following the instructions", ".", "You should see a result similar to the video below. The 3 laser scan messages displayed in", "are obtained by splitting the original scan.", "Two drivers are available:", "and", ". Their parameters and topics are identical.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/manifest_cleaner", "package": "manifest_cleaner", "package_summary": [], "package_details": ["If the", "tag is not used, the summary will contain whether the URL tag is specified or not.", "If the", "tag is used, the summary will contain the HTTP response numbers obtained when the given URL is downloaded. Note that this option will take a bit longer to run.", "A list of all the authors and the number and list of all the stacks/packages they maintain. Minor parsing is done to separate comma delineated lists and email addresses when they are of the form 'My name/", "'."]},
{"url": "https://wiki.ros.org/maxwell_calibration", "package": "maxwell_calibration", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/camera_handler", "package": "camera_handler", "package_summary": [], "package_details": ["In V-REP it is possible to simulate a vision sensor. Vision sensors are added to the scene with [menu bar --> Add --> Vision sensor]. After a double-click on a vision-sensor, we can set some parameters like the resolution and the field of view of the camera. In addition we added a GUI to set the frequency of acquisition and the type of color coding (RGB or grayscale) that should be used."]},
{"url": "https://wiki.ros.org/rosmsg", "package": "rosmsg", "package_summary": ["rosmsg contains two command-line tools:", "and", ".", "is a command-line tool for\n    displaying information about", ".", "is a command-line tool for displaying\n    information about", "."], "package_details": ["and", "are handy command-line tools that provide reference information for developers and also serve as a powerful introspection tool for learning more about data being transmitted in ROS.", "and", "are stable tools. There is currently no plan to add new features to them.", "For example, if you are using a message in your code, you can type", "at the command-line to look up its fields:", "For even quicker typing, you can omit \"", "\", and", "will search all packages for a matching message.", "You can also use this in an online system with tools like", ". For example,", "will tell you the message type of a topic:", "You can pass this to", "to quickly see the fields of the message:", "Once you know more about the fields of a particular message, you can then listen them at the command-line, e.g.", "The", "command-line tool displays information about ROS", ". The following sections describe the commands that are available.", "Note that messages in a subfolder may not be listed as of March 2017 (", ").", "The", "command-line tool displays information about ROS services. It has the exact same usage as", "(see what it offers when it runs without sub-command below):"]},
{"url": "https://wiki.ros.org/jog_launch", "package": "jog_launch", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ridgeback_description", "package": "ridgeback_description", "package_summary": ["URDF robot description for Ridgeback"], "package_details": ["This package provides a", "model of", ". For an example launchfile to use in visualizing this model, see", ".", "Ridgeback has a suite of optional payloads called accessories. These payloads can be enabled and placed on Ridgeback using environment variables specified at the time the", "is rendered to URDF. Available accessory vars are:", "As an alternative to individually specifying each accessory, some fixed configurations are provided in the package. These can be specified using the", "arg to", ", and are intended especially as a convenience for simulation launch."]},
{"url": "https://wiki.ros.org/jog_control", "package": "jog_control", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/steer_bot_hardware_gazebo", "package": "steer_bot_hardware_gazebo", "package_summary": [], "package_details": ["inherits", "so that the plugin is integrated to", ".", "is designed to have two joint interfaces, one is velocity_joint_interface for the single rear wheel joint and the other is position_joint_interface for the single front steer joint. This concept keeps the controller's abstraction to be applied in various types of configuration by converting the joint interfaces in the controller to ones on an actual robot via", "or", ".", "(", ")", "(", ")", "has an example launch file to spawn", "with", "named", ".", "An example of usage of this plugin can be seen in", ", especially in", ".", "This package provides 4-wheel car-like robot model with steer mechanism for Gazebo simulation, by using", "plugin.", "We developed this plugins assuming that", "is selected as the driving controller.", "Now we need to do it for a Gazebo model too, which is the main role of this plugin. The following figure shows how a velocity command of", "converted to a joint command to", "via", ".", "Each type of joint interface on", "is split into two interface for right and left. This is because", "doesn't support closed links (e.g. parallel link or Ackermann link), which means we need to virtually imitate such links by software.", "In order to achieve the conversion mentioned above, you need to register joint interfaces for both", "and", "in", ".", "For", ", it's simple to just register two joint interface for a rear wheel and a front steer as mentioned previously.", "For", ", 4 more velocity joint interfaces for wheels and 2 more position joint interface for front steers (in total 2 + 4 + 2 = 8 joint interface are registered in this plugin).", "An example of registering such joint interfaces can be seen in", ".", "In", "in your robot, add the following tag to apply", ".", "An example of a xacro is", "in", "."]},
{"url": "https://wiki.ros.org/turtlebot_dashboard", "package": "turtlebot_dashboard", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roscpp_core", "package": "roscpp_core", "package_summary": ["Underlying data libraries for roscpp messages."], "package_details": []},
{"url": "https://wiki.ros.org/realtime_tools", "package": "realtime_tools", "package_summary": ["Contains a set of tools that can be used from a hard\n    realtime thread, without breaking the realtime behavior."], "package_details": ["The", "allows users that write C++", "to publish messages on a ROS topic from a hard realtime loop. The normal ROS publisher is not realtime safe, and should not be used from within the update loop of a realtime controller. The realtime publisher is a wrapper around the ROS publisher; the wrapper creates an extra non-realtime thread that publishes messages on a ROS topic. The example below shows a typical usage of the realtime publisher in the", "and", "methods of a realtime controller:"]},
{"url": "https://wiki.ros.org/people_msgs", "package": "people_msgs", "package_summary": ["Messages used by nodes in the people stack."], "package_details": ["- Generic message for detecting the location of a person. Includes a 3-D point estimate, reliability estimate and covariance matrix.", "- An array of PositionMeasurements as well as a co-occurence array.", "- A position estimate with an added velocity vector, as well as the ability to add tags to the person. Has no header, should only be used in conjunction with PersonStamped or People.", "- A header + a person", "- A header + an array of persons"]},
{"url": "https://wiki.ros.org/turtlebot3_msgs", "package": "turtlebot3_msgs", "package_summary": ["Message and service types: custom messages and services for TurtleBot3 packages"], "package_details": []},
{"url": "https://wiki.ros.org/spur_gazebo", "package": "spur_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/touch_skill_msgs", "package": "touch_skill_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"touch_skill_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/touch_skill_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/uavc_v4lctl", "package": "uavc_v4lctl", "package_summary": [], "package_details": ["This ROS node is just a wrapper for the", "tool. It provides two services, to set and to get particular", "video device parameter. If a yaml file will be provided a save and restore capability will be enabled. Parameter are then loaded and set automatically in the capture device when starting the node. Changed parameter are stored to a yaml file when the program ends. Additionally a dynamic reconfigure rqt gui is available to manipulate v4l parameter.", "The below v4lctl list output is based on an Osprey 440 bttv capture card.", "is optimized for this card (but the services provided by this ROS node are generic and can be used for any hardware related available v4l parameter). Your card may output other options. To support them as well feel free to adapt the files v4lctl_node.cpp and v4lctlNodeDyn.cfg in the repository to your needs.", "The sources can be found here:"]},
{"url": "https://wiki.ros.org/acado", "package": "acado", "package_summary": ["ACADO Toolkit"], "package_details": ["is a software environment and algorithm collection for automatic control and dynamic optimization. It provides a general framework for using a great variety of algorithms for direct optimal control, including model predictive control, state and parameter estimation and robust optimization. ACADO Toolkit is implemented as self-contained C++ code and comes along with user-friendly Matlab interfaces. The object-oriented design allows for convenient coupling of existing optimization packages and for extending it with user-written optimization routines.", "The ACADO Toolkit is made available in ROS Indigo by", ". You can install it on Ubuntu like so:"]},
{"url": "https://wiki.ros.org/visp_tracker", "package": "visp_tracker", "package_summary": ["Wraps the ViSP moving edge tracker provided by the ViSP visual\n    servoing library into a ROS package.\n\n    This computer vision algorithm computes the pose (i.e. position\n    and orientation) of an object in an image. It is fast enough to\n    allow object online tracking using a camera."], "package_details": ["is part of", "stack.", "even if a nodelet is available for the client and viewer, one should avoid running them in the same process than the vision pipeline to avoid crashing the whole pipeline if something goes wrong.", "The package is composed of one node called", "that does the tracking and two additional nodes", "(that allows to set the initial pose by user mouse click) and", "that allows to visualize the result of the tracking.", "The", "node tries to track the object as fast as possible but needs to be initialized using the client. The viewer can be used to monitor the tracking result.", "When the nodelet version is used, no-copy intraprocess publishing is used. See the", "documentation for more information.", "Use GitHub to", "."]},
{"url": "https://wiki.ros.org/turtlesim", "package": "turtlesim", "package_summary": ["turtlesim is a tool made for teaching ROS and ROS packages."], "package_details": ["As of", "turtlesim uses the", "/Twist message instead of its own custom one (", "in", "and older). Also the topic has been changed to", "(instead of", "before)."]},
{"url": "https://wiki.ros.org/sr_edc_muscle_tools", "package": "sr_edc_muscle_tools", "package_summary": ["sr_edc_muscle_tools - Usefull commands and basic demo for the ethercat muscle hand."], "package_details": []},
{"url": "https://wiki.ros.org/staubli_tx90_support", "package": "staubli_tx90_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/basic_states_skill_msgs", "package": "basic_states_skill_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"basic_states_skill_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/basic_states_skill_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/nao_extras", "package": "nao_extras", "package_summary": [], "package_details": ["This stack replaces parts of the", "stack since version 0.2."]},
{"url": "https://wiki.ros.org/rtt_geometry_msgs", "package": "rtt_geometry_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_calibration_launch", "package": "pr2_calibration_launch", "package_summary": ["Launch files and configuration files needed to run the calibration pipeline on PR2. This package is\n     still experimental. Expect large changes tp occur."], "package_details": []},
{"url": "https://wiki.ros.org/linksys_access_point", "package": "linksys_access_point", "package_summary": [], "package_details": ["This package implements the", "dynamic_reconfigure interface for controlling an access point for Linksys access points."]},
{"url": "https://wiki.ros.org/ridgeback_bringup", "package": "ridgeback_bringup", "package_summary": [], "package_details": ["See", "for information on Ridgeback configurations."]},
{"url": "https://wiki.ros.org/std_msgs", "package": "std_msgs", "package_summary": ["Standard ROS Messages including common message types representing primitive data types and other basic message constructs, such as multiarrays.\n    For common, generic robot-specific message types, please see", "."], "package_details": ["contains wrappers for ROS primitive types, which are documented in the", ". It also contains the", "type, which is useful for sending an empty signal. However, these types do not convey semantic meaning about their contents: every message simply has a field called \"", "\". Therefore, while the messages in this package can be useful for quick prototyping, they are", ". For ease of documentation and collaboration, we recommend that existing messages be used, or new messages created, that provide meaningful field name(s).", "Newly proposed, mistyped, or obsolete package. Could not find package \"std_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/std_msgs/manifest.yaml", "Note that this package also contains the \"MultiArray\" types, which can be useful for storing sensor data.", ", the same caveat applies: it's usually \"better\" (in the sense of making the code easier to understand, etc.) when developers use or create non-generic message types (see", "for more detail).", "There are currently no plans to add new data types to the", "package."]},
{"url": "https://wiki.ros.org/turtlebot_2dnav", "package": "turtlebot_2dnav", "package_summary": [], "package_details": ["The", "application can be run with the following command:", "The", "stack that is the core of the turtlebot_2dnav application can be commanded via", ",", ", or through code."]},
{"url": "https://wiki.ros.org/asr_mild_calibration_tool", "package": "asr_mild_calibration_tool", "package_summary": ["A tool to calibrate the relative frames between the mild's laserscanner and the cameras"], "package_details": ["This package provides a tool to collect transformation data between the mild's laserscanner sensor and it's camera head. This data can then used calibrate the mild's kinematic chain using the", ".", "The calibration object in the form of a", "could be recognized by a 2D laserscanner and, using its detected edges p", ", p", "and p", "as well as the priorly known proportions, the pose of its top point", "can be calculated.", "All relevant specifications for the calibration object can be retrieved and even changed using the", "file.", "Two", "have been integrated into the calibration software:", "Both the", "(left), which is used in the mild platform, as well as the", "(right), which has been used for evaluation of the calibration tool, have been integrated into the package and can be selected by changing a single parameter (", "The supported types of", "units depend on the", "package and are described there.", "All", "supported by the", "package can be used for calibration."]},
{"url": "https://wiki.ros.org/automotive_platform_msgs", "package": "automotive_platform_msgs", "package_summary": ["Generic Messages for Communication with an Automotive Autonomous Platform"], "package_details": []},
{"url": "https://wiki.ros.org/tedusar_box_detection_msgs", "package": "tedusar_box_detection_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/staubli", "package": "staubli", "package_summary": ["ROS-Industrial support for Staubli manipulators (metapackage)."], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program. It currently contains robot support packages for Staubli manipulators and associated", "packages.", "See the", "metapackage for additional packages.", "See", "for a VAL 3 based driver for use with CS8 controllers and Staubli 6-axis manipulators. See the", "and the", "for more information.", "For the generic ROS-Industrial tutorials, please see the ROS-Industrial", ".", "For questions related to the Staubli support or ROS-Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/spinnaker_sdk_camera_driver", "package": "spinnaker_sdk_camera_driver", "package_summary": [], "package_details": ["Modify the", "file replacing the cam-ids and master cam serial number to match your camera's serial number. Then run the code as:"]},
{"url": "https://wiki.ros.org/termcolor", "package": "termcolor", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/task_allocation", "package": "task_allocation", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The following packages of the", "are required:", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the auction process.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/asr_halcon_bridge", "package": "asr_halcon_bridge", "package_summary": ["This package is used to convert between image-messages of the ROS environment and HALCON-images."], "package_details": ["This Package contains a library which is used to convert point clouds and images between ROS and", "specific data structures.", "The structure of this library is mostly based on the", "-package, for more information you can check out the documentation for that.", "To be able to build this package and use it in your project you will need to have a version of the", "image processing library installed. So far it was tested mainly with version 11 but in theory it should work with higher versions as well as the basic structure of the data types has not changed (build tests have been conducted with version 12 as well).", "The environment variables", "and", "need to be set correctly, otherwise cmake won't be able to find your HALCON installation. Usually this should be the case if you have followed the installation guide of HALCON.", "To convert a", "to a", "call one of the following functions:", "The return-value is a", "object, which contains a", "-Pointer as a member called", ".", "To convert a", "to ROS again call one of the following member functions:", "to convert a", "to a", "(the member in the returned", "is called", ")."]},
{"url": "https://wiki.ros.org/stdr_parser", "package": "stdr_parser", "package_summary": [], "package_details": ["is a Yaml/XML parser created for", ". Its job is to parse resource files (robots and sensors) and create the according stdr_msgs. Also, provided a stdr_msgs message", "can save it to a Yaml or XML file. The parser structure is such that it can be \"easily\" extended with more file types (such as JSON f.e.) by changing only specific source files (the filetype parser and writer). A brief overview of the parsing steps follow.", "takes as input a Yaml or XML file and initially does a \"blind\" parsing of the file, meaning that no validation is performed. Of course if the file does not exist or is malformed, a", "is thrown. This initial parsing creates a tree consisting of stdr_parser::Node objects and represents the initial file. As the following sections describe, for convenience reasons you can have", "tags in your robot or sensor file, which are used for including  other resources (for example in a robot you can include laser and sonar sensors without writing them from the scratch). During the parsing the specific filenames are parsed also recursively.", "When a", "tag is found, during the parsing step, a stdr_parser::Node is created tagged as", ". For example a robot XML resource follows:", "and the", "In addition, every", "contains a level value that is increased when the recurrent file depth increases. After the first step, the tree will look like that (the levels in [ ]):", "The second step is to eliminate the", "tags from the tree. To do so a sanity check is performed: the parent node and the child node of a", "node must be the same. If the above holds, the", "node is eliminated, as well as its child and the child's children are connected to", "'s parent. The result follows:", "The third step is the recursive node merging. In this step the", "file under", "is of crucial importance. There, the tags that can have multiple occurrences under a specific tag are placed. The current implementation allows multiple occurrences in these tags:", "This is the final parsing step where the validation is performed. Crucial role plays the", "file under", ". There for every valid tag, the allowed and required children are specified. (Look at the end of the page for the file's contents). The validation step reads this file and performs", "and", "checks for all tree nodes.", "After the tree is fully created,", "can create the according", ". This is performed seamlessly by using templates. An example of creating a", "follows:", "In a similar way a", "message can be saved to a Yaml or XML file:", "If anything goes wrong an", "is thrown. The way to use it in a source code file follows:", "The", "exceptions hold a trail of the error for better debugging. Example:"]},
{"url": "https://wiki.ros.org/sr_gui_grasp_controller", "package": "sr_gui_grasp_controller", "package_summary": [], "package_details": ["You can also save a current hand pose (obtained either by interpolating between two grasps, or by moving then hand with the sliders) by clicking on the", "button."]},
{"url": "https://wiki.ros.org/teraranger_array", "package": "teraranger_array", "package_summary": ["This package provides ros nodes for multi-sensor arrays from Terabee"], "package_details": ["*", "*", "*", "*", "*"]},
{"url": "https://wiki.ros.org/swarm_behaviors_position", "package": "swarm_behaviors_position", "package_summary": [], "package_details": ["The following packages of the", "are required:", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/tf_publisher_gui", "package": "tf_publisher_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_descriptor_surface_based_recognition", "package": "asr_descriptor_surface_based_recognition", "package_summary": ["This package contains a 6-DoF object localizer for textured household objects"], "package_details": ["This package contains an object localization system that returns 6-DoF poses for textured objects in RGBD-data.", "There are two types of parameters which can be set, static and dynamic ones. The static ones can be found in the .yaml file in the param-directory and the dynamic ones in the launch-file (or during runtime by using", ")."]},
{"url": "https://wiki.ros.org/blort_msgs", "package": "blort_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/automotive_navigation_msgs", "package": "automotive_navigation_msgs", "package_summary": ["Generic Messages for Navigation Objectives in Automotive Automation Software"], "package_details": []},
{"url": "https://wiki.ros.org/vrep_ros_bridge", "package": "vrep_ros_bridge", "package_summary": [], "package_details": ["is a plugin for V-Rep developed by the Inria", "team located at", ".", ", developed by", ", is an open-source state-of-the-art (and freely available for academic use) 3D physical simulation engine which is becoming more and more widespread in the robotics community thanks to its flexibility (possibility to simulate many different robotic platforms), dynamical engine (it supports ODE, Bullet and Vortex), and finally customizability (it offers many different possibilities to include one's own code or to interface it with the external world).", "ROS V-Rep Bridge uses the", "package. Pluginlib is a C++ library for loading and unloading plugins from within a ROS package. Plugins are dynamically loadable classes that are loaded from a runtime library (i.e. shared object, dynamically linked library). In this way our handlers are actually plugins with some dependencies. If we don't need a handler or we don't have installed its dependencies we are still able to build our bridge (that plugin will not be available). For example, the", "needs", ". If we don't want to install Telekyb we can just add a file called CATKIN_IGNORE in the quadrotor_tk_handler folder and it will not be considered. In spite of this the other handlers will be available.", "We have an object in the scene (let's say a quadrotor) and we want that the plugin", "manage it. To do it we will have to tag the object with a predefined string. If we don't do it the plugin will not act on the object. We will show how to tag a quadrotor but the procedure for the other objects will be similar.", "The function 'simExtSetFloatCustomDataFromHeader()' adds a custom data to the object related to 'sim_ext_ros_bridge_set_obj_twist_data_main'. As we can see, the function requires a third input. If requested, we can add a value to our custom data, setting the third input of the function. In our case, since we don't want to use this additional parameter we set it to zero (it will be ignored). We can add float and int values. If you want to add an int value you have to use the function 'simExtSetIntCustomDataFromHeader()'. You can find the list of the Custom Lua Variables in the description of each handler. Moreover you will find the complete list in the file", "(From line 149). In certain case the third values will be important (for instance to set the frequency of the camera acquisition). You will find more information about these commands in each wiki.ros page dedicated to the packages.", "You will find a guide for the installation in the", ".", "You can find info about this demo", "."]},
{"url": "https://wiki.ros.org/tuw_marker_server", "package": "tuw_marker_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosserial_embeddedlinux", "package": "rosserial_embeddedlinux", "package_summary": ["rosserial for embedded Linux enviroments"], "package_details": ["There are a variety of great embedded linux systems on the market today which enable quickly and easily programming hardware. Some, like the", "support an entire electro-mechanical robotics platform. Others, like the Chumby alarm clock or WRT54-class routers provide just an inexpensive linux controller. This class of device typically supports USB and wifi, has USB drivers for webcam and USB-serial dongles, is physically small, and consumes under 10 watts of electrical power. This makes them expandable and interesting for use on smaller robots, especially when vision is desired.", "Using the", "package, you can use ROS directly with the these systems.", "provides a ROS communication protocol that works over your embedded linux system's serial UART, or its wifi or network connection. It allows your embedded linux system to run linux processes that are full fledged ROS nodes that can directly publish and subscribe to ROS topics, advertise services and request services, publish TF transforms, and get the ROS system time over any of the supported connection types.", "The", "package supports the following major connection types and capabilities:", "This package contains embedded-linux-specific extensions required to run", "on a small embedded linux system such as the VEXPro controller, Chumby alarm clock, WRT54GL router, Raspberry Pi, or many similar devices. It is meant to demonstrate how easy it is to integrate custom hardware and cheap sensors including USB cameras into your ROS project using an embedded linux system. The Tutorials of this package will walk you through setting up your run environment and creating a few example programs.", "Go to the", "to learn how to install and use the package to connect your embedded linux system to ROS.", "Please file new bugs on the project's", ". The bugs listed below are the most serious, which you would want to be aware of when considering use of this technology. You are encouraged to contribute fixes."]},
{"url": "https://wiki.ros.org/rc_roi_manager_gui", "package": "rc_roi_manager_gui", "package_summary": ["The ros client for the region of interest manager of the itempick and boxpick modules"], "package_details": ["Use GitHub to", ". [", "]", "See", "and", "for more details.", "For the", "module:", "For the", "module:"]},
{"url": "https://wiki.ros.org/tuw_ellipses", "package": "tuw_ellipses", "package_summary": ["The tuw_ellipses package contains a computer vision library which is able to detect ellipses within images.  \n    The package is able to estimate the pose of the circle related to the ellipse the circle diameter as well as the camera parameter are known.\n    A dynamic reconfigure interface allows the user to tune the parameter of the system to ones needs.\n    But be aware that the pose of a projected circle within a image (ellipse) has two solutions and only one is published as TF."], "package_details": ["This package detects ellipses in camera images and computes the 3D pose of the related circle if the radius of the circle is given. The current 3D pose estimation is based on the [Chen2004] and the successor of the", "package. Various Parameter and algorithm used to find ellipses can be tuned via ROS shared parameters or by using the dynamic reconfigure interface.", "Chen2004) Chen, Q.; Wu, H. & Wada, T. Pajdla, T. & Matas, J. (Eds.) Camera Calibration with Two Arbitrary Coplanar Circles Computer Vision - ECCV 2004, Springer Berlin Heidelberg, 2004, 3023, 521-532,"]},
{"url": "https://wiki.ros.org/graspdb", "package": "graspdb", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/svenzva_moveit", "package": "svenzva_moveit", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_hand", "package": "sr_hand", "package_summary": ["This is a ROS interface to the Shadow Robot's robotic hand. It\n        contains both an interface to the real hand (communicating via\n        a CAN interface) and a simulated version of the hand. It also\n        contains an interface to Shadow Robot's muscle arm."], "package_details": ["For more information please see our", "."]},
{"url": "https://wiki.ros.org/people_tracking_filter", "package": "people_tracking_filter", "package_summary": ["A collection of filtering tools for tracking people's locations"], "package_details": []},
{"url": "https://wiki.ros.org/rsv_balance", "package": "rsv_balance", "package_summary": [], "package_details": ["'s", "common package.", "Tutorials", "."]},
{"url": "https://wiki.ros.org/ndt_map", "package": "ndt_map", "package_summary": [], "package_details": ["NDT maps can be created either using a regular grid data structure (", ") or using an irregular grid (", "). The recommended mode is to use", ", as most of the subsequent algorithms have been optimized for that data structure."]},
{"url": "https://wiki.ros.org/pysdf", "package": "pysdf", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/srv_tools", "package": "srv_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/wpi_jaco_msgs", "package": "wpi_jaco_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"wpi_jaco_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/wpi_jaco_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/canopen_master", "package": "canopen_master", "package_summary": ["CiA(r) CANopen 301 master implementation with support for interprocess master synchronisation."], "package_details": []},
{"url": "https://wiki.ros.org/summit_xl_navigation", "package": "summit_xl_navigation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/canopen_402", "package": "canopen_402", "package_summary": ["This implements the CANopen device profile for drives and motion control. CiA(r) 402"], "package_details": ["This package contains the implementation of the CiA 402 DSP protocol. It just communicates via objects (", ", no direct CAN communication is needed."]},
{"url": "https://wiki.ros.org/segbot_gazebo", "package": "segbot_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_flir_ptu_driver", "package": "asr_flir_ptu_driver", "package_summary": ["asr_flir_ptu_driver is a package for controlling a flir ptu via (external) msg\n     authors: Valerij Wittenbeck, Joachim Gehrung, Pascal Meissner, Patrick Schlosser"], "package_details": ["Using the ptu_left.launch launchfile the topics shown below will be found under", ".", "Using the ptu_left.launch launchfile the topics shown below will be found under", ".", "Using the ptu_left.launch launchfile all parameters shown below will be found under", ".", "There are no external services needed. Nevertheless, if the GUI is used, it uses a few services offered by the driver, therefore always start", "before", "Using the ptu_left.launch launchfile the services shown below will be found under", ".", "needs to be invoked from the terminal to start the PTU. Make sure it is connected. Configure the forbidden areas in the", "as you need them (details on forbidden areas in Chapter 2). Then continue with the tutorials below:"]},
{"url": "https://wiki.ros.org/turtlebot3_automatic_parking", "package": "turtlebot3_automatic_parking", "package_summary": ["Package for turtlebot3 automatic_parking. You need a reflective tape and real robots. You can see parking spot using this pacakge on rviz."], "package_details": []},
{"url": "https://wiki.ros.org/sr_ronex", "package": "sr_ronex", "package_summary": [], "package_details": ["For installation instructions, documentation and examples please refer to our", "If you have questions, would like to leave feedback or get support, visit the", "For more information please visit"]},
{"url": "https://wiki.ros.org/tuw_marker_detection", "package": "tuw_marker_detection", "package_summary": ["The tuw_marker_detection package"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_arm_ik_tests", "package": "pr2_arm_ik_tests", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/toposens_pointcloud", "package": "toposens_pointcloud", "package_summary": ["PCL integration for TS sensors mounted on Turtlebot3."], "package_details": ["This package enables conversion of messages of type", "into messages of type", ".", "Due to the specular reflection behavior of ultrasound, the surface normal of the detected object can be represented by a vector pointing from the detected point towards the sensor\u2019s position while the point was recorded. This normal vector is added to the", "representation. For a more detailed explanation of the physics behind Toposens sensors see", "."]},
{"url": "https://wiki.ros.org/nao_control", "package": "nao_control", "package_summary": [], "package_details": ["Is used within", "and", "packages"]},
{"url": "https://wiki.ros.org/ros3djs_experimental", "package": "ros3djs_experimental", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/warthog_msgs", "package": "warthog_msgs", "package_summary": ["Messages exclusive to Warthog, especially for representing low-level motor commands and sensors."], "package_details": ["These messages are the low-level interface between", "'s ARM MCU and integrated PC. Most users of Warthog should be able to use standard ROS interfaces (eg.", ",", ") to command and monitor the robot. Possible exceptions are:"]},
{"url": "https://wiki.ros.org/laser_pipeline", "package": "laser_pipeline", "package_summary": ["Meta-package of libraries for processing laser data, including converting laser data\n      into 3D representations."], "package_details": ["The", "stack is intended to do the necessary processing to get from the output of a scanning laser rangefinder to a more useful 3D representation of a point cloud.  This processing takes three distinct steps:", "For an end-user higher up the system, the", "is actually capable of performing all 3 of these steps, implementing an arbitrary filter chain on its input, performing a high-fidelity transformation to a point cloud internally, and then making clouds available via a", ".", "Point clouds generated using the laser pipeline results in a", "or (", ")", "message.  This point cloud can have the following channels attached to it:", "The", "assumes that you have a scanning laser rangefinger.  The most common examples of these are the Hokuyo UTM and the Sick LMS.  The", "stack provides drivers for these particular models.  However, any driver which outputs the", ", including", ", can be used as the input to this pipeline."]},
{"url": "https://wiki.ros.org/rostopic", "package": "rostopic", "package_summary": ["rostopic contains the rostopic command-line tool for displaying\n    debug information about\n    ROS", ", including\n    publishers, subscribers, publishing rate,\n    and ROS", ". It also\n    contains an experimental Python library for getting information about\n    and interacting with topics dynamically. This library is for\n    internal-use only as the code API may change, though it does provide\n    examples of how to implement dynamic subscription and publication\n    behaviors in ROS."], "package_details": [", like several other ROS tools, uses YAML-syntax at the command line for representing the contents of a message. For information on how to use this YAML syntax for commands like", ", please see the", "guide.", "is a stable command-line tool within the ROS core toolchain. The underlying code may undergo refactoring for easier library use, but the external API is expected to be fairly stable.", "The", "command-line tool displays information about ROS topics. Currently, it can display a list of active topics, the publishers and subscribers of a specific topic, the publishing rate of a topic, the bandwidth of a topic, and messages published to a topic. The display of messages is configurable to output in a plotting-friendly format.", "See also", ".", "or on Windows, replace single quotes with double quotes", "Publish a geometry_msgs/Twist message with a rate of 10Hz.", "One area in which", "is expected to see development is with the output format of", "and input format of", ". The planned feature is to make both compatible with YAML syntax, which will enable"]},
{"url": "https://wiki.ros.org/katana", "package": "katana", "package_summary": [], "package_details": ["This package provides the", "ROS node, which provides four sets of functionality at once: the", ", the", ", the", "and the", ". They are combined into one single node for technical reasons (only one single process can access the Katana), but documented separately below for clarity.", "Also there is a second node in this package, called", ", documented at the end."]},
{"url": "https://wiki.ros.org/turtlebot3_applications_msgs", "package": "turtlebot3_applications_msgs", "package_summary": ["Message and service types: custom messages and services for TurtleBot3 Applications packages"], "package_details": []},
{"url": "https://wiki.ros.org/rosh_core", "package": "rosh_core", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_delivery", "package": "pr2_delivery", "package_summary": [], "package_details": ["See:"]},
{"url": "https://wiki.ros.org/roslibjs", "package": "roslibjs", "package_summary": [], "package_details": ["This project is released on a CDN as part of the", "effort. Releases can be found", ". The files are also hosted on the jsdelivr cdn", "|", ".", "Source code is available at", ". Pull requests should be made to the", "branch. This project follows the", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/widowx_arm", "package": "widowx_arm", "package_summary": [], "package_details": ["This package contains the different controllers and description files for"]},
{"url": "https://wiki.ros.org/widowx_arm_description", "package": "widowx_arm_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/staubli_rx160_gazebo", "package": "staubli_rx160_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/summit_x_sim", "package": "summit_x_sim", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation.", "Control the robot joints in all kinematic configurations, publishes odom topic and, if configured, also tf odom to base_link. Usually takes as input joystick commands and generates as outputs references for the gazebo controllers defined in summit_xl_control. This package permits an alternative way to control the robot motion (4 motorwheels) that by default is carried on by the Gazebo plugin (skid-steer). In the default configuration this package only controls the pan-tilt camera joints. When used as main controller of the simulated robot, this node also computes the odometry of the robot using the joint movements and a IMU and publish this odometry to /odom. The node has a flag in the yaml files that forces the publication or not of the odom->base_footprint frames, needed by the localization and mapping algorithms."]},
{"url": "https://wiki.ros.org/srdf", "package": "srdf", "package_summary": [], "package_details": ["Proposer:", "This format is intended to represent information about the robot that is not in the URDF file, but it is useful for a variety of applications. The intention is to include information that has a semantic aspect to it.  A review of this format is available", "."]},
{"url": "https://wiki.ros.org/maggie_devices_msgs", "package": "maggie_devices_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_eyelids_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_eyelids_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_ir_controller_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_ir_controller_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_motor_controller_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_motor_controller_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_rfid_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_rfid_msgs/manifest.yaml", "This package defines", "-specific message and service types for the devices. Most users will not use these types directly, but rather through Maggie-specific visualizations and utilities."]},
{"url": "https://wiki.ros.org/moveit_pr2", "package": "moveit_pr2", "package_summary": ["All PR2-specific packages for MoveIt"], "package_details": []},
{"url": "https://wiki.ros.org/kdl_typekit", "package": "kdl_typekit", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rtt_rosnode", "package": "rtt_rosnode", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/svenzva_joy", "package": "svenzva_joy", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_moveit_config", "package": "pr2_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the pr2 with the MoveIt Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/ur_bringup", "package": "ur_bringup", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/pr2_navigation_self_filter", "package": "pr2_navigation_self_filter", "package_summary": ["Filters the robot's body out of point clouds."], "package_details": ["The pr2_navigation_self_filter package provides a node that filters hits on the robot's body out of", "messages and republishes them.", "Due to the fact that", "messages will soon be deprecated, the pr2_navigation_self_filter has no stable API. A new version of the node will be written and supported long term with the new PointCloud structure, but until the", "stack moves to support the new PointCloud's this package will remain in", ". Overall, you can use this package, but its at your own risk.", "The pr2_navigation_self_filter package has been moved to the robot_self_filter package as it is no longer PR2 specific. It is hosted at", ". This change will not fully go into affect until ROS Jade which the pr2_navigation_self_filter package will then be removed from the pr2_navigation metapackage. This means in Indigo, we will support both packages. In Hydro, there will be no relaese of robot_self_filter. Please see", "for discussion on the matter."]},
{"url": "https://wiki.ros.org/turtlebot_arm_kinect_calibration", "package": "turtlebot_arm_kinect_calibration", "package_summary": [], "package_details": ["Refer to the", "for instructions on how to calibrate a Kinect to the", "."]},
{"url": "https://wiki.ros.org/rosserial", "package": "rosserial", "package_summary": ["Metapackage for core of rosserial."], "package_details": ["is a", "for wrapping standard ROS serialized messages and multiplexing multiple topics and services over a character device such as a serial port or network socket.", "Client libraries allow users to easily get ROS nodes up and running on various systems. These clients are ports of the general ANSI C++", "library.  Currently, these packages include:", "Refer to", "for details on how to add a new hardware platform.", "Devices running", "code require a node on the host machine to bridge the connection from the serial protocol to the more general ROS network:", "The number of Publishers and Subscribers are limited at 25, and the size of serialization and deserialization buffers are limited at 512 bytes by default for", ".", "However, those numbers and sizes are too big for microcontroller with limited", ". The buffer sizes, and numbers of Publisher/Subscriber for", "now vary depending on the chip used:", "You can change these numbers and sizes, refer to tutorial", "for more informaiton.", "To conserve precious AVR memory, strings are not stored inside a message instance, instead an", "is stored. This has two impacts:", "Therefore, to send an array message, we have to set the length and pointer. When deserializing, we cannot deserialize in-place like the string (since the bytes of the message are actually packed, unlike a string which is passed in plain form). Therefore, the deserialization function will automatically allocate enough storage using", ", attempting to reuse the memory location whenever possible and only expanding it when the new message received is larger than the largest previous message.", "The", "protocol is aimed at point-to-point ROS communications over a serial transmission line. We use the same serialization/de-serialization as standard ROS messages, simply adding a packet header and tail which allows multiple topics to share a common serial link. This page describes the low-level details of the packet header and tail, and several special topics used for synchronization.", "The Protocol version byte was", "on ROS Groovy,", "on ROS Hydro, Indigo, and Jade.", "Topics ID 0-100 are reserved for system functions, as defined in the", "message.", "Report bugs, ask questions in the issues list on"]},
{"url": "https://wiki.ros.org/target_monitor", "package": "target_monitor", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The following packages of the", "are required:", "The following packages of the", "are required:", "to launch the", "node.", "In the", "subdirectory there are two parameter files", "and", "that allows to configure the behavior of the", "node. The", "contains the coordinates of the simulated targets. It is only used when the parameter", "is set to", ". They are given as two list parameters where the list index is the ID of the target.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/asr_lib_pose_prediction_ism", "package": "asr_lib_pose_prediction_ism", "package_summary": ["This package contains classes and algorithms to predict poses of searched objects by the help of a tree of ISMs. It is organized as a library and contains only a small program to evaluate the performance of different algorithms."], "package_details": ["#include <asr_msgs/AsrObject.h>", "#include <pose_prediction_ism/pose_predictor.h> #include <pose_prediction_ism/shortest_path.h>", "pose_prediction_ism::PosePredictor* pose_predictor;", "//use shortest path pose prediction. You can also use BestPath, RandomPath, PaperPredictionNormalized or PaperPredictionNonNormalized pose_predictor = new pose_prediction_ism::ShortestPath(db_filename);", "//enables the random functionallity to simulate some noise (in mm, deg) //pose_predictor_->enableRandom(random_position, random_orientation);", "//Buffer for already found objects in scene pose_prediction_ism::FoundObjects fos;", "//add all already found objects to buffer for(std::size_t i = 0; i < BUFFERED_OBJECTS.size(); i++) { asr_msgs::AsrObject asr_o; asr_o.type = BUFFERED_OBJECTS[i]->type; asr_o.identifier = BUFFERED_OBJECTS[i]->observedId; fos.push_back(asr_o); }", "//add buffter to predictor pose_predictor_->setFoundObjects(fos);", "//ISM::PosePtr of ISM reference ISM::PosePtr referencePosePtr = MY_REFERENCE;", "//name of pattern representing ISM std::string = \"MyPattern\";", "//call actually prediction here with parameters: pose_predictor_->predictUnfoundPoses(referencePosePtr, pattern_name, samplefactor);", "//get the resulting attributed point cloud (which contains the prediction-results as labed points) pose_prediction_ism::AttributedPointCloud current_point_cloud = pose_predictor_->getAttributedPointCloud();", "//disables the random functionallity //pose_predictor_->disableRandom();"]},
{"url": "https://wiki.ros.org/rosservice", "package": "rosservice", "package_summary": ["rosservice contains the rosservice command-line tool for listing\n    and querying ROS", ". It also\n    contains a Python library for retrieving information about\n    Services and dynamically invoking them. The Python library is\n    experimental and is for internal-use only."], "package_details": ["is a stable command-line tool within the ROS core toolchain. It's currently feature set is not expected expand much. Currently, the only major feature planned is the ability to use YAML text files as well as piped YAML input with the", "command. This feature is currently not scheduled.", "The", "tool provides information about", "files.", "The", "command implements a variety of commands that let you discover which services are currently online from which nodes and further drill down to get specific information about a service, such as its type, URI, and arguments. You can also call a service directly from the command line.", "Please see", "for a detailed description and examples of how to specify service arguments to", ".", "Please see", "for a detailed description and examples of how to call", "with negative-number arguments."]},
{"url": "https://wiki.ros.org/nextage_description", "package": "nextage_description", "package_summary": ["As a part of rtmros_nextage package that is a ROS interface for", "dual-armed robot from Kawada Robotics Inc, this package provides its 3D model that can be used in simulation and", "-based motion planning tasks."], "package_details": []},
{"url": "https://wiki.ros.org/turtle_actionlib", "package": "turtle_actionlib", "package_summary": ["turtle_actionlib demonstrates how to write an action server and client with the turtlesim. The shape_server provides and action interface for drawing regular polygons with the turtlesim."], "package_details": ["This tutorial package provides a", "and example", "for drawing regular polygons with the", ". The default client will draw a pentagon in", ".", "The", "is defined below:", "Then in separate terminals", "the following nodes:"]},
{"url": "https://wiki.ros.org/wheeled_robin_teleop", "package": "wheeled_robin_teleop", "package_summary": [], "package_details": ["This package contains a launch file for the", "node in", "to teleoperate a robot with a Thrustmaster T-Wireless gamepad. The launch file also includes the", "file. A", "node from", "is also loaded."]},
{"url": "https://wiki.ros.org/m4atx_battery_monitor", "package": "m4atx_battery_monitor", "package_summary": [], "package_details": ["The", "package will read the information from a m4atx battery supply and publish it as a ros message.", "Locate the bus and device number of the device called \"", "Technology, Inc.\".", "To install the", "package, you can choose to either install from source, or from the Ubuntu package:", "The", "package contains a", "file. This file launches an instance of the", ". To launch these nodes the following command can be used:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/constrained_ik", "package": "constrained_ik", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_navigation", "package": "turtlebot_navigation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/schunk_grippers", "package": "schunk_grippers", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This stack contains packages to control EZN64 and PG70 Schunk grippers from ROS. It is a basic implementation of Schunk Motion protocol in combination with", "and", "library, which allows user to interface grippers through standard ROS services. Xacro models of EZN64 and PG70 grippers are included as well.", "Schunk EZN64 (libusb1.0 implementation) -", "Schunk  PG70  (serial implementation)                  -"]},
{"url": "https://wiki.ros.org/ur3_moveit_config", "package": "ur3_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the ur3 with the MoveIt Motion Planning Framework"], "package_details": ["This package is part of the", "program. It is the", "! configuration for the UR3 arm, generated automatically by the", "Setup Assistant.", "Install the package from package management, and run the MoveIt! planning demo:", "This is not a real simulation, just a demonstration of the planning capability and the MoveIt! and RViz integration. For true simulation of a UR3, see the", "package.", "See also the relevant sections in the", "on Github."]},
{"url": "https://wiki.ros.org/roscpp_traits", "package": "roscpp_traits", "package_summary": ["roscpp_traits contains the message traits code as described in", ".\n\n    This package is a component of", "."], "package_details": ["Please see", ".", "roscpp_traits is an internal library used in", "and should not be used directly."]},
{"url": "https://wiki.ros.org/waypoint_touring", "package": "waypoint_touring", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/python_ethernet_rmp", "package": "python_ethernet_rmp", "package_summary": [], "package_details": ["The", "package contains the drivers for interfacing to a Segway RMP via an Ethernet connection.", "To install the", "package, you can choose to either install from source, or from the Ubuntu package:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/staubli_tx90_gazebo", "package": "staubli_tx90_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_ros_benchmarks_gui", "package": "moveit_ros_benchmarks_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roscpp_serialization", "package": "roscpp_serialization", "package_summary": ["roscpp_serialization contains the code for serialization as described in", ".\n\n    This package is a component of", "."], "package_details": ["Please see", ".", "roscpp_serialization provides the", "API used in", "and should not be used directly."]},
{"url": "https://wiki.ros.org/sr_gui_motor_resetter", "package": "sr_gui_motor_resetter", "package_summary": ["A GUI plugin for resetting motors on the shadow hand."], "package_details": []},
{"url": "https://wiki.ros.org/wheeled_robin_core_apps", "package": "wheeled_robin_core_apps", "package_summary": [], "package_details": ["This package contains various robot apps (rapps) that can be used by WheeledRobin or any", "compatible robot. Rapps are used by the appmanager started by 'minimal_with_appmanager' or 'bringup.concert' in", "package.", "Control the", "with a Thrustmaster Joystick. Rapp Platform: linux.ros.turtlebot"]},
{"url": "https://wiki.ros.org/tra1_bringup", "package": "tra1_bringup", "package_summary": ["Package contains bringup scripts/config/tools for tra1 robto"], "package_details": ["Now you can see", "! rviz interface to control the robot."]},
{"url": "https://wiki.ros.org/pr2_navigation_config", "package": "pr2_navigation_config", "package_summary": ["This package holds common configuration files for running the"], "package_details": ["This package holds a number of common configuration files for the", "node on the PR2 robot. In particular, it holds parameter settings for the", ",", ", and", "components of the", "node that are shared between many different configurations of the", "stack run on the PR2."]},
{"url": "https://wiki.ros.org/turtlebot3_simulations", "package": "turtlebot3_simulations", "package_summary": ["ROS packages for the turtlebot3 simulation (meta package)"], "package_details": ["is a new generation mobile robot that is modular, compact and customizable. Let\u2019s explore ROS and create exciting applications for education, research and product development. The goal of", "is to drastically reduce the size and lower the price of the platform without sacrificing capability, functionality, and quality. Optional parts such as chassis, computers and sensors are available, and", "can be customized in various ways.", "is willing to be in the center of the maker movement by applying the latest technical advances of the SBC(Single Board Computer), the Depth sensor and 3D printing technology."]},
{"url": "https://wiki.ros.org/pr2_mechanism_model", "package": "pr2_mechanism_model", "package_summary": [], "package_details": ["is the main class in this package.  When a controller gets initialized, the", "passes the controller a pointer to the", "(see the", "). The robot state describes both the kinematic/dynamic model of the robot and the current state of the robot. The state of the robot is defined by the position/velocity/effort of the joints in the robot. The model of the robot is a", "object, as defined in the", ". Additionally, the", "provides access to the 'controller time', the time at which a controller cycle is started. To see an example on how to use the", ", check out the", ".", "The", "package contains the", "C++ class, which is an interface to the robot joints and a description of the robot model. The", "gives easy access to individual joints. To work with a kinematic chain that contains multiple joints,", "contains a", "tool that represents a full kinematic chain and interfaces with the", ".", "The", "provides access by name to all the", "s it contains. To get access to a", ", use the following method:", "From a", "you can extract joint position, effort, velocity, and command the desired joint effort:", "To get e.g. the measured joint position from the", ", use:", "or, to set the commanded effort on", ", use:", "The", "give more examples on how to use the", ".", "The", "also gives access to the joint model, which contains things like the joint type, axis, reference position, etc. To e.g. get the joint type, use:", "The", "API documentation provides all details.", "For reference documentation, check out the", ". From a", "you can read the measured position, measured velocity and measured effort effort, and write the commanded effort.", "Class member", "The", "also provides access to the transmissions between the motors and the joints. Typically you should not need the transmissions, unless you are using some advanced dynamic model, or you are calibrating the joints. To get access to a", ", use the following method:", "See the", "for more details.", "For details on the transmission description format, check out the", "page.", "Every time a controller cycle is started, the", "records the time. This time can be accessed by all controllers through the", ". When a controller e.g. needs to compute the duration between two consecutive update loops, it should", ". In contrast to the system time, the controller time is not affected by the time other controllers consume in their update loop. Moreover, the controller time is the best measure of when the communication with the hardware actually occurs. To get access to the controller time, use:", "The", "contains a", "robot description object. There is lots of", "on the urdf model, and there are even a number of", "you could look at. To get access to the urdf model use:", "The", "class provides an easy way to work with a kinematic chain that consists of multiple joints. Instead of finding all the joints by iterating through the", ", the", "will pull out all the joints between a given root and tip link:", "From a", "you can get the positions/velocities/efforts of all the joints, and set the efforts of all joints:", "From a chain you can also extract a", ":", "See the", "for more details.", "The", "is used when writing a realtime controller. For example code on how to use the", "and the", "classes, check out", ". To see an example on how to use the", "object for Cartesian control, check out", "."]},
{"url": "https://wiki.ros.org/rc_visard_driver", "package": "rc_visard_driver", "package_summary": ["The rc_visard_driver provides data from a Roboception rc_visard 3D sensor on several ROS topics."], "package_details": ["Use GitHub to", ". [", "]", "Official ROS driver for", "rc_visard 3D sensor.", "See", "and", "for more details.", "The", "is the world\u2019s first 3D sensor that allows robots to perceive their environment in 3D and localize themselves in space.", "The", "is the official ROS driver for the", "which provides ROS parameters (configuration), ROS services (control of rc_visards dynamic module) and ROS topics (sensor data: Images, Stereo Data, Point Clouds, Dynamic State i.e. poses and IMU data, TF).", "The proprietary", "messages are sent for every image and contain information like the exposure time, gain and values of digital inputs and outputs at the time of image capture.", "If the connected rc_visard has an", "license, then the following", "topics are additionally provided for images where the GPIO out1 is either low", "or high. These topics only useful if", "is set to the special mode", ".", "For color sensors with an", "license, the following topics are", "additionally available:", "If the parameter", "is set to true, the node subscribes to the", "rc_visard's pose stream (same data published on", "topic) and publishes them on tf.", "The following service is offered to trigger stereo matching in", "mode.", "It returns an error if the", "is", ".", "The trajectory constructed and stored by the", "node", "can be retrieved by", "The onboard map of the", "node can be saved on the rc_visard for loading it", "after a SLAM restart or power cycle:", "The onboard", "node can be \"reset\" (clears the internal state of the SLAM component,", "including the trajectory) to free the memory with", "The rc_visard_driver uses the", "class from the", "to regularly publish a", ".", "The regular publishing rate can be set via the", "parameter and defaults to 1 second.", "The published status values are", ",", ",", ", and", ".", "If not", ", additionally the current", "and", "are published."]},
{"url": "https://wiki.ros.org/test_nodelet", "package": "test_nodelet", "package_summary": ["A package for nodelet unit tests"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_follow_filter", "package": "turtlebot3_follow_filter", "package_summary": ["turtlebot3_follow_filter package using laser_filters for turtlebot3_follower package"], "package_details": ["This package provides parameters from", "in", "directory."]},
{"url": "https://wiki.ros.org/rosh_common", "package": "rosh_common", "package_summary": [], "package_details": ["provides an index of all", "actions in a running ROS graph. The API is currently very simple right now and only supports display action goal arguments and synchronous invocation.", "provides an index of cameras that support the general ROS camera interface, which is commonly used in", ". With the", "object, you can easily inspect which cameras are available, retrieve their camera info, and show camera images."]},
{"url": "https://wiki.ros.org/sr_gui_joint_slider", "package": "sr_gui_joint_slider", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_hardware_interface", "package": "pr2_hardware_interface", "package_summary": ["This package contains the C++ interfaces to the PR2 hardware\n  components that are controlled over EtherCAT. This includes the\n  motors and encoders needed to control the PR2 mechanism, as well as\n  components like the pressure sensors in the fingertips, camera\n  triggers, etc... All of the hardware components in this interface are\n  directly available to the controllers inside the hard realtime\n  control loop."], "package_details": ["The PR2 hardware interface provides a C++ abstraction layer for the PR2 hardware that is controlled over the", "that runs through the robot. Most users should not have to deal directly with this interface. If you are only interested in controlling the robot joints, you should directly interact with", ". Only very advanced users that need direct access to the hardware should be using the PR2 hardware interface."]},
{"url": "https://wiki.ros.org/staubli_experimental", "package": "staubli_experimental", "package_summary": ["Experimental packages for Staubli manipulators within ROS-Industrial (metapackage)."], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program. It contains experimental packages that will be moved to the", "package once they've received sufficient testing and review.", "Due to the experimental nature of these packages, they have not been released and are not part of any ROS distribution. In order to use this stack, it has to be checked out into a catkin workspace and has to be build manually. Refer to the", "for more information.", "See the", "page for more information.", "For questions related to the Staubli support or ROS-Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/jog_msgs", "package": "jog_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_autorace", "package": "turtlebot3_autorace", "package_summary": ["AutoRace ROS packages for AutoRace with TurtleBot3 (meta package)"], "package_details": ["is a new generation mobile robot that is modular, compact and customizable. Let\u2019s explore ROS and create exciting applications for education, research and product development. The goal of", "is to drastically reduce the size and lower the price of the platform without sacrificing capability, functionality, and quality. Optional parts such as chassis, computers and sensors are available, and", "can be customized in various ways.", "is willing to be in the center of the maker movement by applying the latest technical advances of the SBC(Single Board Computer), the Depth sensor and 3D printing technology."]},
{"url": "https://wiki.ros.org/turtlebot_teleop", "package": "turtlebot_teleop", "package_summary": [], "package_details": ["The", "package provides launch files for teleoperation with different input devices."]},
{"url": "https://wiki.ros.org/allocators", "package": "allocators", "package_summary": ["Contains aligned allocation functions, as well as an STL-compatible AlignedAllocator class."], "package_details": ["General aligned allocation is done through the", "and", "functions.  For example:"]},
{"url": "https://wiki.ros.org/pr2_mechanism", "package": "pr2_mechanism", "package_summary": ["The pr2_mechanism stack contains the infrastructure to control the PR2 robot in a hard realtime control loop."], "package_details": ["The", "stack contains useful libraries if you want to write a realtime controller to interact with the PR2 (or similar) robot. These libraries are contained in the following ROS packages:", "Report new issues on"]},
{"url": "https://wiki.ros.org/turtlebot_capabilities", "package": "turtlebot_capabilities", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sync_params", "package": "sync_params", "package_summary": [], "package_details": ["provides a means to synchronize parameter servers between multiple ROS masters. The parameter server is polled, and new parameters are published as a topic. The topic is then synchronized across masters using", ". The topic is received and written to the parameter server on the other ROS master.", "By default, all parameters will be synchronized. The", "excludes parameters based on their name. The", "parameters are exempt from the", ". These can both be regular expressions. For example:", "Would only synchronize", ".", "The parameter", "is designed for spawning robots in Gazebo. Gazebo pauses the ROS clock when loading a robot, and waits for the", "parameter. But that parameter might not get synchronized if", "uses the ROS clock.", "Examples can be found in the", "."]},
{"url": "https://wiki.ros.org/ros3djs", "package": "ros3djs", "package_summary": [], "package_details": ["This project is released on a CDN as part of the", "effort. The following is a list of the available revisions:", "Source code is available at", ". Pull requests should be made to the", "branch. This project follows the", ".", "Live demos are available on the", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/swarm_functions", "package": "swarm_functions", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "The swarm functions library provides simple functionalities that enable swarm algorithms to work. It is part of the", ".", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/ncd_parser", "package": "ncd_parser", "package_summary": ["The ncd_parser package reads in .alog data files from the New College Dataset and broadcasts scan and odometry messages to ROS."], "package_details": ["used with the permission of Dr. Paul Newman, Oxford University.", "The", "package reads in .alog data files from the New College Dataset and broadcasts the data in ROS. The messages are broadcast in real time. Currently, the data extracted includes the odometry of the robot and the readings from the left and right SICK laser scanners. Additional transforms are provided between the odometric frame and the two lasers, as described in the NCD paper.", "To use the", ", you need to obtain an .alog file from the New College Dataset", ".", "You can run the", "on a small .alog file included in the package for demo purposes. First, make sure you have the", "stack downloaded and installed by following the instructions", ".", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/librms", "package": "librms", "package_summary": [], "package_details": ["To install the", "stack, you can choose to either install from source, or from the Ubuntu package:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/tf_tools", "package": "tf_tools", "package_summary": [], "package_details": ["tf_logger will record the changes of frames published through", "each with respect to a given reference frame.", "E.g. if you want to log both the transforms /world -> /odom and /odom -> /base_link at a frequency of 5 Hz, run"]},
{"url": "https://wiki.ros.org/ur_kinematics", "package": "ur_kinematics", "package_summary": ["Provides forward and inverse kinematics for Universal Robots designs.\n     See http://hdl.handle.net/1853/50782 for details."], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/sr_robot_lib", "package": "sr_robot_lib", "package_summary": ["sr_robot_lib contains the robot library used in the sr_edc_ethercat_drivers. The\n    library is used to store the incoming etherCAT messages in an easy to access format,\n    and prepare the messages to be send through etherCAT."], "package_details": ["This package also contains a class which builds the etherCAT command we want to send to the hand, based on the configuration file", ", the data is updated at different rates.", "The", "folder contains most of the configuration for the hand driver (except the controller configuration):"]},
{"url": "https://wiki.ros.org/rc_hand_eye_calibration_client", "package": "rc_hand_eye_calibration_client", "package_summary": ["The rc_hand_eye_calibration_client package"], "package_details": ["Use GitHub to", ". [", "]", "See", "and", "for more details.", "The default behavior is to request the existing calibration of the rc_visard once on startup, broadcast it (latched) on", "and only broadcast again if the advertised ROS services", "or", "are called.", "After the calibration transform is calculated and tested, it should be saved to the rc_visard (", ").", "For detailed instructions on the calibration routine consult the rc_visard manual:", "."]},
{"url": "https://wiki.ros.org/laser_scan_matcher", "package": "laser_scan_matcher", "package_summary": [], "package_details": ["(", ", default:", ")", "(", ", default:", ")", "(", ", default:", ")", "(", ", default: 0.10)", "(", ", default:", ")", "(", ", default: 10)", "(", ", default: 0.010)", "The", "package is an incremental laser scan registration tool.  The package allows to scan match between consecutive", "messages, and publish the estimated position of the laser as a", "or a", "transform.", "The", "can operate using", "messages or", "messages. When using", ", make sure they have no", "values.", "While the", "can operate by just using scan data, we can speed up the scan registration process by providing a guess for the current position of the sensor every time a new scan message arrives. When no guess is available, a reasonable (and widely-used) assumption is that the sensor didn't move (zero-velocity model). Below is a list of inputs that", "accepts:", "We can use combinations of the above such as IMU together with wheel odometry or IMU together with alpha beta tracking. When several prediction modes are enabled, the priority is IMU > Odometry > Constant Velocity > Zero Velocity.", "Setting the tolerance for updating the keyframe can be achieved via the", "and", "parameters. Their default values give a more robust performance, both while standing still and moving.", "You can run the", "on a pre-recorded bag file that comes with the package. First, make sure you have the", "stack downloaded and installed by following the", ".", "Two drivers are available:", "and", ". Their parameters and topics are identical.", "Parameters when using", "instead of", "messages.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/summit_xl_description", "package": "summit_xl_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot", "package": "turtlebot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/acc_finder", "package": "acc_finder", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/quadrotor_handler", "package": "quadrotor_handler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_type_introspection", "package": "ros_type_introspection", "package_summary": ["The ros_type_introspection package allows the user to parse and deserialize\n  ROS messages which type is unknown at compilation time."], "package_details": ["The ROS Message Types can be described as a", ". This approach is very well known and commonly used on the web and in distributed systems in general.", "A", "is defined by the user; an \"IDL compiler\", i.e.", ", reads this schema and generates a header file that contains the source code that the user shall include in his/her applications. The inclusion of this header file is needed on both the publisher", "the subscriber sides.", "The only \"problem\" is that in very few use cases (for instance if you want to build a plugin to", ") you don't know in advance which ROS Messages you will need to read. Therefore, you won't be able to include the necessary header files.", "1.", ": a type used to subscribe to any topic, regardless of the original type.", "2.", ": the generic type commonly used to read data from a ROS bag.", "Please refer to", "."]},
{"url": "https://wiki.ros.org/batteries_skill_msgs", "package": "batteries_skill_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"batteries_skill_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/batteries_skill_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/launch_tools", "package": "launch_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/wsg_32_description", "package": "wsg_32_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/spur", "package": "spur", "package_summary": [], "package_details": ["Document is available in", "."]},
{"url": "https://wiki.ros.org/visp_camera_calibration", "package": "visp_camera_calibration", "package_summary": ["visp_camera_calibration allows easy calibration of\n     cameras using a customizable pattern and ViSP library."], "package_details": ["is part of", "stack.", "visp_camera_calibration is a ROS package that allows a highly customisable camera calibration using calibration tools from the ViSP library avalaible from", ".", "The image feed used for calibration is a set of clearly distinguishible points. The planar disposition of the points is of no importance.", "This package uses ViSP's camera model described in", "and camera calibration capabilities described in", ". The output camera parameters are given in the", "format.", "visp_camera_calibration will work with any camera driver node satisfying the standard ROS camera interface. See the", "."]},
{"url": "https://wiki.ros.org/multirobot_map_merge", "package": "multirobot_map_merge", "package_summary": ["Merging multiple maps without knowledge of initial\n  positions of robots."], "package_details": ["Use GitHub to", ". [", "]", "does not depend on any particular communication between robots.", "finds robot maps dynamically and new robots can be added to system at any time.", "This package provides global map for multiple robots. It can merge maps from arbitrary number of robots. It expects maps from individual robots as ROS topics. If your run multiple robots under the same ROS master then", "will probably work for you out-of-the-box. It is also very easy to setup an simulation experiment.", "To make this dynamic behaviour possible there are some constrains placed on robots. First all robots must publish map under", ", where topic name (", ") is configurable, but must be same for all robots. For each robot", "will be of cause different.", "Two merging modes are currently supported as orthogonal options. If you know initial positions of robots you may preferably use the first mode and get exact results (rigid transformation will be computed according to initial positions). If you don't know robot's starting points you are still able to use the second mode where transformation between grids will be determined using heuristic algorithm. You can choose between these two modes using the", "parameter.", "This is preferred mode whenever you are able to determine exact starting point for each robot. You need to provide initial position for each robot. You need to provide set of", "parameters. These positions should be in", ". See", ".", "Estimating transforms between grids is cpu-intesive so you might want to tune", "parameter to run re-estimation less often if it causes any troubles.", "This package was developed as part of my bachelor thesis at", "in Prague.", "Idea for dynamic robot discovery is from", "package from Zhi Yan. Merging algorithm and configuration are different."]},
{"url": "https://wiki.ros.org/network_control_tests", "package": "network_control_tests", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_interactions", "package": "turtlebot_interactions", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/wifi_drivers", "package": "wifi_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/toposens_driver", "package": "toposens_driver", "package_summary": ["ROS device driver for communication with TS sensors."], "package_details": ["This package functions as a device driver for a Toposens 3D ultrasonic sensor. It can be used to setup a serial connection to the sensor, parse the received data string and publish it as a", ".", "Most of the parameters are used by the sensors firmware and are therefore sent to the sensor via the serial port. For a more detailed description of these parameters see", "."]},
{"url": "https://wiki.ros.org/tra1_moveit_config", "package": "tra1_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the tra1 with the MoveIt! Motion Planning Framework"], "package_details": ["To try", "! with this package, type below command:", "You can see the", "rviz screen and make it move with GUI."]},
{"url": "https://wiki.ros.org/wire_msgs", "package": "wire_msgs", "package_summary": [], "package_details": ["contains all message types used in the", "stack.", "Newly proposed, mistyped, or obsolete package. Could not find package \"wire_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/wire_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/rgbd_depth_correction", "package": "rgbd_depth_correction", "package_summary": [], "package_details": ["The", "package provides a tool for calculating and correcting the depth error (distortion and bias) of a RGBD camera.  This is done by placing a calibration target on a flat surface, then comparing the sensor depth data to the position found using the calibration target.", "As was found by Daniel Herrera C., Juho Kannala, and Janne Heikkila, (", "), RGBD cameras have not only depth error that is radial, but is depth dependent.  In order to correct for this depth error, a series of images must be taken of a calibration target on a flat surface.  This package provides a method for calibrating and correction this depth error."]},
{"url": "https://wiki.ros.org/roswiki_node", "package": "roswiki_node", "package_summary": [], "package_details": ["Using the source code of your packages, this package applies a set of regular expressions and parses out the basic node information, particularly the type of information used by the", "template, (", ").", "Are you a regular expression whiz? Tickets and patches are welcome for adding new patterns.", "or contact"]},
{"url": "https://wiki.ros.org/turtlebot_apps", "package": "turtlebot_apps", "package_summary": [], "package_details": ["This stack is a supporting stack for the", "providing example applications."]},
{"url": "https://wiki.ros.org/pr2_navigation_perception", "package": "pr2_navigation_perception", "package_summary": ["This package holds navigation-specific sensor configuration options and launch files for the PR2."], "package_details": []},
{"url": "https://wiki.ros.org/rosh_desktop", "package": "rosh_desktop", "package_summary": [], "package_details": ["rosh_desktop is a meta-plugin that makes it easy to automatically load all desktop-related", "plugins.  See the", "documentation on how to automatically load rosh_desktop when you start rosh.", "Please see the", "documentation to find out more about rosh."]},
{"url": "https://wiki.ros.org/rail_recognition", "package": "rail_recognition", "package_summary": [], "package_details": ["The", "package contains nodes for object recognition and demonstration grasp selection using models from a grasp database, handled by", ".  The package also contains a node used for generating object models from grasp demonstrations collected with the", "package.  The recognizer has support for a 2D image recognizer to run first in the full recognition pipeline, significantly increasing the runtime of the point cloud recognizer by limiting the number of candidate classes to test with point cloud registration.  This package also contains nodes for data collection, training, and testing of the 2D recognizer.", "The full recognition pipeline takes in a list of unrecognized segmented objects, such as what the", "package provides.  Each unrecognized object will first be classified by the 2D image classifier to determine a set of candidate object classes of high probability.  These candidate classes will then be retrieved from the object model database, handled by", ", which are then used by the point cloud recognizer to provide a final object label and set of example grasps for picking up the now-recognized object.", "The 2D image recognizer can be trained in a few steps.  First, an image set representative of the objects in the environment must be collected.  This can be accomplished by running a segmentation node, such as the one found in", ", and the collect_images node as follows:", "See the tutorials section of", "for details on how to set up an object model database, provide grasp demonstrations, train new object models, and refine existing object models.", "To install the", "package, you can install from source with the following commands:", "The", "package contains a launch file for launching the object_recognition_listener node with the various database, segmentation, and recognition parameters set, executed with:", "Model generation can be run with an rviz plugin for visualization found in", "."]},
{"url": "https://wiki.ros.org/swarm_behaviors", "package": "swarm_behaviors", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "The swarm behaviors library contains implementations of swarm algorithms. It is part of the", ".", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/summit_xl_pad", "package": "summit_xl_pad", "package_summary": [], "package_details": ["This package contains the node that subscribes to /joy messages and publishes command messages for the robot platform including speed level control. The joystick output is feed to a mux (", ") so that the final command to the robot can be set by different components (move_base, etc.)"]},
{"url": "https://wiki.ros.org/topological_tools", "package": "topological_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_description", "package": "turtlebot_description", "package_summary": [], "package_details": ["This package contains robot description files for", ", organized into subdirectories as follows:"]},
{"url": "https://wiki.ros.org/asr_ivt", "package": "asr_ivt", "package_summary": ["Ros wrapper for the Integrated Vision Toolkit (IVT) library (version 1.3.22)"], "package_details": ["This package contains a ROS-wrapper for the", "library (version 1.3.22)."]},
{"url": "https://wiki.ros.org/visualization_osg", "package": "visualization_osg", "package_summary": ["visualization_osg is a metapackage providing support for visualization of geometry using the OpenSceneGraph rendering engine."], "package_details": []},
{"url": "https://wiki.ros.org/teraranger_array_converter", "package": "teraranger_array_converter", "package_summary": [], "package_details": [": This package depends on URDF description of the sensor setup. Please use the", "package for this disponible here:"]},
{"url": "https://wiki.ros.org/web_interface", "package": "web_interface", "package_summary": [], "package_details": ["(where", "is the name of computer 1 on your robot)", "If you want to install the web interface on a new computer or non-PR2 robot, there are experimental instructions on the", "page."]},
{"url": "https://wiki.ros.org/asr_flir_ptu_controller", "package": "asr_flir_ptu_controller", "package_summary": ["asr_flir_ptu_controller is a package to control a flir ptu unit from a action server"], "package_details": ["The asr_flir_ptu_controller is closely connected to the", "as it grants access to the PTU just as the mentioned package. The difference between both packages is that asr_flir_ptu_controller uses", "to make the PTU accessible for actionservers by offering an action client that takes new position commands for the pan and tilt values of the pan and executes them with the help of", ". The package supports the taking of new position goals, constant feedback of the movement and a check if the movement ended successfully. Not fulfillabe goals get filtered out from the beginning - they get rejected.", "The asr_flir_ptu_controller serves a single purpose: It makes the movement of a Flir pan-tilt-unit accessable by a", ". The functionality by asr_flir_ptu_controller will be shown below in a sequence diagram. For knowledge of the invoked functions check out", ".", "Basic knowledge of the PTU movement (e.g. orientation of axis, movement area, etc.) can be obtained from the documentation of asr_flir_ptu_driver. A lot of functionalities, especially the configuration of forbidden areas, are only available in the asr_flir_ptu_driver and cannot be accessed from here. asr_flir_ptu_controller extends the basic functionalities of movement and forbidden area checking by wrapping them them inside an Action offered by an ActionServer, making invocations easy and offering the opportunity to use the ActionServer in context of a more complex control logic. However, the controller restricts the opportunities of the asr_flir_ptu_driver somehow as it forces the check for forbidden areas and does not allow path_prediction.", "Being mounted upon the", "it is necessary that you have a running instance of asr_flir_ptu_driver, so start it", ".", "After starting the asr_flir_ptu_driver, start the asr_flir_ptu_controller. Interaction is then done over the", "launched by asr_flir_ptu_controller.", "As the", "has no simulation mode itself, launching it real is the only option you have. Little to no configuration needs to be done before launch if you did not change the topic names used by asr_flir_ptu_driver. Otherwise you need to adjust the corrsponding topic names found in the ptu_controller_settings.yaml file in the param folder. Most of the values there should be fine, nevertheless two should be reconsidered:", "and", "The first one describes the maximum amount of steps that will be done before a movement is considered a failure. A step means hereby a spin of ROS (to be totally fair, it means a publishing from the asr_flir_ptu_driver about his current position, what happens each spin). The second one describes the margin parameter known from asr_flir_ptu_driver. You can set this parameter freely, it is limited by the minimum of the width/height of the pan/tilt movement area divided by 2.", "From that point on you can use the ActionServer offered by asr_flir_ptu_controller.", "All topics below are subscribed by the ActionServer of asr_flir_ptu_controller by default. They use a custom defined message which can be found inside the action folder of the package.", "All published topics by the asr_flir_ptu_controller are related to the ActionServer and should not be invoked from the command line. Use an ActionClient or some tool design for interacting with ActionServers. Most of them are based on a custom ActionServer message that can be found inside the action folder of the package.", "Nevertheless there exists a very long code example on how to use the Goal/....-callbacks offered by the asr_flir_ptu_controller. Move to the src folder of the package and have a look at the PTUControllerClient.cpp. It is a piece of code that was used to test the behaviour of the ActionServer provided during development and remained here as an example for the usage. Be aware that some of the expected reactions of this program depend on the configuration of the", "and the PTU you are using - executing it without adapting it to your data is not recommended. Just use it as an example for usage.", "If you do not know how to use a ActionServer check out the", "."]},
{"url": "https://wiki.ros.org/scan_tools", "package": "scan_tools", "package_summary": ["Laser scan processing tools."], "package_details": ["This stack contains tools for manipulating", "and", "messages.", "See", "on the development repository.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/cpp_common", "package": "cpp_common", "package_summary": ["cpp_common contains C++ code for doing things that are not necessarily ROS\n    related, but are useful for multiple packages. This includes things like\n    the ROS_DEPRECATED and ROS_FORCE_INLINE macros, as well as code for getting\n    backtraces.\n\n    This package is a component of", "."], "package_details": []},
{"url": "https://wiki.ros.org/teb_local_planner_tutorials", "package": "teb_local_planner_tutorials", "package_summary": ["The teb_local_planner_tutorials package"], "package_details": ["This package contains supplementary material and examples for the", "package.", "Refer to the", "wiki page for more information and the", "section."]},
{"url": "https://wiki.ros.org/sr_gui_muscle_driver_bootloader", "package": "sr_gui_muscle_driver_bootloader", "package_summary": ["A GUI plugin for bootloading the muscle drivers on the etherCAT muscle shadow hand."], "package_details": ["This is similar to", "but is used for the version of the hand that employs air pressure actuated muscles instead of electric motors. Select one or more muscle driver(s) and a hex file and the click Bootload Motors."]},
{"url": "https://wiki.ros.org/staubli_rx160_support", "package": "staubli_rx160_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_tactile_sensors", "package": "sr_tactile_sensors", "package_summary": ["An interface to the tactile sensors used in the Shadow Dextrous Hand. Also Contains a virtual set of\n        sensors."], "package_details": ["To ensure the same versatile use as the", "package, the sr_tactile_sensors come in three flavours: dummy sensors, simulated sensors and real sensors.", "There's a good example on how to use the data coming from the tactile sensors in the", "When you start the interface, two topics per sensors will be published (10 topics in all). Each sensor publishes a pressure value. Each of the topic is publishing a", "/float64 value.", "By default, when you run", ", the tactiles are compiled as a set of dummy sensors.", "To compile the interface to the real tactile sensors, run:", ".", "If you want to compile the Gazebo tactile sensors:", "."]},
{"url": "https://wiki.ros.org/tf2_ros", "package": "tf2_ros", "package_summary": ["This package contains the ROS bindings for the tf2 library, for both Python and C++."], "package_details": ["is designed both as a command-line tool for manual use, as well as for use within", "files for setting static transforms. For example:", "Please refer to the", "or", "Please refer to the", "or", "For most purposes using tf2_ros will be done using", ". It's main public API is defined by", ". Typically it will be populated using a", "which subscribes to the appropriate topics.", "Please refer to the", "or", "Please refer to the", "or", "For more information see", "or"]},
{"url": "https://wiki.ros.org/ros2djs", "package": "ros2djs", "package_summary": [], "package_details": ["This project is released on a CDN as part of the", "effort. The following is a list of the available revisions:", "Source code is available at", ". Pull requests should be made to the", "branch. This project follows the", ".", "Live demos are available on the", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/plot_tools", "package": "plot_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/stdr_resources", "package": "stdr_resources", "package_summary": [], "package_details": ["package is the container for the resources needed by", "to operate. The resources are divided in two main groups:", "and", ".", "In the maps section six indicative maps are provided. Note that each", "is actually a pair of files:", "In this section the files under the", "folder are described. These are Yaml or XML files that describe robots and sensors. The available folders, each holding some sample resource files, are:", "For more information about the use of resource files please visit", "or the following tutorial :"]},
{"url": "https://wiki.ros.org/jsk_hark_msgs", "package": "jsk_hark_msgs", "package_summary": ["jsk_hark_msgs"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_surrogate", "package": "pr2_surrogate", "package_summary": [], "package_details": ["The button assignment is similar to one used for the PS3 joystick in", "."]},
{"url": "https://wiki.ros.org/warthog_simulator", "package": "warthog_simulator", "package_summary": ["Packages for simulating Warthog"], "package_details": ["To work with simulated Warthog on your own machine, make sure if have", "set up, and install the metapackages for desktop and simulation:", "Please see", "and", "."]},
{"url": "https://wiki.ros.org/stepback_and_steerturn_recovery", "package": "stepback_and_steerturn_recovery", "package_summary": [], "package_details": ["(", ", default: false)", "The", "is designed for a robot with a car-like steering mechanism. It adheres to the", "interface found in the", "package and can be used as a recovery behavior", "for the", "node.", "The C++", "class adheres to the", "interface found in the", "package. For detailed documentation, please see", "."]},
{"url": "https://wiki.ros.org/world_canvas_utils", "package": "world_canvas_utils", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/octomap_rviz_plugins", "package": "octomap_rviz_plugins", "package_summary": ["A set of plugins for displaying occupancy information decoded from binary octomap messages."], "package_details": []},
{"url": "https://wiki.ros.org/laser_ortho_projector", "package": "laser_ortho_projector", "package_summary": ["The laser_ortho_projector package calculates orthogonal projections of LaserScan messages."], "package_details": ["The package is intended as an intermediary step to transform laser data, before passing it to another node that performs scan-matching (for example,", "or", "). It works under the assumption that the environment is rectilinear in the z-dimension, meaning that obstacles look the same, regardless of the height where they are observed. This assumption typically holds for indoor spaces.", "We also calculate a transformation between the world frame and a orthogonally-projected base frame of the robot (labeled", "in the figure above), and publish it as a", "transform.", "Note that projecting the scan from an arbitrary roll and pitch results in points that are no longer equal angles apart. Thus, we pubish the projected scan as a", ". The point cloud is published in the base_ortho frame of reference.", "You can run the", "on a pre-recorded bag file that comes with the package. First, make sure you have the", "stack downloaded and installed by following the instructions", ".", "You should see the input laser scan and the orthogonally projected scan displayed in", ", similar to the video below:", "Two drivers are available:", "and", ". Their parameters and topics are identical.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/katana_description", "package": "katana_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/win_empy", "package": "win_empy", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/katana_teleop", "package": "katana_teleop", "package_summary": [], "package_details": ["This package provides the", "ROS node, which provides a keyboard-based teleoperation for the Neuronics Katana 450 arm."]},
{"url": "https://wiki.ros.org/wheeled_robin", "package": "wheeled_robin", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Please refer main", "page."]},
{"url": "https://wiki.ros.org/twist_mux", "package": "twist_mux", "package_summary": ["Twist multiplexer, which multiplex several velocity commands (topics) and\n      allows to priorize or disable them (locks)."], "package_details": ["When there are more than a single source to move a robot with a", "message, it is important to multiplex all those input sources into a single one that goes to the controller (e.g.", ").", "This package provides a node that subscribes to a list of topics publishing", "messages and multiplexes them using a priority-based scheme. It also supports timeouts for each input and locking by means of topics that publish", "messages.", "The main node of this package is", ", which provides a multiplexer for", "messages. It takes N input twist topics and outputs the messages from a single one. For selecting the topic they are prioritized based on their priority, the messages timeout and M input lock topics that can inhibit one input twist topic. This is illustrated in the diagram below.", "In the", "folder there are example yaml files with configuration parameters.", "The", "subscribes to the N input twist topics and M input lock topics specified in the parameters", "and", "described below.", "The", "parameter contains a list of structs with the following fields that specify each input twist topics:", "Example configuration to multiplex the autonomous navigation from", ", a joystick from", ", a keyboard from", "and a tablet:", "The", "parameter contains a list of structs with the following fields that specify each input lock topics:", "The next plot shows one input twist topic vs. the output one. The delay is usually 0, and always", ".", "In order to make it easier to use a joystick input from", "with", ", the package comes with a joystick relay. See", "."]},
{"url": "https://wiki.ros.org/libcreate", "package": "libcreate", "package_summary": ["C++ library for interfacing with iRobot's Create 1 and Create 2"], "package_details": ["is a C++ library for interfacing with iRobot Create and Roomba platforms. For ROS bindings, see", ".", "Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/uos_rotunit", "package": "uos_rotunit", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For installation instructions, see", "."]},
{"url": "https://wiki.ros.org/manipulation_msgs", "package": "manipulation_msgs", "package_summary": [], "package_details": ["This package is", ". You probably want to use", "where some have been moved to. See also", "."]},
{"url": "https://wiki.ros.org/swiftnav", "package": "swiftnav", "package_summary": [], "package_details": ["This package is a ROS release of", "'s libswiftnav. It offers a variety of functionality related to linear algebra and spacial processing.", "All libswiftnav releases are here:", "Note that because libswiftnav is a plain CMake project and not a", "one, you can't use it in a regular catkin workspace\u2014 you must build and install using", ", and then overlay the resulting workspace with a regular catkin one."]},
{"url": "https://wiki.ros.org/rosrt", "package": "rosrt", "package_summary": ["rosrt provides classes for interfacing with ROS from within realtime systems, such as realtime-safe Publisher and Subscriber classes."], "package_details": ["starts three threads, one for publishing, one for subscribing and one for garbage collection.  The publisher thread uses a lock-free multi-writer single-reader queue with a fixed limit on the # of messages specified by", ".", "will never return the same message twice.  This means:", "rosrt is a package that contains realtime-safe tools for interacting with ROS.  It is currently", "and", ", so use at your own risk.", "Used together with a Xenomai Kernel the ROS processes get guaranteed CPU time and are not affected by other processes.", "rosrt can also slightly improve performance by avoiding memory allocations by preallocating. Those speed-ups should probably be helpful even if not running a real time system if small margins are important.", "There is an optional", "argument to", ".", "See also:", "Using the", "is very similar to the standard", "but with some realtime-specific requirements.  First, it provides you with a fixed-size buffer of messages (10 in the example below).  To be realtime safe you must allocate your messages out of this", "you're publishing it with.  Second, you must initialize each of those messages with a template message when you initialize the", ".  Anything that needs to be preallocated should be preallocated in this template.", "Deallocation of the", "'s pool of memory is done by a separate garbage collection thread, and will not happen until all messages allocated out of the", "have been freed (or on program exit).", "See also:", "Using the", "is a bit different from the standard", ", mainly because it's polling based instead of callback based:", "As with the", ", you must specify a message pool size.  If you are not going to be storing off received messages the optimal size for this is 3 (1 for the ROS-side subscription queue, 1 waiting in the Subscriber, 1 in use by realtime).", "Deallocation of the", "'s pool of memory is done by a separate garbage collection thread, and will not happen until all messages allocated out of the", "have been freed (or on program exit).", "rosrt also provides a way of tracking allocations and frees per thread.  See the", ",", ",", "functions in", ", as well as the", "."]},
{"url": "https://wiki.ros.org/summit_xl_localization", "package": "summit_xl_localization", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/laser_joint_projector", "package": "laser_joint_projector", "package_summary": ["Projects laser readings into a point cloud, based on a set of recorded joint angles\n     This package is experimental and unstable.\n     Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/schunk_powercube_chain", "package": "schunk_powercube_chain", "package_summary": ["This packages provides a configurable driver of a chain\n  of Schunk powercubes. The powercube chain is configured\n  through parameters. Most users will not directly interact\n  with this package but with the corresponding launch files\n  in other packages, e.g. schunk_bringup, cob_bringup, ..."], "package_details": ["To use this package you need one or more powercubes", ". Alternatively you can use a simulated version without any hardware, see", ".", "The installation is tested for Ubuntu 14.04 using ROS", ". If you discover problems installing them on other platforms, please", ".", "The", "package provides a configurable node for operating a chain of powercube modules.", "This package is not intended to be used directly, but with the corresponding launch and yaml files from e.g.", "in the", "stack.", "For starting only the lwa use", "All hardware configuration is done in the", "package. A sample parameter file in \"schunk_hardware_config/lwa/config/lwa.yaml\" could look like this"]},
{"url": "https://wiki.ros.org/tuw_checkerboard", "package": "tuw_checkerboard", "package_summary": ["The tuw_checkerboard package is designed to detect one \n    checkerboard and to estimate the pose of the checkerboard relative to the camera.\n    The detection itself is based on the opencv functions for checkerboards."], "package_details": ["This package detects one checkerboard in camera images and computes the 3D pose. The current 3D pose estimation is based on the OpenCV", "function. Various Parameter and algorithm used to detect the checkerboard can be tuned via ROS shared parameters or by using the dynamic reconfigure interface.", "This package allows you to publish the checkerboard pose as tf, marker msg, or pose."]},
{"url": "https://wiki.ros.org/pr2_common", "package": "pr2_common", "package_summary": ["URDF description of the robot kinematics and dynamics, 3D models of robot components, information required for gazebo to simulate the PR2, and messages specific to the PR2 such as detailed information about its power board and fingertip pressure sensors."], "package_details": ["This stack is not intended for user consumption. Check the", "documentation for how to interpret this data, or  look at the examples in"]},
{"url": "https://wiki.ros.org/staubli_rx160_moveit_plugins", "package": "staubli_rx160_moveit_plugins", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "metapackage page."]},
{"url": "https://wiki.ros.org/kobuki_gazebo_plugins", "package": "kobuki_gazebo_plugins", "package_summary": [], "package_details": ["The plugin is configured throught the parameters given in the URDF description. See the", "for details.", "Have a look at the", "package to find out how to use this plugin."]},
{"url": "https://wiki.ros.org/can_msgs", "package": "can_msgs", "package_summary": ["CAN related message types."], "package_details": []},
{"url": "https://wiki.ros.org/asr_gazebo_models", "package": "asr_gazebo_models", "package_summary": ["This package provides our gazebo_models"], "package_details": ["To use these models with gazebo, copy the according folder to \"~/.gazebo/models\" following", ".", "One need", "to use the models.", "To use these models with gazebo, copy the according folder to \"~/.gazebo/models\" following", "."]},
{"url": "https://wiki.ros.org/pr2_map_navigation_app", "package": "pr2_map_navigation_app", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/semantic_point_annotator", "package": "semantic_point_annotator", "package_summary": ["A node which annotates 3D point cloud data with semantic labels."], "package_details": ["This package provides a node that the", "package uses for removing hits on the ground from", "messages.", "Since the", "message will be deprecated in the near future, and the code in this package will be replaced with code using the new PointCloud format, there are no guarantees about the stability of this package. After the", "stack switches to the new PointCloud structure, this package will likely be removed. You should feel free to use the code in this package, but it will not be supported and is at your own risk."]},
{"url": "https://wiki.ros.org/maggie_rfid_msgs", "package": "maggie_rfid_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_rfid_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_rfid_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/tuw_aruco", "package": "tuw_aruco", "package_summary": ["This is a wrapper around the marker detection library ArUco."], "package_details": ["live demo using the", "(uvc camera driver) package as a video source. Default settings (marker_dictonary=ARTOOLKITPLUSBCH, marker_size=0.06) are used.", "The", "plugin", "provides visualization for the", "message."]},
{"url": "https://wiki.ros.org/rtt_stereo_msgs", "package": "rtt_stereo_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot", "package": "robot", "package_summary": ["A metapackage which extends ros_base and includes ROS libaries for any robot hardware. It may not contain any GUI dependencies."], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_actions", "package": "turtlebot_actions", "package_summary": [], "package_details": ["This package is still experimental."]},
{"url": "https://wiki.ros.org/tf2_py", "package": "tf2_py", "package_summary": ["The tf2_py package"], "package_details": ["This package allows to convert tf2 and geometry_msgs data to", ". Also binds the tf2 functions and exceptions to python.", "This is an implementation package, please refer to", "for more information."]},
{"url": "https://wiki.ros.org/posedetection_msgs", "package": "posedetection_msgs", "package_summary": ["posedetection_msgs provides messages and services to facilitate passing pose detection results and features."], "package_details": []},
{"url": "https://wiki.ros.org/power_msgs", "package": "power_msgs", "package_summary": ["ROS messages for power measurement and breaker control."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"power_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/power_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/pr2_msgs", "package": "pr2_msgs", "package_summary": ["Messages for representing PR2 state, such as battery information and the PR2 fingertip sensors."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"pr2_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/pr2_msgs/manifest.yaml", ": Added", "Where two versions of a message or service are defined, the version defined with a suffix of", "is preferred; the non-suffix version is deprecated (e.g., we use", "instead of", ")."]},
{"url": "https://wiki.ros.org/maxwell", "package": "maxwell", "package_summary": [], "package_details": ["The development of Maxwell has been covered on my blog (", ")."]},
{"url": "https://wiki.ros.org/tedusar_manipulation", "package": "tedusar_manipulation", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/wire_tutorials", "package": "wire_tutorials", "package_summary": [], "package_details": ["Package containing data for", "stack tutorials. The tutorials can be found"]},
{"url": "https://wiki.ros.org/ridgeback_msgs", "package": "ridgeback_msgs", "package_summary": ["Messages exclusive to Ridgeback, especially for representing low-level motor commands and sensors."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"ridgeback_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/ridgeback_msgs/manifest.yaml", "These messages are the low-level interface between", "'s ARM MCU and integrated PC. Most users of Ridgeback should be able to use standard ROS interfaces (eg.", ",", ") to command and monitor the robot. A possible exception is to programmatically monitor system state such as voltage, current, battery, faults, etc."]},
{"url": "https://wiki.ros.org/schunk_pg70", "package": "schunk_pg70", "package_summary": [], "package_details": ["This package is part of", "stack. It allows user to control Schunk PG70 gripper over RS232 link using standard ROS services and  provides Xacro model for easier integration with various robots.", "This package depends on", "library by William Woodall, git clone and catkin_make if not already in your workspace. Then you can proceed to clone and build of schunk_pg70", ".", "The right to access a serial port is determined by the permissions of the device file (e.g. /dev/ttyS0). Serial ports are usualy owned by root and group dialout, so to access the serial device as non-root user it is convenient to add yourself to", "group:", "These services are ROS user interface to Schunk PG70 gripper. Except \"set_position\" all of them use", "requests, so you don't need to specify any values, just \"rosservice call\" as in the example below.", "To test the driver start by calling the", "service (", "request):", "To get actual gripper position, call", "service (", "request):", "Service respond with actual position value is in", "format:", "To move the gripper to target position, call", "service (", "request):", "where \"", "\" is within a range of <0 - 69> mm, velocity <0-83>mm/s and acceleration <0-320>mm/s2. The gripper should respond with goal_position being accepted or not and move to goal position:", "To reference gripper, call", "service (empty request). Referencing may also help in cases when you are not  able to move the gripper although everything else looks okay:"]},
{"url": "https://wiki.ros.org/sr_external_dependencies", "package": "sr_external_dependencies", "package_summary": ["sr_external_dependencies package is a \"dummy\" package used to synchronize the includes for the protocol\n    communication between the host and the PIC for Shadow's EtherCAT hardware. It contains a script that automatically\n    downloads the latest h file from our pic32 git."], "package_details": ["'", "When you run make in this package, it simply copies the files from the released directory to the include and compiled_firmware directories. The protocol headers are then used in the", "and", "to interpret the incoming packets.", "The compiled firmware can be used in the bootloader plugin of the", "to update the firmware of the motors.", "If you set the", "environment variable to 1, then we'll download the latest version of the protocol and also the latest compiled firmware from our internal svn (this is only possible if you're working for Shadow)."]},
{"url": "https://wiki.ros.org/sr_gui_change_controllers", "package": "sr_gui_change_controllers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/visp_hand2eye_calibration", "package": "visp_hand2eye_calibration", "package_summary": ["visp_hand2eye_calibration estimates the camera position with respect\n     to its effector using the ViSP library."], "package_details": ["visp_hand2eye_calibration is a ROS package that computes extrinsic camera parameters : the constant transformation from the hand to the camera coordinates.", "is part of", "stack.", "An example client is shipped with this package. It feeds different transformations (camera->object and world->hand) to the calibrator which computes the relative transformation between the the camera and the hand.", "To do so, two sets of transformations are fed to the", "node.", "The package consists of a", "node and an experimental client doing a sample calibration from a few poses.", "To run the", "node:"]},
{"url": "https://wiki.ros.org/win_roscpp_tutorials", "package": "win_roscpp_tutorials", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/svenzva_description", "package": "svenzva_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/face_detector", "package": "face_detector", "package_summary": ["Face detection in images."], "package_details": ["and", "together consists the namespace prefix, and", "makes the body of the topic to subscribe. In the example above, you're looking for:", "See", "to see how to run the face detector continuously, or", "to run it as an action.", "files above are stored", ".", "Possible pitfall may be the argument names (in", "for example):", "See", "for the name of the topics you need to correct.", "No doubt", "works on the robots on simulator. Examples below show how you can run this package using stereo camera on", "and", ". Additionally, using some other useful packages, you can visualize face detection result on", "."]},
{"url": "https://wiki.ros.org/maggie_eyelids_msgs", "package": "maggie_eyelids_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_eyelids_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_eyelids_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/pr2_controller_manager", "package": "pr2_controller_manager", "package_summary": ["The controller manager (CM) package provides the infrastructure to run controllers in a hard realtime loop."], "package_details": ["The", "provides a", "loop to control the robot mechanism. The robot mechanism is represented by a set of effort controlled joints (see", "for details).  For the PR2 robot, we run the control loop at 1000 Hz. The controller manager provides the infrastructure to load your own realtime controller into its control loop. Every controller that is loaded into the controller manager will get triggered once every mili-second. To find out how to write your own hard realtime controller, take a look at", ".", "The controller manager ensures that none of the loaded controllers can command a joint past its", ". If necessary, the controller manager reduces the commanded joint effort, or even applies an effort in the opposite direction. For more details, take a look at the", "page.", "The controller manager publishes the state of all joints over ROS, as", "messages. These messages appear on the", "topic, at 100 Hz. You can change this publishing frequency by setting the", "parameter.", "To interact with controllers from the command line, use the", "tool. To interact with a specific controller, use:", "To automatically load and start a set of controllers at once, and automatically stop and unload those same controllers at once, use the", "tool:", "To automatically stop a set of controllers, and restart them later, you can use the", "tool:", "The listed controllers will be", ", but not unloaded. Once spawner is shut down, the controllers will be restarted.", "You could run", "to start controllers from within a launch file. However, the controller would then stay up even after the launch file is taken down. Instead, use the", "tool to automatically load, start, stop and unload a controller from within a launch file. When you start", ", it will load and start the controller. When you stop", "(when the launch file is taken down) it will stop and unload the controller. Your launch file would look something like this:"]},
{"url": "https://wiki.ros.org/sr_gui_self_test", "package": "sr_gui_self_test", "package_summary": [], "package_details": ["You can select one of the available self tests of the hand to be executed. Follow the on screen instructions. This will take some time! This is the front-end of", "package."]},
{"url": "https://wiki.ros.org/turtlebot_msgs", "package": "turtlebot_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"turtlebot_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/turtlebot_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/sr_mechanism_model", "package": "sr_mechanism_model", "package_summary": ["sr_mechanism_model contains the transmissions used in the robot model. We needed specific\n        transmission as we're using our own actuator. We also needed to take care of the joint 0s\n        which combine the distal and middle phalanges."], "package_details": ["We needed to redefine the", "used in the", ", to be able to combine the distal and middle phalanges of the fingers into joint 0s. The new transmissions are defined in this package. They're using the actuators which are defined in", "."]},
{"url": "https://wiki.ros.org/sr_gui_hand_calibration", "package": "sr_gui_hand_calibration", "package_summary": ["A GUI plugin for calibrating the Shadow EtherCAT Hand."], "package_details": []},
{"url": "https://wiki.ros.org/summit_x_description", "package": "summit_x_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/win_ros", "package": "win_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pheeno_ros_sim", "package": "pheeno_ros_sim", "package_summary": [], "package_details": ["Documentation for our package can be found", ". We will also be adding documentation to this ROS page in the coming weeks."]},
{"url": "https://wiki.ros.org/pr2_dense_laser_snapshotter", "package": "pr2_dense_laser_snapshotter", "package_summary": ["Stores the data from a series of laser scan messages in a dense representation, allowing\n     users to easily perform image-like operations on intensity or range data. This package is\n     experimental. Expect APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_mechanism_diagnostics", "package": "pr2_mechanism_diagnostics", "package_summary": ["The `pr2_mechanism_diagnostics` node subscribes to `mechanism_statistics` and publishes diagnostics data for joints and controllers on `/diagnostics`."], "package_details": ["The", "package publishes data from the", "topic onto diagnostics. This data is published by", ". The joints and controllers diagnostics come from this package.", "The", "topic contains statistics and information from the joints, actuators and controllers."]},
{"url": "https://wiki.ros.org/asr_ism", "package": "asr_ism", "package_summary": ["This package contains nodes which make up the Passive-Scene-Recognition interface to Implicit Shape Model (ISM) trees. The Active-Scene-Recognition interface to ISM trees is located in asr_recognizer_prediction_ism, instead. A short outline of the functionalities provided by the nodes are:\n      1. Recording of scenes\n      2. Training of an ISM tree (Implicit shape model tree)\n      3. Recognition of scenes\n      4. Visualization of ISM (tree) data \n\t  etc."], "package_details": [": Visualize recorded data of a given pattern as a path for each object on which these objects moved while recording.", ": Expand the", "visualization with vectors from positions of an object on its path at a certain point in time to its reference path at the same point in time. This visualization can help the user to understand how the model was created from each record data point.", ": Provide two different vote visualizations, the first just visualizes all votes from a fixed pose for a selected object in a selected subpattern and the second visualizes a given configuration with each object's votes that the model of a selected pattern provides.", ": This class can be used for custom nodes to convert ros messages (", ") to data-types used by the", "library. This class is implemented in the", "file.", ": This class expands a node with the functionality to configure an object configuration interactively. Main features of this class are the multi-threaded processing of incoming messages (number of threads set by the user) and the processing of keyboard input (polling on its own dedicated thread). With this approach the actual node runs on its own thread(s) and decouples the", "logically and computationally from the node.", ": This node republishes recorded data from a given database as ros messages (", ").", ": This node generates an object configuration by editing object data from a given database or XML-file and writes it to an XML-file.", ": This service is only called by the ObjectConverter class and provides it with additional information about recognizable objects from the", ".", "Missing object estimations when using a SceneConfigurator -Node and the", "_driver GUI.", "Make sure to uncheck the \u201cupdate current angle immediately\u201d option if you want to work with the current view.", "This package serves as the Passive-Scene-Recognition interface to the functionality provided by the", "library in the ROS environment. The Active-Scene-Recognition interface to ISM trees is located in", ", instead. The core functions of this package are the training and recognition of scenes which consist of various objects using Implicit Shape Model (ISM) trees. In addition to the implementation of the tools provided by", "there are several visualization (based on", ") and utility tools to make the usage of the scene recognition system more convenient.", "There are two training approaches implemented, one simply being called", ", the other", ". They are interchangeable but as they use different algorithms the trained models result in a difference in recognition quality mostly in terms of speed as the latter has a shorter computation time. The input of both trainers is a recording of a scene consisting of multiple objects which is stored in a sqlite database and can be created using the \"Recorder\" tool. The \"Recognizer\" tool uses the trained models and tries to find the most likely match given a set of objects.", "In general the steps required are the recording of a scene, training a model from this recording and then using the recognizer to get the most likely scene match from a new object configuration. Below you can see a list of all tools this package provides including the mentioned ones and tutorials on how to use them. For more information about the functionality see the", "package.", "The nodes in this list wrap tools from", "to provide them in the ROS environment:", "Although many nodes of this package publish some kind of visualization, the purpose of these nodes is solely to visualize ism data in", ".", "If you are using the", "from", "and you checked the option \u201cupdate current angle immediately\u201d, it may happen that the SceneConfigurator clears the object estimations in the current view, because the ptu toggles its \u201creached_desired_position\u201d parameter."]},
{"url": "https://wiki.ros.org/tedusar_box_detection", "package": "tedusar_box_detection", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosserial_python", "package": "rosserial_python", "package_summary": ["A Python-based implementation of the rosserial protocol."], "package_details": ["The", "package contains a Python implementation of the host-side rosserial connection. It automatically handles setup, publishing, and subscribing for a connected rosserial-enabled device.", "To run the node with a different port and baud rate, for example on /dev/ttyACM1, you must specify the", "and", "parameters on the command line:"]},
{"url": "https://wiki.ros.org/pr2_machine", "package": "pr2_machine", "package_summary": ["This package contains the xxx.machine files that describe the different hosts a node can be spawned on. Currently there is one machine file for the pr2 robot, and one for the simulated pr2 robot."], "package_details": ["These files are intended to be included by", "files.  The intended usage is:", "The user sets the", "environment variable to", "when working with a physical PR2, and", "when working in simulation.  In this way,", "files that refer to machines", "and", "will distribute computation appropriately on the robot, but still work on a single machine in simulation (assuming that the single machine can support the processing requirements)."]},
{"url": "https://wiki.ros.org/segbot_simulation_apps", "package": "segbot_simulation_apps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/smart_battery_msgs", "package": "smart_battery_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"smart_battery_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/smart_battery_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/uos_rotunit_driver", "package": "uos_rotunit_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/srdfdom", "package": "srdfdom", "package_summary": ["Parser for Semantic Robot Description Format (SRDF)."], "package_details": []},
{"url": "https://wiki.ros.org/wpi_jaco", "package": "wpi_jaco", "package_summary": [], "package_details": ["Not all of the functionality of the meta-package is implemented yet for the JACO2.  There's no jaco2_description package yet, providing a urdf for the arm.  Similarly, there is no sample", "! configuration either, which is waiting on the urdf before configuration is possible.  As such, the motion planning functionality found in the two moveit packages have not yet been extended to the JACO2.  All of the other functionality should work as intended for the new arm.", "To install the", "package, you can install from source with the following commands:", "The", "package contains a launch file,", ", to start all of the nodes required to communicate with the JACO arm.  Once these nodes are launched, further launch files can be run from the other packages, all of which are documented in their respective wiki pages.", "Please send bug reports to the", "."]},
{"url": "https://wiki.ros.org/rtmros_nextage", "package": "rtmros_nextage", "package_summary": ["The rtmros_nextage package is a ROS interface for", "dual-armed robot from Kawada Robotics Inc."], "package_details": ["The content of this DVD has become obsolete. Please refer to", "tutorial page and get the software.", "might ask you this password:", "See", ".", "Please read the", ".", "When you insert the DVD into your Ubuntu computer,", "package, which is a basis of", ", and its dependency will be installed.", "Once installation is done, you can try it by following", "(which is ogirinally made for the robot from the same manufacturor called", "). Since installation should be done by this point, you can skip installation section and move forward to", ".", "(New 2013/11/07) Now", "is installable from ROS repository. See", "."]},
{"url": "https://wiki.ros.org/phidgets_imu", "package": "phidgets_imu", "package_summary": ["Driver for the Phidgets Spatial 3/3/3 devices"], "package_details": ["The", "package contains a  ROS driver for the", "IMU sensor. The driver publishes the following data:", "You can use this driver in conjunction with", "or a similar IMU filter to get an estimate for the orientation of the sensor from the fused sensor readings.", "An example", "for using the driver together with a filter is included in the package."]},
{"url": "https://wiki.ros.org/sr_gui_change_muscle_controllers", "package": "sr_gui_change_muscle_controllers", "package_summary": ["A GUI plugin for loading the different muscle controllers."], "package_details": ["This is similar to", "but is used for the version of the hand that uses air pressure actuated muscles instead of electric motors. You may select Valve or position control mode."]},
{"url": "https://wiki.ros.org/linux_peripheral_interfaces", "package": "linux_peripheral_interfaces", "package_summary": ["Simple scripts which help utilise, monitor, interact with computer\n     hardware abstracted by a linux OS."], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/turtlebot_rapps", "package": "turtlebot_rapps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/spur_controller", "package": "spur_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_navigation", "package": "pr2_navigation", "package_summary": ["The pr2_navigation stack holds common configuration options for running the"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_bringup", "package": "turtlebot_bringup", "package_summary": [], "package_details": ["Follow the", "to start your TurtleBot."]},
{"url": "https://wiki.ros.org/tedusar_cartesian_arm_teleop", "package": "tedusar_cartesian_arm_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_handler", "package": "manipulator_handler", "package_summary": [], "package_details": ["The manipulator handler looks for a manipulator tag and it finds all its joints. After it creates a ROS publisher of", "messages:", "In addition it gives us the possibility to control the joints using commands from ROS in several ways (see", "for more details):", "In the folder", "you will find the model of a manipulator with the joints controlled in velocity:", "."]},
{"url": "https://wiki.ros.org/turtlebot_create_desktop", "package": "turtlebot_create_desktop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tuw_marker_noise", "package": "tuw_marker_noise", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_mechanism_controllers", "package": "sr_mechanism_controllers", "package_summary": ["The sr_mechanism_controllers package contains different types of\n        controllers for the etherCAT hand: position controllers,\n        velocity controllers, force controllers, ..."], "package_details": ["The different controllers are implemented in this package. The controllers have access to an actuator which contains the hand data updated in real time by", "and", ".", "The", "package is used to record and interpolate the friction compensation map. Based on this map, we just add a value to the output of the controller as illustrated below (we have two different maps, one for each direction):"]},
{"url": "https://wiki.ros.org/stdr_server", "package": "stdr_server", "package_summary": [], "package_details": ["(", ")", "(", ")", "(", ")", "can run without any command-line arguments and simply waits until someone calls either", "or", "service. There is an option to run", "passing an image file to load as the static map or you can include it to a launch file using the", "option.", "The", "node implements the synchronization and coordination functionalities of", ". It is used to serve the static map, which represents the simulated environment and keeps track of active robots.", "The", "node provides several action server implementations used for robot handling and coordination.", "The", "node uses", "'s", "library to load an map image from a file, fill a", "message, call", "service and load it to the simulator. The loading functionality is also provided in", "library and can be used by other packages.", "For tutorials see", "."]},
{"url": "https://wiki.ros.org/schunk_modular_robotics", "package": "schunk_modular_robotics", "package_summary": ["This stack includes packages that provide access to the Schunk hardware through ROS messages, services and actions."], "package_details": ["For the Schunk Powercubes, see", ".", "For the Schunk SDH, see", ".", "Please consult", "to see if your problem is already known.", "Please use the", "for additional support or feature discussion.", "Use", "to report bugs or request features."]},
{"url": "https://wiki.ros.org/vtec_ros", "package": "vtec_ros", "package_summary": ["The vtec_ros metapackage that installs VisioTec packages"], "package_details": ["Use GitHub to", ". [", "]", "A", "A technical report is available here:", ". It describes the tracker software and its working principles. If you use this software in an academic context, please cite the technical report, using:", "Download the dataset from here:"]},
{"url": "https://wiki.ros.org/trac_ik_python", "package": "trac_ik_python", "package_summary": ["The trac_ik_python package contains a python wrapper using SWIG\n  for trac_ik_lib"], "package_details": []},
{"url": "https://wiki.ros.org/intrinsic_cal", "package": "intrinsic_cal", "package_summary": [], "package_details": ["While a", "method does already exist, for some industrial and high precision  applications, the results may not be sufficient.  Depending on the number and quality of the images collected by the user, the calibration method can result in widely varying focal length values.", "Error per observation: The industrial calibration package utilizes the", "to collect all the image observations and optimize the camera parameters (intrinsic or extrinsic) to minimize the error.  For the intrinsic calibration package, an observation is a single circle found in the calibration target.  So for a single image of an 18x24 grid calibration target, there are 432 observations made, and 4320 observations made for a series of 10 images.  After optimization, the total error is then divided by the number of observations in order to obtain the average error per observation.  This is the measure of how accurately the algorithm was in finding the target location.  Since the target location in the image is measured in pixels, then the error units is also in pixels.  Thus, an average error per observation of 1 pixel indicates that final solution was able to find the actual target location with an accuracy of 1 pixel.  When performed correctly, all calibration attempts should result in less than 1 pixel of error."]},
{"url": "https://wiki.ros.org/kobuki_dashboard", "package": "kobuki_dashboard", "package_summary": [], "package_details": ["The kobuki_dashboard is also part of the", ". In order to get the battery statuses, you need to launch the", "."]},
{"url": "https://wiki.ros.org/ur_msgs", "package": "ur_msgs", "package_summary": ["Message and service definitions for interacting with Universal Robots robot controllers."], "package_details": []},
{"url": "https://wiki.ros.org/twist_mux_msgs", "package": "twist_mux_msgs", "package_summary": ["The twist_mux msgs and actions package"], "package_details": []},
{"url": "https://wiki.ros.org/tf2_geometry_msgs", "package": "tf2_geometry_msgs", "package_summary": ["tf2_geometry_msgs"], "package_details": []},
{"url": "https://wiki.ros.org/rosout", "package": "rosout", "package_summary": ["System-wide logging mechanism for messages sent to the /rosout topic."], "package_details": ["is an aggregated feed for subscribing to console logging messages. This aggregated topic is offered as a performance improvement: instead of connecting to individual ROS nodes to receive their console messages, the aggregated message feed can instead be received directly from the", "node.", "node by default logs all messages into", "in the ROS log directory.", "This can be disabled by setting environment variable", "to", "when launching", ".", "This behavior can be changed by setting boolean ROS parameter", "at any time.", "The", "only provides the", "node.", "Please see", ".", "The", "node is part of", "and has preferential startup order.", "ROS", "are required to publish console logging messages to the", "topic as a standard interface.", "By default,", "prints", "name for every message.", "No future development on", "is currently planned."]},
{"url": "https://wiki.ros.org/rosh_visualization", "package": "rosh_visualization", "package_summary": [], "package_details": [":"]},
{"url": "https://wiki.ros.org/sr_edc_launch", "package": "sr_edc_launch", "package_summary": ["Package with launch files to start the needed nodes for the Shadow Robot EtherCAT hand."], "package_details": ["This package contains the main launch files used to start the etherCAT Hand ROS driver. For more information on how to start the interface, please go to the", "."]},
{"url": "https://wiki.ros.org/rosnode", "package": "rosnode", "package_summary": ["rosnode is a command-line tool for displaying debug information\n    about ROS", ",\n    including publications, subscriptions and connections. It also\n    contains an experimental library for retrieving node\n    information. This library is intended for internal use only."], "package_details": ["is a stable command-line tool within the ROS core toolchain. No major feature development is currently scheduled for this tool.", "The", "command-line tool displays information about ROS", ". The currently supported commands are:", "IMPORTANT:", "is not guaranteed to succeed. If a node is hung or set to \"respawn\" in", ", it may either fail to die or may quickly reappear.", "IMPORTANT:", "was meant as a temporary solution and its use was not encouraged in normal operation. Its benefit is aesthetic and it has the downside of potentially unregistering functioning nodes.", "."]},
{"url": "https://wiki.ros.org/nextage_ik_plugin", "package": "nextage_ik_plugin", "package_summary": ["IKFast package for NEXTAGE Open"], "package_details": ["See", "tutorial for the usage of this package."]},
{"url": "https://wiki.ros.org/asr_lib_ism", "package": "asr_lib_ism", "package_summary": ["This package contains the ROS-independent library which provides the actual scene-recognition functionality of Implicit Shape Model (ISM) trees. It is referred to both by asr_ism for Passive Scene Recognition and by asr_recognizer_prediction_ism for Active Scene Recognition."], "package_details": ["Provides an interface to store sets of  objects to a sqlite database. Each set of objects represents a  configuration of objects for a certain scene.", "The Trainer and the CombinatorialTrainer  are interchangeable, both create a scene model represented by an ISM  from the object poses stored in the recorded database and write it into a  sqlite database. The ISM created by the CombinatorialTrainer should have a shorter computing time when it comes to recognizing a scene compared to the one created by the Trainer.", "Given a set of objects, the Recognizer calculates the  most likely scenes that those objects are part of. These calculations  use the scene models created by the Trainer/CombinatorialTrainer.", "Delete the recordings or the models or both from the database.", "Merge multiple databases into one.", "Rotate the pose of objects which are determined by a marker e.g.", ".", "Generates additional recording data  between objects by interpolating the pose of two objects between  consecutive recorded object sets.", "Transform the absolute pose of an entire scene relative to a world coordinate frame.", "Rotate Objects in the  database which are rotation invariant to the y-Axis around this y-Axis  to a given direction. As result these objects get distinct object poses.", "- Stores the representing name for a pattern.", "- Stores a recorded object set at a point in time for a certain pattern.", "- Stores the object estimation pose obtained from a object recognizer during the recording process.", "- Stores the object estimation meta-data obtained from an object recognizer during the recording process.", "- Stores trained patterns.", "- Store all objects which appeared while training the model.", "- Stores the votes generated by the trainer.", "Include", "Create a new Recorder instance:", "Insert objects of a recorded object configuration into the database:", "Include", "Create a new Trainer instance:", "Train ism for all patterns inside the database:", "Train ism only for the given pattern (patternName):", "Before using the trainPattern method, the training parameters  should be set. An example how to set those parameters can be found at asr_ism/src/trainer.cpp", "Include", "Create a new CombinatorialTrainer instance:", "Train ism for all patterns inside the database:", "Include", "Create a new", "instance:", "Recognize most likely pattern for a given object configuration:", "This package contains the ROS-independent library which provides the actual scene-recognition functionality of Implicit Shape Model (ISM) trees. It is referred to both by", "for Passive Scene Recognition and by", "for Active Scene Recognition.", "XML is used to represent a scene, a pattern or just a set of objects for convenient use in simulation or to just store a certain configuration of objects for further use. E.g. use the XML to publish the contained object-set as recognized object estimations with the provided tool of the", "package.", "This package only provides the library without any nodes, however the package", "implements nodes for the actual usage of the recognition system."]},
{"url": "https://wiki.ros.org/ndt_registration", "package": "ndt_registration", "package_summary": [], "package_details": ["This package implements point cloud registration, using the Normal Distributions Transform. Two basic classes are available - point to distributiuon registration (NDTMatcherP2D) and distribution to distribution registration (NDTMatcherD2D). The point to distribution algorithm is described", "and the distribution to distribution", "."]},
{"url": "https://wiki.ros.org/network_autoconfig", "package": "network_autoconfig", "package_summary": ["ROS Networking Autoconfiguration"], "package_details": []},
{"url": "https://wiki.ros.org/wire", "package": "wire", "package_summary": [], "package_details": ["J. Elfring, S. van den Dries, M.J.G. van de Molengraft, M. Steinbuch, Semantic world modeling using probabilistic multiple hypothesis anchoring, Robotics and Autonomous Systems, Volume 61, Issue 2, February 2013, Pages 95-105, (", ")", "To install the", "software, clone the source into your workspace:", "We have created a set of", "explaining how to use, tune and interpret the world model and the resulting world state estimate."]},
{"url": "https://wiki.ros.org/maggie_ir_controller_msgs", "package": "maggie_ir_controller_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_ir_controller_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_ir_controller_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/maxwell_moveit_config", "package": "maxwell_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rail_ceiling", "package": "rail_ceiling", "package_summary": [], "package_details": ["Rail_ceiling is an overhead camera system for tracking the positions of obstacles in a closed space and publishing maps containing those obstacles for use in robot navigation. Rail_ceiling supports multiple cameras and can publish multiple maps with different obstacle footprints. Obstacle tracking is accomplished using ar tags and the", "ros package.", "The", "node will run an automatic calibration procedure where each camera will take sample poses of an associated marker of known position in the environment.  Once a sufficient number of samples have been taken for each camera, the transforms will be calculated and written to the", "file in your home directory, and must then be copied into the", "directory of the", "package if you wish to use it.", "The", "node provides a method of calibrating the camera transforms from a marker placed on a localized mobile robot, such as the CARL platform.  This calibration method is executed as follows:", "Next, the robot must be driven into the field of view of a camera to be calibrated.  Once the robot is in the camera's field of view and it is confirmed to be accurately localized, publishing to the", "topic with the id number of the camera to be calibrated replacing [camera_id]:", "Once sufficient samples are collected for all of the cameras, the transforms will be calculated and written to the", "file in your home directory, and must then be copied into the", "directory of the", "package if you wish to use it.", "The transforms can also be edited directly in the human-readable urdf file,", ".  This should only be done if the camera positions and orientations can be accurately measured.", "Furniture footprints and marker information can be configured in the", "and", "file in the", "directory.  The", "configuration file defines general pieces of furniture with convex polygon footprints for localization and navigation, and the", "configuration file defines instances of furniture with attached markers and their associated poses.", "To add a new type of furniture, simply add a new entry to the", "file.  Each entry must have a name (for identifying the type of furniture) a localization footprint (a set of convex polygons that a laser scanner will detect), and a navigation footprint (a set of convex polygons that represent the full area occupied by the piece of furniture that should be avoided during navigation).  The entry format is as follows:", "Points composing the polygons are defined with respect to the center of the piece of furniture, according to a coordinate system with x increasing right, y increasing forward, and z increasing up.  In practice, the reference frame's position does not have to be at the center of the furniture piece, as long as it is consistent with the reference frame defined for instances of the furniture type in the", "file.", "Each piece of furniture in th eenvironment must have its own entry in the", "file.  Each entry consists of a required type (corresponding with the furniture names defined in", "), an optional initial_pose (an initial pose for the piece of furniture in the global coordinate frame), and a required set of markers.  Markers are defined with the unique id used to generate them, and the pose of the marker with respect to the furniture reference frame.  The entry format is as follows:", "The main functionality of the", "package is furniture tracking.  This can be launched with:", "Please send bug reports to the", "."]},
{"url": "https://wiki.ros.org/xbot_description", "package": "xbot_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/stop_base", "package": "stop_base", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rtt_trajectory_msgs", "package": "rtt_trajectory_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/teleop_twist_keyboard_cpp", "package": "teleop_twist_keyboard_cpp", "package_summary": ["Generic keyboard teleop for twist robots (in C++)! Based off of the teleop_twist_keyboard Python ROS node."], "package_details": ["C++ Implementation of the Generic Keyboard Teleop for ROS:"]},
{"url": "https://wiki.ros.org/ros_canopen", "package": "ros_canopen", "package_summary": ["A generic canopen implementation for ROS"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_make_a_map_app", "package": "pr2_make_a_map_app", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_visualization", "package": "sr_visualization", "package_summary": ["This stack contains the different gui plugins used with the shadow robot stacks."], "package_details": ["is a package with GUI plugins which can be used to control the different nodes of the", "stack. The GUI plugins are programmed in Python and can be started from within rqt. A ROS master must be running before starting rqt. rqt can be started by simply typing in linux command line:", "For more information please see our", "."]},
{"url": "https://wiki.ros.org/lyap_control", "package": "lyap_control", "package_summary": [], "package_details": ["The lyap_control package provides a sophisticated and relatively easy-to-use control node. It can handle regulation or tracking problems of any order and with any number of inputs... from simple first order dynamic systems where a PID controller would typically be used... up to complex, large, higher-order systems. There is also a", "which can be used to visualize, tune, and simulate the control algorithm beforehand. The default example of the MATLAB toolbox shows the simultaneous tracking of seven motors. The theory behind the algorithm is explained", ".", "(You may have to do this every time you open a new terminal window, or add this line to your bashrc:", ")", "This launches a simulation of a 2nd-order system with (1,-2) setpoints. The displayed", "is the sum-of-squares of the error for all states (it should drop exponentially).", "You may wish to tune the controller at this point. You can adjust its 'aggressiveness', called", ", in controller.h. Generally a more negative value performs better, unless the time step is too small and it becomes unstable. The saturation limits on the control effort (maximum and minimum) and the controller's model of the system are also adjusted here.", "The time step for the simulation is adjusted as the variable", "in second_order_plant_header.h. A smaller time step will perform better.", "To demonstrate how to switch to a different dynamic system, a first-order single-input example is included (", "). Here are the changes that must be made to control this other system:", "1. In", ", change", "and", "to one-vectors since there is one input now.", "2. Edit the model definition in", "to update the controller's model of the system. Comment the second equation so there is just one state variable", "3. Since there are fewer states and inputs, the messages that the nodes pass must be shorter. In", ", update", "to a 1-vector. In", ", update", "and", "to 1-vectors.", "If you wish to change the initial conditions or the setpoints, or even make a time-varying setpoint, you can do so in", ". If you want more aggressive gain, again, change", "in", "In general, the best results are achieved with a very high control rate and a very large 'gain.' Set the loop rate of your plant and the controller as fast as the hardware will allow, then set the gain (a.k.a.", ") as high as stability allows. These changes are made in"]},
{"url": "https://wiki.ros.org/stdr_msgs", "package": "stdr_msgs", "package_summary": [], "package_details": ["package provides the essential ROS messages, services and actions for the", "to operate.", "Newly proposed, mistyped, or obsolete package. Could not find package \"stdr_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/stdr_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/imu_handler", "package": "imu_handler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/spatial_world_model", "package": "spatial_world_model", "package_summary": [], "package_details": ["As a basic example for the types of end-user interfaces that can be created with the Spatial World Model, we look at the Map annotation interface. Information on this interface can be found on the", ". Below is a video demonstrating its capabilities:", "The following steps are written for", "but apply to most Linux systems.", "To begin, we must install", "and the Python libraries that will talk to it. To do so, run the following command:", "Finally, we are able to install the database schema. This is provided in a script found in the", "package. This script can be used to both install a new database and to update an existing one.", "In many cases, you will be installing the Spatial World Model database on a central server so that multiple clients (and robots) can talk to it. As of now, the ROS nodes communicate via SQL to the database; however, due to security risks this will eventually be changed. To allow remote connections, we must modify the configuration scripts on the system. Using your choice of editor, modify", "with root privileges and add the following line:", "Next, modify", "with root privileges and add the following line:", "At its core, the Spatial World Model is designed to be a persistent, multi-robot model to keep track of both the robot's working memory as well as keeping track of properties, affordances, and activities that can be associated with each object. To manage persistence, the world model is stored in a", "database  At a high level, currently the Spatial World Model allows for two sets of entities: a", "and a", ".", "A", ", defined in the", "message, can be thought of as a robot's working memory. At a basic level, such an entity contains a relative pose in the world with associated tags and timestamps. These entities describe a particular, specific instance of an object in the world (e.g., the cup sitting on the desk in the conference room). Each instance is linked to a single", "which contains a set of spatial descriptors for the object (e.g., mesh, bounding box, point-cloud cluster, etc...). Below is a detailed explanation of the fields in the", ". Note that some fields will be blank depending on the type of object or what you know about the world.", "The second implemented entity is the", ". This entity, defined in the", "message, contains spatial descriptors of objects in the world. These are shared models that are common between all instances of such an object (e.g., a 3D mesh of the object itself). Each descriptions contains a set of tags and an array of actual", "s. The genericness of the descriptor model allows for models to come from a variety of sources (point cloud segmentation, 3D model warehouses and databases) with few-to-no restrictions. The main idea is to associate an appropriate", "and", "field with each descriptor to determine how the data should be treated. In a sense, the", "field can be thought up as a non-standard MIME type (PNG, Collada, but also", "as a type). Future goals of the project set out to create a standard set of accepted type fields. Below is a detailed description of the fields associated with a", ".", "The first design decision was to use a", "database for storage. Given the highly relational components associated with the world model (e.g.,", "and", "), it made sense to use such a database over other types of databases. For efficiency in searching and storage, the database schema itself is broken into finer grains than the APIs allow for. It is intended that developers make user of these higher-level APIs when dealing with the Spatial World Model as apposed to making raw SQL queries.", "The current implementation includes several layers of APIs. As mentioned previously, it is not intended for a developer to use the world model by directly making SQL queries. At the lowest level, the", "Python API should be used. This level of the API is responsible for talking SQL to the world model database and is able to make basic insertion and search queries while maintaining the correct structure. This level of the API allows for non-ROS processes to make use of the world model (another future goal of the project). By using an SQL connection between this library and the database, remote connections can be made and a central database can be used (such as one hosted in the cloud). This, of course, requires your server to allow remote SQL connections which is not ideal. Therefore, future plans hope to create a server-side API to allow for remote queries (think REST as an example but this would require polling). With such an API in place, the interface between the robot or client and the database could be made with this new service.", "Furthermore, a", "library is provided in", "to allow remote web clients to interact with the world model. This API currently uses", "and", "to communicate with the world mode; however, as discussed above, the eventual goal is to have a standard server-side API to communicate with directly instead of using ROS.", "Within ROS, the intended use of the APIs into the world model was to create a series of what are being called listener nodes. Such nodes listen to a set of defined topics, make the appropriate inferences on the information, and update the world model accordingly. Below are three examples included in", ".", "To allow for multiple robots, a notion of namespacing must be kept. To support this feature early on, this information is currently held inside of the", "of the instance. It is up to the developer to maintain this namespace. For example, the above listeners take an optional argument to define the namespace. If no namespace is given, it will default to the hostname of the machine the node is running on. In most cases, this is good enough since the hostname of the robot is usually a good namepsace. Then, when searching for things like a particular robot, we can do a tag search for", ". Future improvements should be made to make this clearer and enforce unique namespacing.", "One improvement to the current system would be to separate the", "array into its own separate database. The idea behind properties is to define relationships such as", "or", "between entities in the world model. Current thoughts are to point to entries within a graph database. By doing so, powerful search queries to can written such as \"give me all the objects inside the bedroom?\" or \"is the book on my bookshelf?\" in an efficient way.", "One large piece of the world model that is missing is the notice of affordances. The goal of the Spatial World Model is to not only keep track of particular instances of objects, but to also manage what types of actions can be taken on certain objects. For example, a door can be opened, a cup can be grasped, and a robot can grasp (assuming it has a gripper, of course). Furthermore, pre-conditions should also be stored here. For example, the cup must be on the table to be picked up (or any number of other conditions). This would rely on the implementation of the graph database described above. These types of attributes should be stored in a separate table in the database and linked to a particular", ".", "In addition to the affordances, a notion of activities, must be stored as well. Such a structure would be used to figure out how to perform such an action on such an object. For example, if you wanted to use a", "action on a coffee cup, the associated activity would be some action call to a grasping pipeline. Each activity can be thought of as a node with some kind of transition model incorporated to provide feedback and belief states. An updated diagram of the Spatial World Model would be the following:", "In addition to abstracting out the", "as defined above, several improvements are needed with respect to the instances. For one, belief states should be associated with most attributes. While the current", "does allow for this, beliefs about things just as timestamps are just as important.", "A second major component is a cleanser process for the database. Currently, descriptions can be linked to multiple instances. This is the main idea behind the descriptions itself. Additionally, these descriptions can potentially contain massive amounts of data (Collada models for example). If there are no longer any instances linked to a given description, it should be removed not only from the database itself, but from the disk as well (since the large data portions are kept in", ". Care should be taken to ensure thread safety in the removal.", "Perhaps the largest piece needed in the project is a more robust, efficient, and flexible server-side API for the world model. Currently, the", "Python API is used by the main ROS node and speaks SQL to the database. For many reasons, security being one, this is not ideal. Efforts should be made to create a server-side API that allows for multiple remote connections to interact with the world model. Not only would this still allow the robots to communicate with the world model, but clients could now directly connect to the world model instead of using", "as a \"proxy\". While at first glance it may seem appropriate, this API should not be response-based such as a REST API. A more robust socket-level connection should be made to allow for bi-directional communication. By standardizing a server-side interface, we can also create a more powerful query system. The protocol between clients and the server could include things like searching descriptions or descriptors without having to return the data associated with them. This allows clients to subscribe to changes in the world model without the need of polling. A diagram of the updated API levels is shown below.", "Discussions and contributions are welcome! To get involved, check out the", "for current feature requests and discussions.", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/staubli_val3_driver", "package": "staubli_val3_driver", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This is a VAL 3 based driver for use with CS8 controllers and Staubli 6-axis manipulators. See the", "for more information.", "For the generic ROS-Industrial tutorials, please see the ROS-Industrial", ".", "For questions related to the Staubli support or ROS-Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/tello_driver", "package": "tello_driver", "package_summary": ["The tello_driver package"], "package_details": ["Use GitHub to", ". [", "]", "Communicating with the Tello drone can be done either using official", "or one of the unofficial libraries. The unofficial libraries originated from the reverse-engineering the raw packages broadcasted by the Tello. This ROS package is build on top of the unofficial", "library. The", "library is used at this moment since it offers more functionalities than the official", "or any other unofficial library.", "Developing of the tello_driver ROS package is inspired by", ", which by now diverged considerately from the original work. Furthermore, development of this ROS package pursues not to modify the", "library, but instead apply any modification or addition to the ros_driver package in an encapsulated manner. This prevents breaking functionalities when updating the", "library.", "Main node running as interface for the", "library", "Converting gamepad input controls from", "to commands for", "Receive input from gamepad controller and publish into", "message"]},
{"url": "https://wiki.ros.org/turtlebot_exploration_3d", "package": "turtlebot_exploration_3d", "package_summary": [], "package_details": ["Please follow the turtlebot network", "to setup network between turtlebot and remote PC."]},
{"url": "https://wiki.ros.org/win_appupdater", "package": "win_appupdater", "package_summary": [], "package_details": ["Some scripts to help out with setting up the", "repositories, namely key signing."]},
{"url": "https://wiki.ros.org/katana_driver", "package": "katana_driver", "package_summary": [], "package_details": [": This will move the robot arm without any obstacle avoidance whatsoever, so if you run this on a physical arm, make sure the workspace of the robot is clear.", "has to be configured individually for each robot. At Osnabr\u00fcck University, we have Calvin, a robot that consists of a Volksbot base and a Katana arm. You can see instructions how to run the full", "stack in Gazebo, including motion planning, inverse kinematics, collision environment etc. on the", "wiki page.", "Use GitHub to", ". [", "]", "You should set your Katana type as an environment variable, for example in your", "/", ". At the moment, only the Katana 450 6M90A and the Katana 300 6M180 (experimental) are supported. Include one of the following lines:"]},
{"url": "https://wiki.ros.org/tf_conversions", "package": "tf_conversions", "package_summary": ["This package contains a set of conversion functions to convert\ncommon tf datatypes (point, vector, pose, etc) into semantically\nidentical datatypes used by other libraries. The conversion functions\nmake it easier for users of the transform library (tf) to work with\nthe datatype of their choice. Currently this package has support for\nthe Kinematics and Dynamics Library (KDL) and the Eigen matrix\nlibrary. This package is stable, and will get integrated into tf in\nthe next major release cycle (see roadmap)."], "package_details": ["We plan to replace this package with a more advanced template-based data conversion package, as part of the redesign of the", "API. See the", "for more details."]},
{"url": "https://wiki.ros.org/canopen_chain_node", "package": "canopen_chain_node", "package_summary": ["Base implementation for CANopen chains node with support for management services and diagnostics"], "package_details": ["This packages contains the ROS interface for", "and", ". It can be used as a stand-alone ROS node, but as well as a base class for profile specific ROS interfaces, e.g.", ".", "The bus settings consists of a CAN interface (", ") and the shared bus settings for", ".", "Each node (or in the defaults) can be passed a publish parameter with a list of object names. The topic types correspond to the object types, e.g. UNSIGNED16 to", ". It is meant for debugging or for simple CANopen interfaces, since it blocks the control loop. Each entry can have an exclamation mark appended that forces the driver to reread the object form the node in each step.", "The", "can be passed the diagnostic_period parameter in fractional seconds.", "This package provides a", "class that implements a", "interface and takes care of the parameter parsing and the life-cycle.", "It can be customized via its virtual interface, especially with"]},
{"url": "https://wiki.ros.org/tuw_marker_filter", "package": "tuw_marker_filter", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/stereo_wall_detection", "package": "stereo_wall_detection", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/osg_markers", "package": "osg_markers", "package_summary": ["osg_markers can be used to create Markers geometry in OSG."], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_gazebo", "package": "turtlebot3_gazebo", "package_summary": ["Gazebo simulation package for the TurtleBot3"], "package_details": []},
{"url": "https://wiki.ros.org/vicon_bridge", "package": "vicon_bridge", "package_summary": [], "package_details": ["All available subjects and segments are recognized automatically and are published as tf transform and", "as", ".", "Sometimes vicon data is too perfect", "This motivated", ", which adds different types of noise, adds delay or reduces the framerate to test how robots work with bad data.", "Then run", "to set the parameters. This is work in progress, suggestions are welcome."]},
{"url": "https://wiki.ros.org/summit_xl_control", "package": "summit_xl_control", "package_summary": [], "package_details": ["This package contains the launch and configuration files to spawn the joint controllers with the ROS controller_manager. It allows to launch the joint controllers for the Summit XL (4 axes skid steering + 2 axes ptz), Summit XL OMNI (4 axes skid steering, 4 axes swerve drive), Summit X-WAM (4 axes skid steering, 4 axes swerve drive, 1 linear axis for scissor mechanism). The Summit XL simulation stack follows the gazebo_ros controller manager scheme described in"]},
{"url": "https://wiki.ros.org/rc_visard_description", "package": "rc_visard_description", "package_summary": ["Visualization package for rc_visard"], "package_details": []},
{"url": "https://wiki.ros.org/world_canvas_msgs", "package": "world_canvas_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rmp_msgs", "package": "rmp_msgs", "package_summary": [], "package_details": ["contains message types for interacting with and receiving feedback from a Segway RMP.", "Newly proposed, mistyped, or obsolete package. Could not find package \"rmp_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/rmp_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/summit_xl_common", "package": "summit_xl_common", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", ", shared for real robot and simulation.", "This package contains the node that subscribes to /joy messages and publishes command messages for the robot platform including speed level control. The joystick output is feed to a mux (", ") so that the final command to the robot can be set by different components (move_base, etc.)"]},
{"url": "https://wiki.ros.org/asr_ism_visualizations", "package": "asr_ism_visualizations", "package_summary": ["This package provides visualization logic for ism data, e.g. visualization with marker in rviz."], "package_details": [":", "The", "package contains several classes for visualization of the ISM-datastructures. There are visualizations for the ISM itself, the pose prediction, the voting space, as well as for the reconstruction of the scene and basic visualizations of objects and object-overlays in RVIZ. It doesn't contain any nodes and its more like a library.", "Normally this package is used by another package like", "and provides no independent components.", "Only topics of dynamic reconfigure are being subscribed to. (e. g.", ")", "All generated markers of ISM-result-visualization, pose-prediction-visualization and voting-space-visualization are published (by default) on", "(msg-Type: Markerarray)"]},
{"url": "https://wiki.ros.org/siftgpu", "package": "siftgpu", "package_summary": [], "package_details": ["For more details go to the"]},
{"url": "https://wiki.ros.org/tf_keyboard_cal", "package": "tf_keyboard_cal", "package_summary": [], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/asr_direct_search_manager", "package": "asr_direct_search_manager", "package_summary": ["This package can be used to generate and manage poses for the direct mode of 3-D\n    object search. The direct mode is used as an opening procedure for Active Scene Recognition.\n    The poses will be generated so that they cover the current environment map.\n    There are different modes to generate these poses. One is based on a grid and a\n    second on a recording of the \"cropbox record\" mode in the asr_state_machine."], "package_details": [": the", "which are search at the moment", ":", ":", ": the path to the config.xml generated by the", ", which contains", "of the grid", ": the path to the initialized grid, which contains", "of the grid. Can be generated by the", "of the asr_state_machine", ": camera fiels of view angles (will be used in", ")", ": camera fiels of view angles (will be used in", ")", ": PTU angle free of vision obstacles (will be used in", ")", ": can be 1 for", ", 2 for", "and 3 for", ": the distance function to use. 1 for the service call", "of", "(accurate, slow) or 2: the euclidean distance (approximative, fast)", ": enables the use of prior knwolege by reordering the poses by", ", so that poses which have a higher chance to detect an object will be taken first. The reordering takes place on the basis of the", "from the current SQL-database", ": if the poses of the", "should be reordered with TSP (", "and", ")", ": the threshold when two positions of", "will be seen as approx equale. This will be used to filter poses depending on already seen viewports taken from other search modes (", ") The threshold for orientation will be /nbv/mHypothesisUpdaterAngleThreshold", ": remove all", "which have not at least this number of normals deleted while the poses were recorded", ": remove all", "which the robot can not reach (this was need due a bug in asr_next_best_view). It could also be neccessary if the colThresh (asr_next_best_viewparam) has changed since the recording of the poses", ": concatenate", "which are approx equale to one with multiple", "As a result the robot will move less.", ": the threshold when two", "of", "will be seen as approx equale for concatenating two", ":", ",", ",", ",", ":", ",", ",", ":", "The", "is used to manage the views for the direct mode of Active Scene Recognition. The direct search is one of the implemented mode in the 3-D object search we interrelated with scene recognition. The main goal of the direct search is to generate views which should cover the search space, i.e., the robot's environment. It provides a possibility to search for objects without prior knowledge. The direct search can be started in the", "with mode 1 or 3.", "One implementation is the grid mode. The grid can be generated with the", ". The idea is to devide the search space with a grid. The grid is made up of grid points which have an equidistant distance between each. On each grid point the asr_direct_search_manager generates a subset of views which are neccessary to cover the room around that grid point. The number of views depens on the size of the frustum.", "#goal definition", ": the command which should be executed:", "#result definition", ": the next", ": the next", "(belonging to the goalRobotPose) if present", ": the next pan to take", ": the next tilt to take", ": the PTU poses which are left for this goalRobotPose (just as information)", ": the", "which are left (just as information)", ": the remaining distance for the remainingRobotPoses to take (just as information)", ": if goalRobotPose is the same as the one from the call before", ": if there are no poses left at all", ": if there are poses left after this one, which are sorted based on the prior knwoledge", ": the searchedObjectTypesAndIds which were filtered. It will be filtered, if at the goalCameraPose were already some objects searched or if it is more likely to find a subset of objects", "This package is part of the active_scene_recognition. When using the", ", this node will be started automatically.", "Generating the views for the gridMode:", "Generating the views for the recordMode:", "To execute the direct search:"]},
{"url": "https://wiki.ros.org/kobuki_qtestsuite", "package": "kobuki_qtestsuite", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/static_transform_mux", "package": "static_transform_mux", "package_summary": ["A helper node that makes sure everybody knows about all static transforms, even if they are published by multiple publishers."], "package_details": ["This ROS node subscribes to", ", collects all the transforms that are ever published there, and re-sends a", "message that contains not only the transforms from the last publisher, but all transforms ever encountered.", "This is a workaround for e.g.", ", or for anybody else who", "needs to have multiple static transform publishers in the system."]},
{"url": "https://wiki.ros.org/pointcloud_tools", "package": "pointcloud_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kni", "package": "kni", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_introspection", "package": "ros_introspection", "package_summary": ["The ros_introspection package"], "package_details": []},
{"url": "https://wiki.ros.org/stdr_gui", "package": "stdr_gui", "package_summary": [], "package_details": ["The", "package provides a Graphical User Interface for", "developed with QT4.", "A detailed description of", "can be examined through the following tutorials:"]},
{"url": "https://wiki.ros.org/rail_pick_and_place_tools", "package": "rail_pick_and_place_tools", "package_summary": [], "package_details": ["The", "package contains rviz plugins to aid in the grasp demonstration collection and model generation process.  This package also contains launch files for easier running of this process.", "To install the", "package, you can install from source with the following commands:", "The", "package contains a launch file for starting up the backend necessary for grasp demonstration collection and object model generation, as well as a frontend that launches rviz with the relevant panels and topics shown:"]},
{"url": "https://wiki.ros.org/turtlebot_arm_moveit_config", "package": "turtlebot_arm_moveit_config", "package_summary": [], "package_details": ["The package contains some tweaks and addition to the automatically generated one. Refer to", "if you want to generate the", "! configuration by yourself."]},
{"url": "https://wiki.ros.org/wge100_camera", "package": "wge100_camera", "package_summary": ["A ROS node and assorted tools to provide access to the WGE100\n    camera used in the forearms and the stereo cameras of the PR2\n    robot."], "package_details": ["The Willow Garage 100 Mbps Ethernet (WGE100) camera is a 752x480 Ethernet camera developed for the PR2 robot. The PR2's narrow stereo camera is a monochrome WGE100, while its wide stereo camera and forearm cameras are in color. This package contains the", ", a ROS driver for a monocular WGE100 camera, the", "node, which allows two cameras in a stereo pair to be configured from one centralized location, and a suite of", "to manage the camera.", "Except for the", "and", "tools, which can be used at any time, the WGE100 tools are not designed for concurrent access to the camera.", "The timestamps returned by the", "are with respect to the end of the exposure. The timestamps can be produced in one of two ways:", "When working with a WGE100 camera, the user needs to identify the camera she wishes to work with.  Cameras are identified using URLs, which can refer either to the camera's serial number or to its descriptive name (set using", "). If there is only one camera present, a URL can indicate that whatever camera is found should be used.", "If a URL matches more than one camera, none of them will be selected, and an error will be reported. This situation cannot happen with a", "URL as camera serial numbers are unique.", "When an IP address is specified, WGE100 camera tools will configure the camera to use that address before they try to work with it. The IP address that is specified using @ will get reset each time a new tool is used. To set a camera's IP address permanently, use the", "tool.", "In some cases, a single camera may be visible on multiple interfaces, or cameras with the same name may be visible on different network interfaces. In this case, an interface name can be included in the camera URL to force a particular interface to be used for communication. An interface name is introduced with the", "sign. For example, on the PR2, only the", "interface is searched to avoid potential conflicts with identically named cameras on the wan0 interface:", "The", "tool uses a broadcast packet to find cameras on the network. It can be run on a single network interface:", "The IP address that is reported by the", "tool is the currently configured address for the camera. This may be different from the IP address stored in the camera's flash, and to which the camera defaults when it is reset. This IP may or may not be valid for the interface on which the camera is located, and it is quite possible that you will not be able to communicate with the camera at this particular IP address.", "Sometimes a camera can be seen from multiple interfaces. The", "tool only reports the first interface on which a response is seen. The camera can nevertheless be configured to run from an interface other than the one on which it was reported.", "The camera name and IP address that are stored in the camera's flash can be accessed using the", "tool. With a single camera URL argument, set_name reports the current settings.", "The camera intrinsics that are stored in the camera's flash can be accessed using the", "tool. With a single camera URL argument, set_name reports the current settings.", "In general, calibration of the camera and uploading of the parameters should be done through the", "package.  These programs will perform the calibration, and make the service call to flash the intrinsics back onto the camera.", "The camera can be reset using the", "command, which takes a single camera_url argument.", "Note: The", "tool currently has the same effect as", ". In future firmware versions", "will always cause the camera FPGA to reconfigure itself, whereas", "may do a softer reset that resets all components without reconfiguring the FPGA.", "For information on contents of the WGE100 flash memory, you may consult", "."]},
{"url": "https://wiki.ros.org/realsense_camera", "package": "realsense_camera", "package_summary": [], "package_details": ["This package provides ROS node(s) for using the Intel\u00ae", "\u2122 R200, F200 and SR300 cameras.", "This package requires the", "package as the underlying camera drivers for all Intel\u00ae", "\u2122 cameras.", "installing the realsense-camera package, follow the", ".", "This will also install the required ros-<*distro*>-librealsense library on your system.", "If a user needs to debug this package or contribute changes/bug fixes to the package, only then should the package need to be built from source. Please closely follow the directions provided on the", "page.", "To ensure you camera has the most current, supported firmware, please review the", ". If the camera requires a firmware upgrade, please refer to the", "page.", ": Currently there is no native Linux tool for FW updates; all updates require a system with Microsoft Windows.", "Please", "concerning this package to the realsense_camera", "Issues.", "See the", "for a complete list."]},
{"url": "https://wiki.ros.org/turtlebot_arm_block_manipulation", "package": "turtlebot_arm_block_manipulation", "package_summary": [], "package_details": ["This", "will walk you through running this demo on your own TurtleBot.", "This package requires almost all the others on", "stack. In particular,", "from the", "package and", "and", "from", "have to be running. See the", "launch file for more details.", "Additionally, it requires an external kinect to be running and calibrated to the robot. Refer to", "package to learn how to calibrate your camera."]},
{"url": "https://wiki.ros.org/leg_detector", "package": "leg_detector", "package_summary": ["Leg Detector using a machine learning approach to find leg-like patterns of laser scanner readings."], "package_details": ["This leg detector package takes", "s as input and uses a machine-learning-trained classifier to detect groups of laser readings as possible legs. Sadly, the training dataset has been lost to Willow Garage history (it wasn't even available before they closed). The code is in the repository for retraining, but is unsupported at this time.", "This node will publish", "s for the individual legs, and it can also attempt to pair the legs together and publish their average as an estimate of where the center of one person is as a", ". The node will also optionally publish visualization Marker messages to indicate where detections happened.", "In the seeded mode, the algorithm will use another source of PositionMeasurement messages to guide the algorithm to possible locations for people. Historically, this has been used with a face detection algorithm that alerts the leg_detector that there is probably a pair of legs underneath. This mode is enabled using the", "parameter."]},
{"url": "https://wiki.ros.org/warthog_viz", "package": "warthog_viz", "package_summary": ["Visualization launchers and helpers for Warthog."], "package_details": ["This package provides launchers and", "configurations to assist with visualizing real or simulated", "from a desktop environment. For help getting your desktop environment set up to use with Warthog, see the", ".", "For more information on simulating Warthog, see", ".", "For more examples, see", "."]},
{"url": "https://wiki.ros.org/sr_kinematics", "package": "sr_kinematics", "package_summary": [], "package_details": ["sr_kinematics currently contains a specific analytical inverse kinematics for the", "hand. Currently, only the 4 fingers have an IK solution, the thumb will come later. The solution takes care of the coupled joint J1/J2 (assuming it is 1:1) and accepts 3D requests (instead of 6D). There is an approximation in this solution.", "The node proposes the same services and parameters as the", "NOTE that", "parameter is used to detect singularities for J4 joint."]},
{"url": "https://wiki.ros.org/uos_diffdrive_teleop", "package": "uos_diffdrive_teleop", "package_summary": ["uos_diffdrive_teleop"], "package_details": []},
{"url": "https://wiki.ros.org/turtlesim_dash_tutorial", "package": "turtlesim_dash_tutorial", "package_summary": [], "package_details": ["This package is designed to provide a quick and dirty tutorial on how to quickly create a Web UI for a ROS environment with", ". As backbone for this tutorial, we'll use ROS's", ".", "The default launch file included in this package,", "brings up a", "environment and starts", "'s", "node. As mentioned in the documentation for", ", the node is designed to control the simulated turtlebot so that it traces out a polygon of a specified radius with the desired number of edges.", "The launch file also starts a", ". On navigating to that URL, you should see a web page like so:", "Here is an example of the page as the turtlebot is executing a", ":", "Creates a", "server on the port 8080; navigate to", "in order to view it."]},
{"url": "https://wiki.ros.org/ridgeback_navigation", "package": "ridgeback_navigation", "package_summary": ["Launch files and code for autonomous navigation of the Ridgeback"], "package_details": ["The ridgeback_navigation package contains configuration and launch files for running", "on", "."]},
{"url": "https://wiki.ros.org/turtlebot_concert", "package": "turtlebot_concert", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xbot_msgs", "package": "xbot_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tf", "package": "tf", "package_summary": ["tf is a package that lets the user keep track of multiple coordinate\nframes over time. tf maintains the relationship between coordinate\nframes in a tree structure buffered in time, and lets the user\ntransform points, vectors, etc between any two coordinate frames at\nany desired point in time."], "package_details": ["is designed both as a command-line tool for manual use, as well as for use within", "files for setting static transforms. For example:", "is a graphical debugging tool that creates a PDF graph of your current transform tree.", "tf comes with a plugin for", "that automatically runs whenever you run", ". This plugin will analyze your current tf configuration and attempt to find common problems. To run, just invoke", "normally:", "You want to", "what tf can do instead of just reading about it? Check out the", ".", "A robotic system typically has many 3D", "that change over", ", such as a world frame, base frame, gripper frame, head frame, etc. tf keeps track of all these frames over time, and allows you to ask questions like:", "tf can operate in a", ". This means all the information about the coordinate frames of a robot is available to all ROS components on any computer in the system.  There is", "of transform information.", "For more information on the design see", "There is a paper on tf presented at TePRA 2013", "We created a set of", "that walk you through using tf, step by step. You can get started on the", "tutorial. For a complete list of all tf and tf-related tutorials check out the", "page.", "Once you are finished with the basic tutorials, you can move on to learn about tf and time. The tf and time tutorial", "teaches the basic principles of tf and time. The advanced tutorial about tf and time", "teaches the principles of time traveling with tf.", "Although tf is mainly a code library meant to be used within ROS", ", it comes with a large set of command-line tools that assist in the debugging and creation of tf coordinate frames. These tools include:", "You may also wish to use the", "node, which is a utility node for remapping coordinate transforms.", "Therefore an helpful shortcut to add in your", "is:", "NOTE: See also", "that allows dynamic introspection of the frames."]},
{"url": "https://wiki.ros.org/topic_proxy", "package": "topic_proxy", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/stereo_msgs", "package": "stereo_msgs", "package_summary": ["stereo_msgs contains messages specific to stereo processing, such as disparity images."], "package_details": [": this package is now part of", ".  In previous releases, it was part of", ".", "Newly proposed, mistyped, or obsolete package. Could not find package \"stereo_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/stereo_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/blort", "package": "blort", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_follower", "package": "turtlebot_follower", "package_summary": [], "package_details": ["Before running the follower, make sure your TurtleBot is setup:", "To start the follower, open an SSH terminal on the TurtleBot laptop, and run the following command:", "The follower should now be running. To initiate following, walk in front of the TurtleBot. Then, slowly walk away from the TurtleBot. The robot should move forward. Moving close to the TurtleBot will cause it to back away. Moving slowly to the left or right will cause the TurtleBot to turn. To stop the robot from following, walk quickly away from the robot.", "To get more details about running TurtleBot follower, please take a look to the"]},
{"url": "https://wiki.ros.org/naoqi_bridge_msgs", "package": "naoqi_bridge_msgs", "package_summary": ["The naoqi_bridge_msgs package provides custom messages for running Aldebaran's robot such as NAO and Pepper. See the packages nao_robot and pepper_robot for details."], "package_details": []},
{"url": "https://wiki.ros.org/rosatomic", "package": "rosatomic", "package_summary": ["rosatomic provides the C++11-style atomic operations by pulling symbols from the proposed Boost.Atomic\n     package into the ros namespace.  Once C++11-style atomics (std::atomic) are available from compilers, rosatomic will\n     conditionally use those instead."], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_gazebo", "package": "kobuki_gazebo", "package_summary": [], "package_details": ["Refer to the Kobuki's", "tutorial."]},
{"url": "https://wiki.ros.org/turtlebot_arm_ikfast_plugin", "package": "turtlebot_arm_ikfast_plugin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xbot", "package": "xbot", "package_summary": [], "package_details": ["Introduction:", "Tutorial:"]},
{"url": "https://wiki.ros.org/tf2", "package": "tf2", "package_summary": ["tf2 is the second generation of the transform library, which lets\n    the user keep track of multiple coordinate frames over time. tf2\n    maintains the relationship between coordinate frames in a tree\n    structure buffered in time, and lets the user transform points,\n    vectors, etc between any two coordinate frames at any desired\n    point in time."], "package_details": ["is the core of a group of packages which form the 2nd generation of", ".  There are three types of packages.", "implements templated datatype support. This allows the core packages to have minimal dependencies and there be packages which add support for converting to and from different datatypes as well as transforming those data types. Please see", "overview, and", "for how to use tf2 with different datatypes.", "does have an internal datatypes which are based on", "'s LinearMath library. However it's recommended to use a fully supported math datatype which best supports your application.", "conversion methods also support converting between and transforming between multiple different datatypes too.", "In previous versions there was a concept of a", "which would be prepended to the frame name using a", "separator. A leading slash used to indicate that it had already been prefixed. For backwards compatibility tf2 will strip any leading", "character.", "provides basic geometry data types, such as", ",", ",", ",", ". These data types support linear algebra operations between each other.", "You want to", "what tf can do instead of just reading about it? Check out the", ".", "A robotic system typically has many 3D", "that change over", ", such as a world frame, base frame, gripper frame, head frame, etc. tf2 keeps track of all these frames over time, and allows you to ask questions like:", "tf2 can operate in a", ". This means all the information about the coordinate frames of a robot is available to all ROS components on any computer in the system.  Tf2 can operate with a central server that contains all transform information, or you can have every component in your distributed system build its own transform information database.", "For more information on the design see", "There is a paper on tf presented at TePRA 2013", "We created a set of", "that walk you through using tf2, step by step. You can get started on the", "tutorial. For a complete list of all tf2 and tf2-related tutorials check out the", "page.", "Once you are finished with the basic tutorials, you can move on to learn about tf2 and time. The tf2 and time tutorial", "teaches the basic principles of tf2 and time. The advanced tutorial about tf2 and time", "teaches the principles of time traveling with tf2.", "If you are looking for an easy tool to manually tweak tf transforms, such as for quick calibration-by-eye tuning, try", "The", "described the high level design of the tf2 library.", "At it's core", "relies on the", "which can be conveniently correlated to ROS messages which have a", ".", "Coordinate frames in ROS are identified by a string", "in the format lower case underscore separated. This string has to be unique in the system. All data produced can simply identify it's", "to state where it is in the world.", "The concept of", "is not scoped in the same way as", ". In particular, namespacing a specific subpart of a computation graph does not change the physical layout which the", "tree represents. Because of this", "s do not follow namespace remapping rules. It is common to support a", "to allow changing", "s used in algorithms.", "For use cases with multiple robots it is generally recommended to use multiple masters and forward specific tf information between the robots. There are several different methods of implementing bridges between masters. For more information please see the", ".", "These packages provide the primary interface for developers using", ".", "For more information about migrating from", "see"]},
{"url": "https://wiki.ros.org/ar_track_alvar", "package": "ar_track_alvar", "package_summary": ["This package is a ROS wrapper for Alvar, an open source AR tag tracking library."], "package_details": []},
{"url": "https://wiki.ros.org/asmach", "package": "asmach", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_example", "package": "sr_example", "package_summary": ["sr_example is an example of a real package interfaced with our robot. Please refer to the tutorial\n    Creating a package to interact with our robots."], "package_details": ["Please refer to", "for more information."]},
{"url": "https://wiki.ros.org/trac_ik_examples", "package": "trac_ik_examples", "package_summary": ["This package contains the source code for testing and comparing trac_ik"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_core_apps", "package": "turtlebot_core_apps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/hostapd_access_point", "package": "hostapd_access_point", "package_summary": [], "package_details": [":", "A ROS node for starting and controlling a hostapd-based access point. This node works with wifi adapters that have", "-compatible drivers which support master mode (see", "for more information).", "This is an example that shows how to set up an access point and control its parameters using the", "interface.", "The following launch file starts an AP node on the", "interface and the", ":", "The desired configuration is selected: mode", ", channel 44, WPA security with the chosen password, a TX power level of 8 dBm and a TX bitrate of 24Mbit/s. Next the", "checkbox is checked at the AP is started:", "This script is useful for setting up a", "-based setup. mac80211_hwsim is a 802.11 radio simulator. The script takes two parameters:", "If the mac80211_hwsim is not loaded or if the number of radios it has currently spawned is smaller than", "then it is re-loaded with the proper radio count. The script prints to its output the name of the", "-th interface.", "For example (this is taken from a real setup), suppose that the system has a real wireless interface with name", "and we need to spawn three virtual interfaces. Their names will be", ",", "and", ".", "Using", ":", "The script can be used to launch nodes on the", "with roslaunch. The following example, launches two nodes on the first and second mac80211_hwsim interfaces while ensuring that there are at least three total interfaces:"]},
{"url": "https://wiki.ros.org/willow_maps", "package": "willow_maps", "package_summary": ["Holds maps of Willow Garage that can be used for a number of different applications."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_navigation_global", "package": "pr2_navigation_global", "package_summary": ["This package holds XML files for running the"], "package_details": ["This package contains configuration files for the", "and", "nodes meant to be run in an application that requires global navigation with a pre-specified static map. This package also includes launch files that bring up", "and", "with global navigation specific configurations."]},
{"url": "https://wiki.ros.org/jog_controller", "package": "jog_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tensorflow_ros_cpp", "package": "tensorflow_ros_cpp", "package_summary": ["Catkin-friendly C++ bindings for the tensorflow package."], "package_details": ["are available for each of the options.", "See the usage example at", ".", "A comprehensive list of compatible options for various OSes and ROS distros is available", ".", "Ubuntu systems starting with 16.04 (Xenial) are using the new C++11 ABI for all system libraries. Until", "gets resolved (if ever!), the pip-distributed Tensorflow is built  againts an older C++ ABI, which is incompatible with the C++11 ABI. This  means linking to the Tensorflow library will fail on such systems and  there's no way around it.", "An example of this approach can be found at", "."]},
{"url": "https://wiki.ros.org/laser_scan_sparsifier", "package": "laser_scan_sparsifier", "package_summary": ["The laser_scan_sparsifier takes in a LaserScan message and sparsifies it."], "package_details": ["The", "package is used to downsample", "messages.", "Two drivers are available:", "and", ". Their parameters and topics are identical.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/wheeled_robin_rviz_launchers", "package": "wheeled_robin_rviz_launchers", "package_summary": [], "package_details": ["This package provides several launch files for", "to visualize", ".", "First launch the robot either in real or faked mode and start the Kinect drivers (see Getting Started section in", ")."]},
{"url": "https://wiki.ros.org/ntpd_driver", "package": "ntpd_driver", "package_summary": ["ntpd_driver sends TimeReference message time to ntpd server"], "package_details": ["Just add to", ":", "Add this to", ":"]},
{"url": "https://wiki.ros.org/waypoint_generator", "package": "waypoint_generator", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_follower", "package": "turtlebot3_follower", "package_summary": ["The follower demo was implemented using a 360 Laser Distance Sensor LDS-01. The classification algorithm is used based on previous fitting with samples of person and obstacles positions to take actions. It follows someone in front of the robot within a 50 centimeter range and 140 degrees."], "package_details": []},
{"url": "https://wiki.ros.org/toposens_description", "package": "toposens_description", "package_summary": ["3D models of the sensor for visualization."], "package_details": []},
{"url": "https://wiki.ros.org/ridgeback_control", "package": "ridgeback_control", "package_summary": ["Controllers for Ridgeback"], "package_details": ["'s mobility is controlled by mecanum_drive_controller."]},
{"url": "https://wiki.ros.org/schunk_libm5api", "package": "schunk_libm5api", "package_summary": ["This package wraps the libm5api to use it as a ros dependency. Original sources from http://www.schunk-modular-robotics.com/fileadmin/user_upload/software/schunk_libm5api_source.zip."], "package_details": []},
{"url": "https://wiki.ros.org/jsk_gui_msgs", "package": "jsk_gui_msgs", "package_summary": ["jsk_gui_msgs"], "package_details": []},
{"url": "https://wiki.ros.org/pheeno_ros", "package": "pheeno_ros", "package_summary": [], "package_details": ["Documentation for our package can be found", ". We will also be adding documentation to this ROS page in the coming weeks."]},
{"url": "https://wiki.ros.org/rtctree", "package": "rtctree", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/octomap_msgs", "package": "octomap_msgs", "package_summary": ["This package provides messages and serializations / conversion for the", "."], "package_details": []},
{"url": "https://wiki.ros.org/graph_rviz_plugin", "package": "graph_rviz_plugin", "package_summary": [], "package_details": ["Documentation is here:"]},
{"url": "https://wiki.ros.org/vigir_pluginlib_msgs", "package": "vigir_pluginlib_msgs", "package_summary": [], "package_details": ["The", "package provides basic message definition needed for inter-process communication via ROS. See", "."]},
{"url": "https://wiki.ros.org/kdl_parser_py", "package": "kdl_parser_py", "package_summary": ["The Kinematics and Dynamics Library (KDL) defines a tree structure\n   to represent the kinematic and dynamic parameters of a robot\n   mechanism.", "provides Python tools to construct a KDL\n   tree from an XML robot representation in URDF."], "package_details": []},
{"url": "https://wiki.ros.org/costmap_2d", "package": "costmap_2d", "package_summary": ["This package provides an implementation of a 2D costmap that takes in sensor\n        data from the world, builds a 2D or 3D occupancy grid of the data (depending\n        on whether a voxel based implementation is used), and inflates costs in a\n        2D costmap based on the occupancy grid and a user specified inflation radius.\n        This package also provides support for map_server based initialization of a\n        costmap, rolling window based costmaps, and parameter based subscription to\n        and configuration of sensor topics."], "package_details": ["The", "package provides a configurable structure that maintains information about where the robot should navigate in the form of an occupancy grid. The costmap uses sensor data and information from the static map to store and update information about obstacles in the world through the", "object. The", "object provides a purely two dimensional interface to its users, meaning that queries about obstacles can only be made in columns. For example, a table and a shoe in the same position in the XY plane, but with different Z positions would result in the corresponding cell in the", "object's costmap having an identical cost value. This is designed to help planning in planar spaces.", "As of the Hydro release, the underlying methods used to write data to the costmap is fully configurable. Each bit of functionality exists in a layer. For instance, the static map is one layer, and the obstacles are another layer. By default, the obstacle layer maintains information three dimensionally (see", "). Maintaining 3D obstacle data allows the layer to deal with marking and clearing more intelligently.", "The main interface is", "which maintains much of the ROS related functionality. It contains a", "which is used to keep track of each of the layers. Each layer is instantiated in the", "using", "and is added to the", ". The layers themselves may be compiled individually, allowing arbitrary changes to the costmap to be made through the C++ interface. The", "class implements the basic data structure for storing and accessing the two dimensional costmap.", "While each cell in the costmap can have one of 255 different cost values (see the", "section), the underlying structure that it uses is capable of representing only three. Specifically, each cell in this structure can be either free, occupied, or unknown. Each status has a special cost value assigned to it upon projection into the costmap. Columns that have a certain number of occupied cells (see", "parameter) are assigned a", "cost, columns that have a certain number of unknown cells (see", "parameter) are assigned a", "cost, and other columns are assigned a", "cost.", "The costmap performs map update cycles at the rate specified by the", "parameter. Each cycle, sensor data comes in, marking and clearing operations are perfomed in the underlying occupancy structure of the costmap, and this structure is projected into the costmap where the appropriate cost values are assigned as described", ". After this, each obstacle inflation is performed on each cell with a", "cost. This consists of propagating cost values outwards from each occupied cell out to a user-specified inflation radius. The details of this inflation process are outlined", ".", "In order to insert data from sensor sources into the costmap, the", "object makes extensive use of", ". Specifically, it assumes that all transforms between the coordinate frames specified by the", "parameter, the", "parameter, and sensor sources are connected and up-to-date. The", "parameter sets the maximum amount of latency allowed between these transforms. If the", "tree is not updated at this expected rate, the", "stops the robot.", "There are two main ways to initialize a", "object. The first is to seed it with a user-generated static map (see the", "package for documentation on building a map). In this case, the costmap is initialized to match the width, height, and obstacle information provided by the static map. This configuration is normally used in conjunction with a localization system, like", ", that allows the robot to register obstacles in the map frame and update its costmap from sensor data as it drives through its environment.", "The second way to initialize a", "object is to give it a width and height and to set the", "parameter to be true.  The", "parameter keeps the robot in the center of the costmap as it moves throughout the world, dropping obstacle information from the map as the robot moves too far from a given area. This type of configuration is most often used in an odometric coordinate frame where the robot only cares about obstacles within a local area."]},
{"url": "https://wiki.ros.org/rosmon", "package": "rosmon", "package_summary": ["Node launcher and monitor for ROS. rosmon is a replacement\n\t\tfor the roslaunch tool, focused on performance, remote\n\t\tmonitoring, and usability."], "package_details": ["rosmon is a drop-in replacement for the venerable", "tool. It offers some interesting features both for monitoring and debugging:", "The", "specification is complex and a bit vague, so you can expect some differences. Bug reports are welcome! Known differences include:", "For additional information and rosmon extensions not supported by roslaunch see", ".", "If you just need the rosmon CLI and don't require the", "rqt plugin, you can install the smaller package", "instead.", "rosmon can also be controlled remotely using an", "plugin, which uses rosmon's ROS interface. The context menu offers starting and stopping control. Additionally collected statistics (CPU and memory usage) are displayed."]},
{"url": "https://wiki.ros.org/base_local_planner", "package": "base_local_planner", "package_summary": ["This package provides implementations of the Trajectory Rollout and Dynamic Window approaches to local robot navigation on a plane. Given a plan to follow and a costmap, the controller produces velocity commands to send to a mobile base. This package supports both holonomic and non-holonomic robots, any robot footprint that can be represented as a convex polygon or circle, and exposes its configuration as ROS parameters that can be set in a launch file. This package's ROS wrapper adheres to the BaseLocalPlanner interface specified in the", "package."], "package_details": ["(", ", default: 2.5)", "(", ", default: [-0.3, -0.1, 0.1, 0.3])", "(", ", default: 0.05)", "(", ", default: 1.0)", "(", ", default:", ")", "(", ", default: 0.05)", "(", ", default:", ")", "The", "package provides a controller that drives a mobile base in the plane.  This controller serves to connect the path planner to the robot.  Using a map, the planner creates a kinematic trajectory for the robot to get from a start to a goal location. Along the way, the planner creates, at least locally around the robot, a value function, represented as a grid map.  This value function encodes the costs of traversing through the grid cells.  The controller's job is to use this value function to determine dx,dy,dtheta velocities to send to the robot.", "The groovy release of ROS includes a new implementation of the", "package. The implementation attempts to be more modular, to allow easier creation of custom local planners while reusing a lot of code. The code base of base_local_planner has been extended with several new headers and classes.", "The interfaces and classes below capture the generic local planning principles allowing many instantiations. It should be possible to create custom local planners using the", "as template and just adding own cost functions or trajectory generators.", "This interface describes a Generator which may generate a finite or infinte number of trajectories, returning a new one on each invocation of", ".", "The", "class can generate trajectories described in the overview, using either the trajectory rollout or the DWA principle.", "This interface contains most importantly", ", which takes a trajectory and returns a score. A negative score means the trajectory is invalid. For positive value, the semantics are that a trajectory with a lower score is preferrable to one with a higher score with respect to this cost function.", "The", "package ships with some cost functions used on the PR2, described below.", "This is a simple implementation of a trajectory search, taking a", "and a list of", ". It will invoke", "until the generator stops generating trajectories. For each, trajectory, it will loop over the list of cost functions, adding up their positive values or aborting the scoring if one cost function returns a negative value.", "The", "is a Controller that can be used as soon as the robot is close enough to the goal. The Controller will then just perform a full stop and a rotation on the spot towards the goal orientation, regardless of whether the robot position after the full stop leads the robot outside the goal position tolerance.", "The", "object is a", "for a", "object that exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "There are a large number of ROS", "that can be set to customize the behavior of the", "wrapper. These parameters are grouped into several categories: robot configuration, goal tolerance, forward simulation, trajectory scoring, oscillation prevention, and global plan.", "The following parameters are only used if", "is set to true:", "The", "provides implementations of the DWA and Trajectory Rollout algorithms described earlier. In order to use the", "with ROS, please use the", ". It is not recommended to use the", "on its own.", "The C++ API is stable. However, it is recommended that you use the", "instead of using the", "on its own."]},
{"url": "https://wiki.ros.org/adhoc_communication", "package": "adhoc_communication", "package_summary": [], "package_details": [":      srv", ":        sendQuaternion.srv", ":", ": ad_hoc_communication.cpp", ": ad_hoc_communication.cpp", ": publishPacket", "The node", "allows you to exchange data over an ad-hoc network protocol via dynamic source routing. The package allows you to exchange data over serveral roscores. The node will send the data to the destination robot and publish the message on the destination on a given topic. The routing is done with the hostname of the robots.", "One-to-Many communication. Every robot has its own multicast group, which will be created when the", "node is starting. The name of the group will be \"", "\" plus the hostname. If a robots hostname is \"", "\", its multicast group is called \"", "\". All other robots can join a group with the service", ". All members of a group can send data within this group.", "You may obtain the paper from", "or search in", ".", "It's", "that the node always runs with root rights because the protocol is implement using raw sockets requiring root.", "Mark node to automatically run as root by setting the SUID bit:", "To send custom messages you just need to serialize a message to a string and then send it with the service", ". To serialize any type of ROS message you can use this function:", "Include the service in", "Function:", "Service name is", ".", "Adapt the function", "that the new payload type will be published. To deserialize the message, the function from Step 4 is used."]},
{"url": "https://wiki.ros.org/tuw_multi_robot_router", "package": "tuw_multi_robot_router", "package_summary": ["This package contains a MultiRobotRouter using Prioritized Planning in Combination with a collision resolution algorithm to find a routing tabel for a large number of robots."], "package_details": ["(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", "default: \"\")", "(", "default: \"true\")", "(", "default: \"true\")", "(", "default: \"true\")", "(", "default: \"10.0\")", "(", "default: \"10.0\")", "(", "default: \"false\")", "(", "default: \"Avoidance\")", "(", "default: \"use_voronoi_goal\")", "(", "default: \"standard_router\")", "(", "default: \"1\")", "Use GitHub to", ". [", "]", "The Multi Robot Mode is the default mode. The planner listens to", "see how many robots are online and available for planning. A list of goals can be send to", "Since the results generated for these scenarios are interdependent, the given routes have to be executed in a synchronized fashion. Therefore, the Router publishes a tuw_multi_robot_msgs/Route containing preconditions, when a robot is allowed to enter a segment. Additionally a unsynchronized version via nav_msgs/Path is published for every robot."]},
{"url": "https://wiki.ros.org/rb1_base_description", "package": "rb1_base_description", "package_summary": [], "package_details": ["-", "In this folder you will find the launch files ready to be executed", "-", "In this folder you will find the STL files of the different parts of the robots", "-", "In this folder you will find the final description of the robot, where all the parts are integrated", "-", "Here you will find the different possible parts of the robot. Each one is a xacro file that will be included in the final description", "To view and manipulate the non-fixed joints in", ", install the package and execute the following command:", "In case you want to change the robot's urdf, this can be found inside the", "folder."]},
{"url": "https://wiki.ros.org/octomap_server", "package": "octomap_server", "package_summary": ["octomap_server loads a 3D map (as Octree-based OctoMap) and distributes it to other nodes in a compact binary format. It also allows to incrementally build 3D OctoMaps, and provides map saving in the node octomap_saver."], "package_details": ["and", "offer a dynamic_reconfigure interface to change the displayed map resolution on the fly (since version 0.3.8). Note that this will not change the resolution of the underlying", ", but only of the published marker / collision topics (e.g. for visualization).", "General information about OctoMap is available at", "and in the publication", "by A. Hornung, K. M. Wurm, M. Bennewitz, C. Stachniss, and W. Burgard (Autonomous Robots Journal, 2013).", "Please cite our paper if you use OctoMap in your research.", "Use the octomap", "to report bugs or request features. For questions (and FAQ), check", "."]},
{"url": "https://wiki.ros.org/force_sensor_handler", "package": "force_sensor_handler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ur5_moveit_config", "package": "ur5_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the ur5 with the MoveIt Motion Planning Framework"], "package_details": ["This package is part of the", "program. It is the", "! configuration for the UR5 arm, generated automatically by the", "Setup Assistant.", "Install the package from package management, and run the MoveIt! planning demo:", "This is not a real simulation, just a demonstration of the planning capability and the MoveIt! and RViz integration. For true simulation of a UR5, see the", "package.", "See also the relevant sections in the", "on Github."]},
{"url": "https://wiki.ros.org/euscollada", "package": "euscollada", "package_summary": ["euscollada"], "package_details": ["and", "Documentation is available", ".", "Use trac to report", "or", "."]},
{"url": "https://wiki.ros.org/stage", "package": "stage", "package_summary": ["Mobile robot simulator http://rtv.github.com/Stage"], "package_details": ["For detailed documentation on the Stage .world file format, consult the", ",", "or", "."]},
{"url": "https://wiki.ros.org/win_pymercurial", "package": "win_pymercurial", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/canopen_motor_node", "package": "canopen_motor_node", "package_summary": ["canopen_chain_node specialization for handling of canopen_402 motor devices. It facilitates interface abstraction with ros_control."], "package_details": ["The objects used in the conversion functions and the drive modes should be mapped to PDOs for best performance.", "The canopen_motor_node package provides a", "interface to [canopen_402]] compliant motors. It is based on", "and inherits all its interfaces, so this site just focuses on the additional interfaces.", "The node includes a", "instance that can be used to spawn", "compliant controllers.", "Depending on the motor device different interfaces are support.", "For each joint a", "is registered with the position, velocity and effort of the specific drive. The actual value is determined by the conversion functions.", "The output from the controller is limited by", "and not passed directly to the motor.", "The limits can be read from URDF or the", ":", ".", "The driver features", "based conversion functions.", "In addition to the predefined", "and", ", the following functions are available:", "Further two constants are defined for convenience:", "and", ".", "The conversion functions from ROS the device units can read the commands from the respective", ",", "and", "variables.", "The conversion functions from device to ROS supports an extended notion with obj prefixes: E.g.", "will read the actual position and", "will read  the gear ration nominator.", "The basic configuration is described in", ".", "For the canopen_motor_node to work each node is given a", "parameter that defaults to the CANopen node name and is used as joint name in the", "interfaces.", "For each motor node a", "can be specified which is used to load a motor plugin with", ", it defaults to the", "implementation.", "All settings contained in the 'motor_layer' parameter will be passed to the motor layer instance.", "In summary the following parameters are supported in", "section and per node:", "The canopen_motor_node exposes the ROS interfaces of", ".", "In addition the interfaces of", "are available after initialization.", "However, the controller_manager is stopped when shutdown service ist called.", "The", "will read its limits from the URDF and from the ParameterServer. The latter takes precedence but does not support soft limits.", "The current implementation does not expose a C++ API, but it is planned for the future:"]},
{"url": "https://wiki.ros.org/std_srvs", "package": "std_srvs", "package_summary": ["Common service definitions."], "package_details": ["contains two service types called", "and", ", which are common service patterns for sending a signal to a ROS node. For the", "service, no actual data is exchanged between the service and the client. The", "service adds the possibility to check if triggering was successful or not.", "For common message definitions, please see the", "package."]},
{"url": "https://wiki.ros.org/asr_ftc_local_planner", "package": "asr_ftc_local_planner", "package_summary": ["A local planner which based on the \"follow the carrot\" algorithm. Drives accurate along the global plan"], "package_details": ["(", ")", "(", ")", "This package provides an implementation of the \"", "\" algorithm to local robot navigation on a flat plane. Given a global plan to follow and a costmap, the local planner produces velocity commands to send to a mobile base. The parameters for this planner are also dynamically reconfigurable. This package implements the asr_nav_core interface for a local planner. For this to work the standard", "and", "must be adapted (look at kapitel 3.1 Needed Packages).", "In this pictures you can see the function graph of the slow down factor. The first one depicts braking without a slow down factor -> the robot rotates a long time with minimal rotation velocity. With the slow down factor in the second picture the robot rotates not as long with a minimal rotation velocity.", "You can also look at this", "with a point by point description on how to setup the navigation to use the ftc_local_planner.", "Manually adapt the two packages", "and", ":", "You can use the launch files in", ":"]},
{"url": "https://wiki.ros.org/pr2_dashboard_aggregator", "package": "pr2_dashboard_aggregator", "package_summary": ["A simple script that aggregates all of the topics that a \"pr2_dashboard\" app might be interested in."], "package_details": []},
{"url": "https://wiki.ros.org/sr_hardware_interface", "package": "sr_hardware_interface", "package_summary": ["This package contains the actuator used in the hand model."], "package_details": []},
{"url": "https://wiki.ros.org/summit_x_control", "package": "summit_x_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_android", "package": "turtlebot_android", "package_summary": [], "package_details": ["Thanks to the great job of Kazuto Murase, we have the the old Android ROS apps updated and improved. See", "for more details. On this stack we add some extra apps specific for", ". If you just want to use them, install the", "(Groovy) or", "(Hydro) and connect to the turtlebot. It will download the follower for you from the app list.", "But if you want to make your own apps, or try to compile the apps by yourself, proceed with the", "."]},
{"url": "https://wiki.ros.org/message_runtime", "package": "message_runtime", "package_summary": ["Package modeling the run-time dependencies for language bindings of messages."], "package_details": []},
{"url": "https://wiki.ros.org/win_python_build_tools", "package": "win_python_build_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xbot_driver", "package": "xbot_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/scan_to_cloud_converter", "package": "scan_to_cloud_converter", "package_summary": ["Converts LaserScan to PointCloud messages."], "package_details": ["The", "converts", "to", "messages.", "The ouput cloud message has the", "attribute set to", ". Ranges in the scan message which are outside", "are represented by", "values in the output cloud.", "Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/wpi_jaco_wrapper", "package": "wpi_jaco_wrapper", "package_summary": [], "package_details": ["The", "package contains nodes to interface ROS with the JACO API.  It includes publishing angular and Cartesian commands to the arm, generating and following trajectories from input such as", "!, rotational representation conversions between ROS and the JACO API, and forward kinematics.", "The", "package uses a configuration file to set most of the parameters for its nodes.  This allows for support of different types of arms, such as the Jaco, Jaco2, or the Mico.  The configuration files are located within the", "directory, which includes a", "file,", "file, and", "file that define default parameter values for the Jaco, Jaco2, and Mico arms respectively.  The parameters include:", "The", "provides three different options for trajectory execution, each of which has its own action server and its own set of advantages and disadvantages.  The specifics of each trajectory follower, how they compare to eachother, and situations where each one may be applicable are detailed below.", "The", "action server provides the simplest trajectory execution method.  This method sends each point to the JACO arm using the Kinova API, which will then execute the trajectory using its PID controller to move the arm from point to point.  This is the most accurate and precise trajectory follower for point-to-point motion, but for complex trajectories with many points, the point-to-point motion causes the arm to stop at each point resulting in a jerky, uneven overally motion.  As such, this trajectory follower is recommended only for simple trajectories that are comprised of a small number of points spaced far apart, such as pre-defined trajectories for basic motions.", "The", "action server works similarly to the point-to-point trajectory follower provided by", ", with the addition of the Kinova API's trajectory smoothing.  This is accomplished through first converting the trajectory points from joint position points to Cartesian end effector points.  The Kinova API then smooths the trajectory of the end effector.  This has the disadvantage of requiring the full trajectory to avoid the singularity protection zones defined internally, so this trajectory follower should only be used for trajectories generated from planners that are aware of these protection zones, or for pre-defined trajectories.", "The", "action server provides an alternative to the previous two methods (which rely on trajectory execution through the Kinova API) by using its own trajectory controller and trajectory follower based on velocity control.  The trajectory points are used to generate a linear interpolated trajectory with smoothed corners using the", "package.  The trajectory is then followed using a velocity controller, defined in the", "file, that sends its control inputs as joint velocity commands through the Kinova API.  This controller is the recommended trajectory follower for execution of complex trajectories with many points, such as those generated by", "!'s motion planners, as it uses joint control and is therefore not subject to the singularity constraints of the smoothed point-to-point trajectory follower.", "This package is designed to work with the 2- or 3-fingered gripper included with the JACO, JACO2, and MICO.  With it's default behavior, the wrapper node will publish joint states for the fingers, and includes gripper control action servers.  If you are using an alternative end-effector for your arm, setting the kinova_gripper argument in the", "file will disable the finger joint state publishing and the gripper action servers.", "This package has been updated to work with the new JACO2.  There is one important difference to note when using this package with the JACO2 instead of the JACO or the MICO.  For the JACO and MICO, the joint state names are published as", ".  The JACO2 publishes joint state names under a different set of names for compatibility with a new arm urdf.  The joint names, in order from the base to the end-effector, are: [", ",", ",", ",", ",", ",", "]", "See the metapackage,", ", for any other limitations of using this package with the JACO2.", "To install the", "package, you can install from source with the following commands:", "The", "package contains the launch file", "which will launch all of the nodes required to send trajectories and manipulation commands to the JACO arm.  Note that the launch file will remap some of the topic names for the trajectory execution actions (this is done for easier", "! integration), but these can be changed if desired by editing the launch file.  This can be launched with the following command:"]},
{"url": "https://wiki.ros.org/theora_image_transport", "package": "theora_image_transport", "package_summary": ["Theora_image_transport provides a plugin to image_transport for\n    transparently sending an image stream encoded with the Theora codec."], "package_details": ["is a plugin package for", ". It enables any node using", "classes to publish and subscribe to image topics compressed over the wire using the Theora video codec.", "only works with 8-bit color or grayscale images.", "See", "for general instruction on using", "."]},
{"url": "https://wiki.ros.org/rostime", "package": "rostime", "package_summary": ["Time and Duration implementations for C++ libraries, including roscpp."], "package_details": ["Please see", "."]},
{"url": "https://wiki.ros.org/wire_viz", "package": "wire_viz", "package_summary": [], "package_details": ["The goal of the wire_viz package is to visualize the input and the output send to and received from the", "package of the", "stack in RViz.", "A tutorial explaining this package is part of the", "tutorials and can be found", "."]},
{"url": "https://wiki.ros.org/sr_robot_msgs", "package": "sr_robot_msgs", "package_summary": ["sr_robot_msgs contains some messages used in the shadow_robot stack."], "package_details": ["This package contains messages specific to our packages. They are defined in a separate package to minimize the dependencies between packages. If you develop a node to interact with ours, most of the time, you only need to depend on this package (and not on", ")."]},
{"url": "https://wiki.ros.org/naoqi_pose", "package": "naoqi_pose", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kurt_bringup", "package": "kurt_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/clear_costmap_recovery", "package": "clear_costmap_recovery", "package_summary": ["This package provides a recovery behavior for the navigation stack that attempts to clear space by reverting the costmaps used by the navigation stack to the static map outside of a given area."], "package_details": ["(", ", default: 3.0)", "The", "is a simple recovery behavior that clears out space in the navigation stack's", "by reverting to the static map outside of a given radius away from the robot. It adheres to the", "interface found in the", "package and can be used as a recovery behavior", "for the", "node.", "The", "object exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "The C++", "class adheres to the", "interface found in the", "package. For detailed documentation, please see", "."]},
{"url": "https://wiki.ros.org/qb_chain", "package": "qb_chain", "package_summary": ["This package contains the ROS interface to control multiple qbrobotics\u00ae devices simultaneously."], "package_details": []},
{"url": "https://wiki.ros.org/rosmaster", "package": "rosmaster", "package_summary": ["ROS", "implementation."], "package_details": ["The", "package implements the ROS", ". Most programs will not need to interact with this package directly. The", "is run automatically whenever", "is run and all communication with the Master happens over XMLRPC APIs.", "The XMLRPC API of the ROS Master is documented on the", "page.  This API is for advanced users only and backwards compatibility is not guaranteed."]},
{"url": "https://wiki.ros.org/rotors_gazebo", "package": "rotors_gazebo", "package_summary": ["The rotors_gazebo package"], "package_details": []},
{"url": "https://wiki.ros.org/ros_realtime", "package": "ros_realtime", "package_summary": ["The ros_realtime package"], "package_details": []},
{"url": "https://wiki.ros.org/nao_gazebo_plugin", "package": "nao_gazebo_plugin", "package_summary": [], "package_details": ["See the doc is on the github"]},
{"url": "https://wiki.ros.org/ivcon", "package": "ivcon", "package_summary": ["Mesh Conversion Utility\n\nUsed to generate '.iv' files from '.stl' files.  This package has not\nbeen changed since 2001 and appears to be very stable.  We plan on\nkeeping this package in this revision for mesh conversions.  This\npackage is only available as a single source file for download.  There\nare no local modifications to this package."], "package_details": ["This is a thirdparty package with", "."]},
{"url": "https://wiki.ros.org/rigid_body_handler", "package": "rigid_body_handler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/eus_assimp", "package": "eus_assimp", "package_summary": ["eus_assimp"], "package_details": []},
{"url": "https://wiki.ros.org/widowx_arm_controller", "package": "widowx_arm_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/trac_ik_lib", "package": "trac_ik_lib", "package_summary": ["TRAC-IK is a faster, significantly more reliable drop-in replacement for\n    KDL's pseudoinverse Jacobian solver.\n\n    The TRAC-IK library has a very similar API to KDL's IK solver calls,\n    except that the user passes a maximum time instead of a maximum number of\n    search iterations.  Additionally, TRAC-IK allows for error tolerances to\n    be set independently for each Cartesian dimension (x,y,z,roll,pitch.yaw)."], "package_details": []},
{"url": "https://wiki.ros.org/visp_bridge", "package": "visp_bridge", "package_summary": ["Converts between ROS structures and ViSP structures."], "package_details": ["is a small interface between ViSP library and ROS. For instance it converts between the different data types used by each library.", "To date, the supported functionnality sums up to:", "is part of", "stack.", "For usage, see the", "."]},
{"url": "https://wiki.ros.org/schunk_description", "package": "schunk_description", "package_summary": ["This package contains the description (mechanical, kinematic, visual,\n  etc.) of different schunk components. The files in this package are parsed and used by\n  a variety of other components. Most users will not interact directly\n  with this package."], "package_details": ["Further information", "Further information", "Further information", "Further information", "Further information"]},
{"url": "https://wiki.ros.org/sr_self_test", "package": "sr_self_test", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosbag_migration_rule", "package": "rosbag_migration_rule", "package_summary": ["This empty package allows to export rosbag migration rule files without depending on rosbag."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_ft_moveit_config", "package": "pr2_ft_moveit_config", "package_summary": [], "package_details": ["Configuration and launch files for using the PR2 robot with force-torque sensors with the", "Motion Planning Framework"]},
{"url": "https://wiki.ros.org/sr_cyberglove_config", "package": "sr_cyberglove_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/arbotix_msgs", "package": "arbotix_msgs", "package_summary": ["Messages and Services definitions for the ArbotiX."], "package_details": []},
{"url": "https://wiki.ros.org/vigir_step_control", "package": "vigir_step_control", "package_summary": [], "package_details": ["If you would like to see the system running with a real robot, then you can get in touch with it using the THORMANG3 in simulation. The full install instruction can be found", ".", "The", "provides a step queue management system and a state machine to keep track of current step plan execution. It is able to feed the low-level motion layer with the proper number of steps required for seamless execution while continuously merging incoming step plans provided by the", ". This allows even for continuous walking using our", "stack. This package provides following features:", "For detailed information about the system please take a look at the", ".", "The", "packages can be downloaded from Git", "Hub:", "In order to run this example. you will need to install the", "stack as well. An install instruction can be found", ".", "In the", "you have first to select a footstep planner parameter set. Afterwards the direction commands become available which allows to generate simple pattern of footsteps. As soon a footstep plan has been generated the", "button becomes active as well. When you click on this button the previously generated footsteps will be executed virtually by the", "which fakes an footstep execution. During the fake execution, you will be able to follow the fake execution in the", "by the progress bar.", "The THORMANG3 provides a nice real world example how to migrate the software into an exisiting setup", ".", "During the Humanoids@Robo", "Cup Demo 2016 at Leipzig, the step controller was used.", "If you would like to try it out in simulation by yourself, then just follow the instructions", "."]},
{"url": "https://wiki.ros.org/pr2_2dnav_local", "package": "pr2_2dnav_local", "package_summary": [], "package_details": ["As with all PR2 applications, you must", ".", "Tuck the arms of the PR2 using the", ".", "The", "stack that is the heart of the pr2_2dnav_local application can be commanded via", ",", ", or through code."]},
{"url": "https://wiki.ros.org/ros_emacs_utils", "package": "ros_emacs_utils", "package_summary": ["A metapackage of Emacs utils for ROS.\n    Only there for simplifying the release process."], "package_details": []},
{"url": "https://wiki.ros.org/ueye_cam", "package": "ueye_cam", "package_summary": ["A ROS nodelet and node that wraps the driver API for UEye cameras\n    by IDS Imaging Development Systems GMBH."], "package_details": ["git clone", "--branch fuerte", "This package provides a ROS interface for the", ". This ROS interface exposes many of the features of the underlying", ", and is compatible with", ",", ", and", ".", "This package has been tested with the", ", on", ", operating with", "cameras.", "The package with the version 1.0.17 (", ") has been tested with the", "and", ", on", ", operating with", "camera.", "(side-note: it is technically possible to", "; see video caption for outline of instructions)", "This implementation makes use of certain C++11 features (such as std::thread, std::to_string, etc), although the CMakeLists.txt is configured for GCC >= 4.6 (and hence uses the", "flag).", "The IDS camera API allows users to have fine-grain control over the camera on-board processor's clock rate, which determines the range of values for frame rates, exposures, and other camera settings. This can be adjusted at runtime alongside other parameters, via", ". It is however not recommended to operate the camera at a fast clock rate for extended periods of time, as the onboard processor may get excessively hot. Thus, ideally one should adjust the clock rate to match a target frame rate and exposure setting.", "You may choose to use the underlying IDS camera API to perform bayer decoding and publish images as 'rgb8' or 'mono8', or alternatively choose to publish images as 'bayer_rggb8' and rely on the standard ROS", "package for decoding. Currently, this ROS interface does not expose fine-grain control over the bayer decoding engine from the underlying IDS camera API.", "A common mistake is to interpret the 'image_width' and 'image_height' ROS parameters as the width and height of the resulting ROS image. Unfortunately, these names were chosen to be consistent with official camera interfaces provided by IDS, and they refer to the width and height of the camera sensor's Area of Interest (AOI). Therefore, values for 'image_width' and 'image_height' that are smaller than your camera's maximum values will result in", "(a.k.a. reduced AOI).", "1. Install the IDS Software Suite 4.xx for Linux from", "2. create catkin workspace", ".", "4. Run", "under", ".", "Returns raw Bayer-encoded (RGGB encoding) images from the UEye camera, and uses", "to convert to RGB images. Also publishes on /camera/image_raw.", "Same as rgb8.launch, but spawns the nodelet (manager) in gdb on a separate screen.", "The ueye_cam wrapper fully supports", ". You can refer to", "for info on calibrating your own UEye cameras.", "All calibration files are stored by default under:", "We have connected multiple cameras in hardware to an Arduino-compatible device (a", "), which allows any camera to act as master and any number of other cameras to act as slaves, and achieve synchronization seamlessly with unified hardware add-on required. Please see", "for further documentation and instructions. A video demonstration of UEye camera synchronization can be seen", ".", "Historically speaking, ueye_cam was based on an earlier ROS package for interfacing with", "cameras. Given that the initial work on ueye_cam was done prior to the release of other similar ROS wrappers like", "and", ", the original intention was to keep this code internal so as to avoid contention. Nevertheless, this code has since been released as result of a number of recent requests, with the sole hope that it may benefit the ROS community. Please check out the other packages to see which one will best suite your needs."]},
{"url": "https://wiki.ros.org/interactive_marker_twist_server", "package": "interactive_marker_twist_server", "package_summary": ["Interactive control for generic Twist-based robots using interactive markers"], "package_details": ["The purpose of this package is to provide a basic generic marker server for teleoperation of twist-based robots, particularly simple differential drive bases. Examples of such platforms include", ",", ", and", ".", "Package is", ". Please see the feature tracker for planned enhancements."]},
{"url": "https://wiki.ros.org/roslz4", "package": "roslz4", "package_summary": ["A Python and C++ implementation of the LZ4 streaming format.  Large data\n    streams are split into blocks which are compressed using the very fast LZ4\n    compression algorithm."], "package_details": []},
{"url": "https://wiki.ros.org/navfn", "package": "navfn", "package_summary": ["navfn provides a fast interpolated navigation function that can be used to create plans for\n        a mobile base. The planner assumes a circular robot and operates on a costmap to find a\n        minimum cost plan from a start point to an end point in a grid. The navigation function is\n        computed with Dijkstra's algorithm, but support for an A* heuristic may also be added in the\n        near future. navfn also provides a ROS wrapper for the navfn planner that adheres to the\n        nav_core::BaseGlobalPlanner interface specified in", "."], "package_details": ["adheres to the", "interface found in the", "package. For detailed documentation, please see", ".", "This package provides an implementation of a fast, interpolated navigation function used to create plans for a mobile base through the", "class. It also provides a", "for this class via the", "object that adheres to the", "interface specified in the", "package. The", "object is also used as a global planner plugin for the", "node.", "The", "object is a", "for a", "object that exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "The", "object provides an implementation of the navigation function described above. Feel free to use it, but beware that we make no guarantees about the stability of its public API."]},
{"url": "https://wiki.ros.org/node_manager_fkie", "package": "node_manager_fkie", "package_summary": ["Graphical interface, written in PySide, to manage the running and \n     configured ROS nodes on different hosts. For discovering \n     the running ROS master master_discovery node will be used."], "package_details": ["This package offers a graphical user interface (GUI) to manage ROS nodes, topics, services, parameters, and launch files in a ROS network. Combined with other tools of the", "it is possible to operate a network with multiple masters.", "Although the node is written in Python we need to run", "to generate message and service types:", "The services of", "and", "are detected automatically by whose names.", "1. Error while launch a node on remote host:", "2. The", "crashes on load a launch file with error:"]},
{"url": "https://wiki.ros.org/turtlebot_rviz_launchers", "package": "turtlebot_rviz_launchers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_navigation_slam", "package": "pr2_navigation_slam", "package_summary": ["This package holds launch files for running the"], "package_details": ["This package contains configuration files for the", "and", "nodes meant to be run in an application that requires SLAM-based global navigation. This package also includes launch files that bring up", "and", "with global navigation specific configuration options."]},
{"url": "https://wiki.ros.org/rtt_nav_msgs", "package": "rtt_nav_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/summit_x_robot_control", "package": "summit_x_robot_control", "package_summary": [], "package_details": ["Control the robot joints in all kinematic configurations, publishes odom topic and, if configured, also tf odom to base_link. Usually takes as input joystick commands and generates as outputs references for the gazebo controllers defined in summit_xl_control. This package permits an alternative way to control the robot motion (4 motorwheels) that by default is carried on by the Gazebo plugin (skid-steer). In the default configuration this package only controls the pan-tilt camera joints. When used as main controller of the simulated robot, this node also computes the odometry of the robot using the joint movements and a IMU and publish this odometry to /odom. The node has a flag in the yaml files that forces the publication or not of the odom->base_footprint frames, needed by the localization and mapping algorithms."]},
{"url": "https://wiki.ros.org/summit_x_gazebo", "package": "summit_x_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/minas", "package": "minas", "package_summary": ["Meta package for minas for PANASONIC MINAS EtherCAT Motor Driver Control System"], "package_details": ["package wiki page shows how to run robots virtually.", "The minas pacakges contains basic control tools for MINAS-A5B EtherCAT communication driver for indusdtrial robots Tra1 and  its simulator with the", "! Motion Planning Framework.", "On your", "machine where", "is installed:"]},
{"url": "https://wiki.ros.org/multi_level_map_utils", "package": "multi_level_map_utils", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/teleop_keyboard_omni3", "package": "teleop_keyboard_omni3", "package_summary": ["Generic keyboard teleop for 3 wheeled omnidirectional robots."], "package_details": ["Motion Analysis of 3 wheeled omnidirectional robot:"]},
{"url": "https://wiki.ros.org/libfreenect", "package": "libfreenect", "package_summary": [], "package_details": ["is a library for accessing the Microsoft Kinect USB camera. This package downloads revision", "from the", ".", "The tarball is currently hosted", ".", "Bugs should be reported on the relevant github issues page:", "If you would like to submit a patch for the ROS wrapper, please open an issue here:"]},
{"url": "https://wiki.ros.org/usv_gazebo_plugins", "package": "usv_gazebo_plugins", "package_summary": ["Gazebo plugins for simulating Unmanned Surface Vehicles\n    Originaly copied from https://github.com/bsb808/usv_gazebo_plugins"], "package_details": ["The included", "file sets all of the parameters for the plugin, intended as a example for customization."]},
{"url": "https://wiki.ros.org/pr2_description", "package": "pr2_description", "package_summary": ["This package contains the description (mechanical, kinematic, visual,\n  etc.) of the PR2 robot.  The files in this package are parsed and used by\n  a variety of other components.  Most users will not interact directly\n  with this package."], "package_details": ["This package contains the description of the PR2 robot.  It supercedes the older", "package which was written for the alpha hardware.", "Some notable changes from", ":", "To see the PR2 URDF graphically, you can", "A snapshot (r46956) is attached", "for reference.", "In general, PR2 URDF contains a tree structured set of links and joints, with", "as the root link of the tree."]},
{"url": "https://wiki.ros.org/libnabo", "package": "libnabo", "package_summary": ["libnabo is a fast K Nearest Neighbour library for low-dimensional spaces."], "package_details": []},
{"url": "https://wiki.ros.org/rosjava_messages", "package": "rosjava_messages", "package_summary": [], "package_details": ["Please see", "for details about how this package generates code and artifacts for the officially released message package set."]},
{"url": "https://wiki.ros.org/rt_usb_9axisimu_driver", "package": "rt_usb_9axisimu_driver", "package_summary": ["The rt_usb_9axisimu_driver package"], "package_details": ["contains a 9-axis sensor (Accelerometer + Gyro + Compass) IC MPU9250 made by Inven Sense Corp."]},
{"url": "https://wiki.ros.org/rotors_description", "package": "rotors_description", "package_summary": ["The rotors_description package provides URDF models of the AscTec multicopters."], "package_details": []},
{"url": "https://wiki.ros.org/visp", "package": "visp", "package_summary": ["ViSP standing for Visual Servoing Platform is a modular cross platform library that allows prototyping and developing applications using visual tracking and visual servoing technics at the heart of the researches done by Inria Lagadic team. ViSP is able to compute control laws that can be applied to robotic systems. It provides a set of visual features that can be tracked using real time image processing or computer vision algorithms. ViSP provides also simulation capabilities. ViSP can be useful in robotics, computer vision, augmented reality and computer animation."], "package_details": ["This package provides packaging of the ViSP library for ROS. For information about the ViSP library, please see the ViSP main page at", ".", "The next video shows what can be done with", "package that uses", "package.", "The next video shows what can be done with", "package that uses also", "package.", "This other video shows how using", "package that depends on", "it may possible to control a Pioneer P3-DX mobile robot using visual servoing.", "ViSP is a library that is maintained by Inria Lagadic research team", "."]},
{"url": "https://wiki.ros.org/ethercat_manager", "package": "ethercat_manager", "package_summary": ["ROS-Industrial support stack for facilitating communication with\nEtherCAT networks. The code is mainly copied from https://github.com/ros-industrial/robotiq/blob/jade-devel/robotiq_ethercat/src/ethercat_manager.cpp"], "package_details": []},
{"url": "https://wiki.ros.org/access_point_control", "package": "access_point_control", "package_summary": [], "package_details": ["The following dynamic_reconfigure API must be implemented by packages specific to access point model such as", ",", ",", "."]},
{"url": "https://wiki.ros.org/hironx_moveit_config", "package": "hironx_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the HiroNX with the MoveIt Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/xbot_navi", "package": "xbot_navi", "package_summary": [], "package_details": ["The package has many functions such as mapping, positioning, navigation, path planning, and integrated services demo including navigation, face recognition, and voice conversations. The package relies on the xbot-u robot platform and other packages such as", ",", "and", ". See the", ",", ",", "and", "package for more details to configure the mapping and navigation parameters.", "To make a map from xbot-u robot with", "package:", "Or you can choose to use google open source", "to make a map:", "Navigate via", "and", ":", "Or use", "to navigate:"]},
{"url": "https://wiki.ros.org/uos_gazebo_worlds", "package": "uos_gazebo_worlds", "package_summary": ["Gazebo world and model files for UOS."], "package_details": []},
{"url": "https://wiki.ros.org/wge100_driver", "package": "wge100_driver", "package_summary": ["This stack contains the ROS driver and firmware for the WGE100 camera used on the PR2 robot."], "package_details": ["ROS driver and firmware for the WGE100 Ethernet camera. See", "for usage and tutorials.", "Prior to Fuerte, these packages resided in", ".", "A", ". WGE100 cameras are not available separately."]},
{"url": "https://wiki.ros.org/rtshell", "package": "rtshell", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/minas_control", "package": "minas_control", "package_summary": ["This package contains ros_control based robot controller for PANASONIC MINAS EtherCAT Motor Driver Control System"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_props_app", "package": "pr2_props_app", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_visual_tools", "package": "moveit_visual_tools", "package_summary": ["Helper functions for displaying and debugging MoveIt data in Rviz via published markers"], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/katana_msgs", "package": "katana_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nextage_gazebo", "package": "nextage_gazebo", "package_summary": ["Gazebo simulation for NEXTAGE Open"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_create", "package": "turtlebot_create", "package_summary": [], "package_details": ["Please refer main", "page"]},
{"url": "https://wiki.ros.org/rospy", "package": "rospy", "package_summary": ["rospy is a pure Python client library for ROS. The rospy client\n    API enables Python programmers to quickly interface with ROS", ",", ", and", ". The\n    design of rospy favors implementation speed (i.e. developer\n    time) over runtime performance so that algorithms can be quickly\n    prototyped and tested within ROS. It is also ideal for\n    non-critical-path code, such as configuration and initialization\n    code. Many of the ROS tools are written in rospy to take\n    advantage of the type introspection capabilities.\n\n    Many of the ROS tools, such\n    as", "and", ", are\n    built on top of rospy."], "package_details": ["Please refer to the", "package and to the", "page.", "Please see the", "for an introduction to the rospy API and its usage.", "For a more detailed reference, please consult the", ".", "Bug reports and feature requests can be filled and views in the", "."]},
{"url": "https://wiki.ros.org/svenzva_utils", "package": "svenzva_utils", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nao_robot", "package": "nao_robot", "package_summary": [], "package_details": ["See", "for installation instructions and the packages in this stack for more documentation, in particular", "to start the nodes for Nao.", "For issues and questions, please use", "or the", "Use the", "to report bugs or request features."]},
{"url": "https://wiki.ros.org/mongodb_store", "package": "mongodb_store", "package_summary": ["A package to support MongoDB-based storage and analysis for data from a ROS system, eg. saved messages, configurations etc"], "package_details": ["Use GitHub to", ". [", "]", "This package contains nodes and libraries for storing and retrieving ROS-related data in a", "database using C++ and Python. It is intended to support data persistence and inspection, including in running systems (i.e. introspection). The main functions are the storage and retrieval of single message (this is the", "); the rosbag-like logging of topics to the db (via", ") and their playback (mongodb_play); and the storage and recreation of parameters.", "First set the host and port you want the datacentre to run on. We do this via", "so that other nodes know where to find the server.", "If these are not set the server uses a generated port number and", "then sets the above parameters to its chosen values.", "This runs the", "server and also provides some utility functions around this. By default, the mongod database will be stored in", ". This can be overridden by setting the private parameter ~database_path for the node. If it is the first time that the database is used, be sure to first create the database path (e.g.", ").", "To create \"", "record\"-like logging of topics to the", "use", ". This has been updated to store logged data in a format that can be easily recreated into ROS messages for replay.", "The", "node reads logged messages from the store and replays them on their original topics. This provides a similar function to \"", "play\". Currently this node always creates its own", "in order to play back the messages at the time they were originally recorded.", "will play back messages previously from the", "and", "topics which were previously stored in the default database (", ").", "and", "respect latched topics.", "1.", ".  These should be \"working defaults\" - so all essential parameters at least have a default value. For example, if a robot application requires some calibration data then default values should be provided. Default parameters can be shared among sites and stored inside a shared ROS package. When the config manager is started, all .yaml files stored in a 'defaults' folder will be examined. Any new default parameters will automatically be inserted into the \"defaults\" collection within the configs database. The defaults folder should be supplied as a private parameter:", "either set to a system path or in the form", ".", "2.", ". These parameters override the same named  global default parameters, allowing site-specific parameter setting. They are stored within the database inside the \"local\" collection.", "At start up, the config manager places all parameters onto the ros parameter server to allow interoperability with existing software. Parameters can also be queried using the", ", or by directly connection to and querying the mongo database server.", "Likewise, local parameter overrides can be set using the", "service or by directly editing the \"local\" collection in the configs database.", "The message store node provides services to allow clients to add, update and remove ROS messages in the mongo store via the", "object in both Python and C++. This is best demonstrated by examples. With the mongodb server running, run the message store:", "If the constructor argument to the message store node", "is set to true, replication of the message store parts of the store is done manually to allow different content to appear on different hosts. A list of hosts and ports where replications should be made can be set via the", "ros parameter:", "If", "is set (regardless of", "), queries are performed on the main first, and if nothing found, the replicants are tried.", "You can test if this works by adding some things to the message store, deleting them from the master using", "(not the message store as the deletes are replicated), then running queries.", "The", "action and the corresponding action server:", "(which is included in", ")", "allows you to bulk copy or move entries from message store collections to the mongod instances defined under", ". The client accepts a list of collection names and uses the", "field of the message store entries to replicate or move all entries that were inserted before a particular time. If no time is provided then the default is 24 hours ago. There is an example client that does this for a list of collections specified on the command line. This *moves* entries inserted 24 hours ago or earlier.", "***NOTE THAT this all makes", "operations a bit uncertain, so please do not use this type of replication on collections you plan to use update on.***"]},
{"url": "https://wiki.ros.org/rotors_joy_interface", "package": "rotors_joy_interface", "package_summary": ["The rotors_joy_interface package to control MAVs with a joystick"], "package_details": []},
{"url": "https://wiki.ros.org/roslaunch", "package": "roslaunch", "package_summary": ["roslaunch is a tool for easily launching multiple ROS", "locally and remotely\n    via SSH, as well as setting parameters on the", ". It includes options to automatically respawn processes\n    that have already died. roslaunch takes in one or more XML\n    configuration files (with the", "extension) that\n    specify the parameters to set and nodes to launch, as well as the\n    machines that they should be run on."], "package_details": ["uses XML files that describe the nodes that should be run, parameters that should be set, and other attributes of launching a collection of ROS", ". For a specification of this XML format, please see:", "was designed to fit the ROS architecture of complexity via composition. Understanding", "'s architecture will give you better insight in how to construct your", "files and better debug remote vs. local launches.", "is a specialization of the", "tool for bringing up the \"core\" ROS system.  A roslaunch will automatically start roscore if it detects that it is not already running (unless the --wait argument is supplied).  For more information, please see the", "documentation. Note: due to a", ", roslaunch should not be used to guarantee a singleton instance of roscore.", "these *.launch file tests can also be initiated using console tool called", "OR", ".", "The", "contains the", "tools, which reads the", ". It also contains a variety of other support tools to help you use these files.", "Many ROS packages come with \"launch files\", which you can run with:", "To find out more about the main", "tool and other command-line tools, please consult:", "The launch file syntax itself is", ", and every effort will be made to provide backwards compatibility with new features.", "The code API of", "is", "and should not be used directly. In order to support the new features that are being planned, it may be necessary to make major, incompatible changes to the programmatic API.", "There are many new features being planned for", ". These include new features within the launch file syntax, GUI tools for interacting with launch files more effectively, network API, better coordination between separate launch files, and more.", "Ref.", "The", "CMake macro can be used to check launch files for common errors such as missing arguments, dependencies, packages, or nodes.", "The following is how you would check all", "files in a package's \"", "\" directory:", "NOTE:", "takes only one directory at a time.", "The check runs during", ". So something like following is cleaner.", "Since you need to find", "in", "as above, you better explicitly add a dependency in your", "as following:", "Pass an optional argument \"", "\" to", "as the following example, if your package defines dependency for the tests (e.g.", "). This avoids issues that happen during tests such as", ".", "A few graphical tools are available to support", "functionalities of ROS."]},
{"url": "https://wiki.ros.org/fingertip_pressure", "package": "fingertip_pressure", "package_summary": ["This package provides access to the PR2 fingertip pressure sensors. This information includes:"], "package_details": [": All nodes assume that", "is either", "or", ".", "is a standalone demo of the package's capabilities.", "It runs all the package's nodes, and rviz (to view the visualization markers). This should demonstrate all the packages capabilities.", "Each pr2 gripper is equipped with two pressure-sensitive fingertips. Each pressure comprises 22 pressure sensing elements: one on the back, 6 around the edges and a 3x5 array on the front.", "provides nodes to facilitate the visualization and interpretation of the fingertip pressure sensor data.", "Example of", "GUI:", "Example:", "and in a separate shell:"]},
{"url": "https://wiki.ros.org/rtsprofile", "package": "rtsprofile", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosserial_client", "package": "rosserial_client", "package_summary": ["Generalized client side source for rosserial."], "package_details": ["contains the generic client-side", "implementation. It is designed for microcontrollers and it can run on any processor for which you have an ANSI C++ compiler and a serial port connection to a computer running ROS.", "The serialization and deserialization code generated by the", "module assumes that the client is a little-endian machine. If you have a bi-endian target such as ARM or MIPS, be sure that it has been placed in little-endian mode in order to use it with rosserial.", "For details on using rosserial_client with the Arduino, please see", ". For other platforms, please see the", "."]},
{"url": "https://wiki.ros.org/uos_rotunit_teleop", "package": "uos_rotunit_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ur_driver", "package": "ur_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_edc_ethercat_drivers", "package": "sr_edc_ethercat_drivers", "package_summary": ["A package implementing a ROS interface for the etherCAT Shadow Robot Dextrous Hand."], "package_details": ["This package contains the driver for the etherCAT Hand. It uses the", "which is running the main loop at 1kHz for sending and receiving packets to/from the etherCAT. We also load the", "which will be used to load the controllers on demand.", "The driver sends different demands to the etherCAT hand and receives and formats correctly the incoming packets. The incoming data is stored in a vector of actuators (defined in the", "package). Those actuators are then passed to the controllers for the 1kHz control loop. The controllers are publishing the relevant data (position / effort / velocity) at 100Hz on the", "topic, and the hardware diagnostics on the", "topic at 1Hz.", "The protocol used to interpret or build the etherCAT packets can be found in", ".", "Please refer to the", "to learn how to use the driver.", "You can look at the current status of the robot using the", ":"]},
{"url": "https://wiki.ros.org/simple_grasping", "package": "simple_grasping", "package_summary": ["Basic grasping applications and demos."], "package_details": []},
{"url": "https://wiki.ros.org/rsv_balance_description", "package": "rsv_balance_description", "package_summary": [], "package_details": ["'s self-balance platform URDF model and meshes.", "The platform macro is provided by the file:", "and can be included in your URDF model as such:", "As an example you can look at", ", which puts on top a rod and a dummy weight of 5kg."]},
{"url": "https://wiki.ros.org/tf2_sensor_msgs", "package": "tf2_sensor_msgs", "package_summary": ["Small lib to transform sensor_msgs with tf. Most notably, PointCloud2"], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_arm_bringup", "package": "turtlebot_arm_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tango_ros_streamer", "package": "tango_ros_streamer", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Note that all image topics are published via", ". Therefore, for each image topic, a compressed version of the image is available together with its compression parameters.", "Also note that the service", "seems to not work properly on Tango Tablet Development Kit."]},
{"url": "https://wiki.ros.org/surface_perception", "package": "surface_perception", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "is a simple tabletop/shelf perception pipeline.", "is the main API.", "It takes in a point cloud, where the positive \"z\" direction points up.", "It also assumes that the point cloud has been cropped down to a tabletop/shelf scene.", "visualizes the result:", "If", "is not provided, the point cloud will be processed in", "."]},
{"url": "https://wiki.ros.org/ros_ethernet_rmp", "package": "ros_ethernet_rmp", "package_summary": [], "package_details": ["broadcasts the robot frame ('/base_footprint') with respect to the odometry frame (", ").", "The", "package is used to bridge ROS and a Segway RMP. It will convert", "topic messages to the RMPCommand format and then publish the feedback from the RMP. There is also a joint state publisher to read in the feedback and publish the changing joint states as necessary.", "To install the", "package, you can choose to either install from source, or from the Ubuntu package:", "The", "package contains a", "file. This file launches an instance of the", ", 'rmp_pose_updater.py' and", "nodes. 'battery_monitor_rmp.launch' from 'battery_monitor_rmp' will also be launched if the argument, include_batt_monitor, is true. It is defaulted to true. To launch these nodes,", "the battery monitor the following command can be used:", "To launch these nodes", "the battery monitor, the following command can be used:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/catkinize_this", "package": "catkinize_this", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/multi_interface_roam", "package": "multi_interface_roam", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ndt_fuser", "package": "ndt_fuser", "package_summary": [], "package_details": ["A tutorial describing how to set-up an NDT fuser node and use it with your robot is available -", "."]},
{"url": "https://wiki.ros.org/abb_driver", "package": "abb_driver", "package_summary": [], "package_details": ["RobotWare OS version 5.13 or later is required due to the use of certain socket options. Earlier versions may work, but will require modifications to the RAPID code.", "This package is part of the", "program.", "The package is usable as-is, but is not feature complete. However, no significant development is planned, as development focus has shifted to", "(with", "and", ").", "While it is possible to use this driver with YuMi, for now this is not recommended.", "Users who have the EGM option available, consider using", ", as it will offer the best possible motion quality.", "The driver does not include any robot models (ie:", "packages) however.", "Various sources for those exist, one of which could be", ".", "Use the links on the", "page for access to the tutorials. These explain how to install and set up the RAPID programs on the controller, as well as how to use them in conjunction with the ROS nodes in this package."]},
{"url": "https://wiki.ros.org/irb_6640_moveit_config", "package": "irb_6640_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/sbpl_recovery", "package": "sbpl_recovery", "package_summary": ["A recovery behavior that uses the sbpl lattice planner and the pose\n    follower to try to plan in full 3D to get the robot out of really tricky\n    situations."], "package_details": []},
{"url": "https://wiki.ros.org/radar_omnipresense", "package": "radar_omnipresense", "package_summary": ["This is the radar driver package developed for the omnipresense radar module."], "package_details": ["Please see the individual packages within this stack for documentation. OPS241/OPS242 radar sensors can be purchased from", ".  The full API Interface documentation (AN-10) is available at", ".", "radar_omnipresense , a ROS module for the", "radar sensor", "The radar_omipresense driver is built automatically by the ROS build farm.  Subsequently, the standard way of installing drivers works for the radar omnipresense driver.  Namely, apt install ros-", "-radar-omnipresense.  So, for example, if you are running with ROS \"melodic\" and are not logged in as root, you could issue the command;", "You can also download the driver as source code and build it yourself.  All external dependencies have been removed, so a beginner should be able to accomplish it without too many complications. The instructions on the wiki are very thorough on walking a developer through the steps.  A good place to start is", "For application support, please contact", "."]},
{"url": "https://wiki.ros.org/usb_cam", "package": "usb_cam", "package_summary": ["A ROS Driver for V4L USB Cameras"], "package_details": ["The node supports the following I/O mode names for the given device:", "Selection of the pixel format name automatically selects the decoder library and pixel representation for FFMPEG/", "processing. The node supports the following pixel format names and decoders (all names are case-sensitive):", ": In its current state, the node does not support hardware-accelerated decoding!", "The node supports the following color representation mode names (case-sensitive):", "The node queries V4L kernel driver for available intrinsic control names and data types they require, in the same way, that one can query from terminal with the following command:", "This package provides a configurable ROS interface to the", "of", "library that implements a common driver for standard USB web cameras. The module uses a monopolistic way of entry point (virtual filesystem) access model with the policy \"one device = one node\". The ROS node running over the", "also queries the kernel about the intrinsic parameters of the camera and provides a flexible configuration model via the standard ROS configuration model. The camera is polled over the intervals of the desired framerate, then the images are decoded and published according to", "package specifications in sink-on-demand operating mode. Also, the", "specifications are partially supported to publish actual frame parameters.", "For example, if the node runs under the name", "and", "is set to", "(default invocation case), the node will publish the following list of topics:", "The support for a hardware-accelerated decoder in the package is now", ". It is implemented in the dedicated", "in the repository. The feature is not enabled by default and it is supported only from", "library version", ".", "The node supports the following types of intrinsic controls provided by", ":", "The queried names become ROS parameters and are placed under", "multilist of the configuration file. Its main namespace contains:", "This example configuration is obtained using", "web camera with standard", "kernel driver from Ubuntu 22.04 with 5.15.0 kernel installed. The manually queried control names:", "Here are the following intrinsic controls that are mentioned in the", "of the", "multilist, so they will be processed and set up:", "All the other intrinsic control names reported by", "are enumerated in the", "string list, so their values will be left intact."]},
{"url": "https://wiki.ros.org/velodyne_height_map", "package": "velodyne_height_map", "package_summary": [], "package_details": ["Start the height map nodelet in a separate process.", "This launch file runs the height map nodelet in the same process with the Velodyne device driver and a", "nodelet which publishes the points transformed into the \"/odom\" frame."]},
{"url": "https://wiki.ros.org/nav2d_operator", "package": "nav2d_operator", "package_summary": ["The operator is a lightweight, purely reactive obstacle-avoidance\n    module for mobile robots moving in a planar environment. The operator node\n    works by evaluating a set of predefined motion primitives based on a local\n    costmap and a desired direction. The best evaluated motion command will be\n    send to the mobile base."], "package_details": ["See the", "for an example how to setup the Operator in Stage and use a Joystick to simulate commands from a higher level node."]},
{"url": "https://wiki.ros.org/industrial_moveit", "package": "industrial_moveit", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This stack is part of the", "program. It currently contains packages that are meant for use with the", "packages.", "See the", "page for an overview of the available tutorials."]},
{"url": "https://wiki.ros.org/asr_intermediate_object_generator", "package": "asr_intermediate_object_generator", "package_summary": ["The intermediate object generator generates intermediate objects for a domain composed from scenes. \n    It is used to restrain the amount of objects searched during the direct search phase by selecting appropriate objects to search."], "package_details": [": The path were the intermediate_object_weights xml file should be created. The XXX works analog here, too.", "The intermediate object generator generates intermediate object for a domain composed from scenes. It is used to restrain the amount of object searched during the direct search (", ") phase by selecting appropriate objects to search.", "This package needs a database of objects and their absolute positions during the time (can be set in the", "). On basis of this information it will be determined which objects have a heigher chance to be found in a 3D-object-search. There will be two files saved.", "In one a subset of the current objects will be saved, to limit the search objects while the direct search of the", ".", "In the second the calculated weight for each object will be saved. This can be used in the", "to prefer some objects about the others.", "The", "will launch this package automatically if the generated files for the current database were not generated yet. There is an option in asr_world_model to activate this function.", "!", ": The path were the intermediate_objects xml file should be created. If there is an XXX in the name, the XXX will be replaced with the current database name. So the name has not to be changed manually after a database change.", "!", ": 0 or 1, 0 is additive and 1 is multiplicative", ": weight for the presence in scene criteria", ": weight for the position variance criteria", ": weight for the average distance between object criterias!", ": gain threshold for the object filtering !", ": name of the domain"]},
{"url": "https://wiki.ros.org/pr2_controller_interface", "package": "pr2_controller_interface", "package_summary": ["This package specifies the interface to a realtime controller. A\n   controller that implements this interface can be executed by the", "in the real time control loop. The package basically\n  contains the C++ controller base class that all controllers need to\n  inherit from."], "package_details": ["To implement a real time controller, your controller needs to inherit from the", "base class. The base class contains", "The", "method is executed in", ".", "The", "method returns if the initialization was successful or not. If the initialization fails, the controller will get unloaded by", ". Make sure to always use", "to inform the user why your controller failed to initialize. A controller can only be initialized once. If you want to re-initialize a controller, you first need to unload it, and then load it again.", "The", "method is executed in", ".", "The", "method initializes the controller right before the first time update is called. The", "is allowed to re-start a controller at a later time, without having to unload/load the controller.", "The", "method is executed in", ".", "The", "method is executed in", ".", "The", "method does not return anything, it is not allowed to fail.", "The", "method is executed in", ".", "The", "method takes three arguments:"]},
{"url": "https://wiki.ros.org/trac_ik", "package": "trac_ik", "package_summary": ["The ROS packages in this repository were created to provide an improved\n    alternative Inverse Kinematics solver to the popular inverse Jacobian\n    methods in KDL.  TRAC-IK handles joint-limited chains better than KDL\n    without increasing solve time."], "package_details": ["Sources -- including a", "! compatible IK plugin -- can be found at:", ".", "TRAC-IK has a very similar API to KDL's IK solver calls, except that the user passes a maximum time instead of a maximum number of search iterations.  Additionally, TRAC-IK allows for error tolerances to be set independently for each Cartesian dimension (x, y, z, roll, pitch & yaw).", "Detailed usage instructions can be found at", "(or more specifically,", ").", "KDL's joint-limited pseudoinverse Jacobian implementation is the solver used by various ROS packages and", "! for generic manipulation chains. In our research with Atlas humanoids in the DARPA Robotics Challenge and with NASA's Robonaut 2 and Valkyrie humanoids, TRACLabs researchers experienced a high amount of solve errors when using KDL's inverse kinematics functions on robotic arms.  We tracked the issues down to the fact that theoretically-sound Newton methods fail in the face of joint limits.  As such, we have created TRAC-IK that concurrently runs two different IK methods:", "Details can be found here in our Humanoids 2015 paper", ".", "Image (from", "): A few high-level results are shown in the attached (low-res) figure.", "Use", "to", ".", "."]},
{"url": "https://wiki.ros.org/octomap_ros", "package": "octomap_ros", "package_summary": ["octomap_ros provides conversion functions between ROS and OctoMap's native types.\n    This enables a convenvient use of the octomap package in ROS."], "package_details": ["See", "for documentation.", "helps you to convert between various ROS / PCL and OctoMap data types.", "Messages, services and conversions of them (without ROS-dependencies) are available in", ". Since fuerte, this package is a unary stack and released separately."]},
{"url": "https://wiki.ros.org/roscompile", "package": "roscompile", "package_summary": ["The roscompile package"], "package_details": ["See", "."]},
{"url": "https://wiki.ros.org/social_navigation_layers", "package": "social_navigation_layers", "package_summary": ["Plugin-based layers for the navigation stack that\n  implement various social navigation contraints, like proxemic distance."], "package_details": ["There are currently two social navigation layers. However, they both share functionality in that they both subscribe to where people are and alter the costmaps with a Gaussian distribution around those people. Both classes derive from the general SocialLayer class.", "They can be used in", "with the following types:", "The proxemic layer adds gaussian costs all around the detected person, with the parameters specified above. If the person is stationary, the gaussian is perfectly round. However, if the person is moving, then the costs will be increased in the direction of their motion. How far in front of the person the costs are increased is proportional to the", "parameter."]},
{"url": "https://wiki.ros.org/pr2_navigation_local", "package": "pr2_navigation_local", "package_summary": ["This package holds xml files for running the"], "package_details": ["This package contains configuration files for the", "node meant to be run in an application that requires navigation in an odometric frame. This package also includes launch files that bring up", "and", "with local navigation specific configurations."]},
{"url": "https://wiki.ros.org/pr2_navigation_teleop", "package": "pr2_navigation_teleop", "package_summary": ["This package holds a special teleop configuration for the PR2 robot that\n     should be used when running applications that use autonomous navigation."], "package_details": ["This package provides an XML file for running", "in a configuration that allows it to run in parallel with the", "stack on the PR2 robot."]},
{"url": "https://wiki.ros.org/shape_tools", "package": "shape_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tuw_marker_slam", "package": "tuw_marker_slam", "package_summary": [], "package_details": ["Start SLAM framework in EKF-SLAM mode with a predefined measurement noise model using the simulation environment Stage (", "):", "Start SLAM framework in EKF-SLAM mode with a predefined measurement noise model using the simulation environment Gazebo (", ") and the tuw_aruco marker detection"]},
{"url": "https://wiki.ros.org/staubli_resources", "package": "staubli_resources", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "metapackage page."]},
{"url": "https://wiki.ros.org/xaxxon_openlidar", "package": "xaxxon_openlidar", "package_summary": ["ROS Drivers for the Xaxxon OpenLIDAR Sensor"], "package_details": ["is an open hardware rotational laser scanner, using the Garmin LIDAR-LiteV3 sensor. Full specs and complete documentation can be found at", "Full specs and complete documentation can be found at"]},
{"url": "https://wiki.ros.org/stdr_simulator", "package": "stdr_simulator", "package_summary": [], "package_details": ["STDR Simulator implements a distributed, server-client based architecture. Each node can run in a different machine and communicate using ros interfaces. STDR Simulator, also provides a", "developed in QT, for visualization purposes and more. The", ", is not necessary for the simulator to run and its functionalities can be performed using command-line tools provided with the package.", "The", "available packages are:", "An overview of the", "architecture is depicted in the following diagram:"]},
{"url": "https://wiki.ros.org/rwt_plot", "package": "rwt_plot", "package_summary": ["rwt_plot"], "package_details": ["Example of", "with", "."]},
{"url": "https://wiki.ros.org/moveit_object_handling", "package": "moveit_object_handling", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/uwb_hardware_driver", "package": "uwb_hardware_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/segbot_navigation", "package": "segbot_navigation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/goal_passer", "package": "goal_passer", "package_summary": ["A global planner plugin for move_base that simply passes the target pose on\n    as a global plan. Useful for debugging local planners."], "package_details": []},
{"url": "https://wiki.ros.org/rosh_geometry", "package": "rosh_geometry", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/hironx_calibration", "package": "hironx_calibration", "package_summary": ["Launch and configuration files for calibrating hironx using the generic", "package.\n\n   THIS FILE IS AUTOMATICALLY GENERATED BY:"], "package_details": []},
{"url": "https://wiki.ros.org/tuw_marker_pose_estimation", "package": "tuw_marker_pose_estimation", "package_summary": ["This node does pose estimation for detected fiducials (marker_msgs/FiducialDetection.msg)"], "package_details": []},
{"url": "https://wiki.ros.org/warehouse_ros_mongo", "package": "warehouse_ros_mongo", "package_summary": ["warehouse_ros for MongoDB"], "package_details": []},
{"url": "https://wiki.ros.org/nav2d", "package": "nav2d", "package_summary": ["Meta-Package containing modules for 2D-Navigation"], "package_details": ["Use GitHub to", ". [", "]", "This stack is developed using the catkin tool-chain. An older version is available that uses ROS Fuerte and rosbuild tool-chain, but has not been updated after the move to Hydro. To build the", "package is required, which is included in ros-navigation.", "To check if all packages are working correctly, you can run the launch files located in the", "package. This will use a joystick to semi-autonomous control a simulated robot in Stage. A more in-detail description can be found in the", ". To start the tests you need to have the following packages additionally installed:", "If you have a Question concerning any of the nav2d-packages, please post your question at", "and add the tag \"nav2d\"."]},
{"url": "https://wiki.ros.org/sbpl_lattice_planner", "package": "sbpl_lattice_planner", "package_summary": ["The sbpl_lattice_planner is a global planner plugin for move_base and wraps\n    the SBPL search-based planning library."], "package_details": ["sbpl_lattice_planner is a ROS wrapper for the", "lattice environment and  adheres to the nav_core::", "interface specified in", ".  The lattice planner can therefore be used as the global planner for", ". The planner will generate a path from the robot's current position to a desired goal pose. Paths are generated by combining a series of \"motion primitives\" which are short, kinematically feasible motions. Planning is therefore done in x, y, and theta dimensions, resulting in smooth paths that take robot orientation into account, which is especially important if the robot is not assumed to be circular or has nonholonomic constraints. Plans can be found using the ARA* planner or AD* planner.", "Please refer to the", "documentation for pre-made motion primitives for the PR2 (and other robots) as well as instructions on how to generate your own custom motions."]},
{"url": "https://wiki.ros.org/rotors_simulator", "package": "rotors_simulator", "package_summary": ["RotorS is a MAV gazebo simulator."], "package_details": ["Use GitHub to", ". [", "]", "RotorS is a MAV gazebo simulator. It provides some multi-rotor helicopter models such as the", "Hummingbird, Pelican, and Firefly, but the simulator is not limited for the use with these multicopters."]},
{"url": "https://wiki.ros.org/agile_grasp", "package": "agile_grasp", "package_summary": [], "package_details": [": If you want to adjust the grasp parameters, you can do this from the launch file. For the available parameters, see", ".", "When no handles or not enough antipodal grasps are found, please increase the", "parameter. Another option is to modify the workspace limits in", "(this requires recompiling the code).", "This package localizes antipodal grasps in 3D point clouds.", "stands for", "ntipodal", "rasp", "dentification and", "arning. The reference for this package is:", ".", "The package already comes with pre-trained machine learning classifiers and can be used (almost) out-of-the-box, in particular with an", "range sensor.", "For a complete", "on a Baxter robot, check out our", "package.", "Two example ROS launch files,", "and", ", are provided that illustrate  how to use the", "ROS node to localize grasps in a point cloud obtained from one or two range sensors.", "The most important parameters to increase the number of grasps found are", "and", ". A higher sample number means that a larger subset of points in the point cloud will be considered. A smaller workspace means that less samples are required to find grasps.", "Localize grasps in a point cloud stored in a", "file:", "This localizes grasps in the point cloud file", "using the SVM stored in the file", ". The last three parameters are optional.", "sets the number of samples,", "sets the number of CPU threads used, and", "sets the minimum number of grasps required to have a cluster of grasps.", "To train the SVM to predict grasps, first create a directory that contains the", "files used for training.", "If you like this package and use it in your own work, please cite our", ":", "Andreas ten Pas and Robert Platt.", "International Symposium on Robotics Research (ISRR), Italy, September 2015."]},
{"url": "https://wiki.ros.org/tuw_multi_robot_demo", "package": "tuw_multi_robot_demo", "package_summary": ["Contains launch and config files to run a sample demo."], "package_details": ["default: \"cave\"", "default: \"true\"", "default: \"true\"", "default: \"true\"", "default: \"true\"", "default: \"true\"", "default: \"true\"", "default: \"default\" (2 robots)", "default: \"false\"", "Use GitHub to", ". [", "]", "To control the robots one can use a custom controller (e.g. the DWA from move_base) in combination with the local behavior controller which takes care of synchronization with other robots and provides an ordinary nav_msgs/Path message. For tests with a large number of robots the", "is provided which directly uses synchronous tuw_multi_robot_msgs/Route messages and controls all robots simultaneously. This is advantageous for performance reasons."]},
{"url": "https://wiki.ros.org/arbotix_firmware", "package": "arbotix_firmware", "package_summary": ["Firmware source code for ArbotiX ROS bindings."], "package_details": ["You can then copy the files found in the", "folder of this package into your sketchbook. You should then be able to open the", "sketch, compile and upload."]},
{"url": "https://wiki.ros.org/nav_pcontroller", "package": "nav_pcontroller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rtt_actionlib_msgs", "package": "rtt_actionlib_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosserial_server", "package": "rosserial_server", "package_summary": ["A more performance- and stability-oriented server alternative implemented\n    in C++ to rosserial_python."], "package_details": ["The", "package contains a C++ implementation of the host-side rosserial connection. It automatically handles setup, publishing, and subscribing for a connected rosserial-enabled device. It uses a python node in the rosserial_python package as an aid for handling subcriptions.", "These nodes use the", "/ShapeShifter meta message in order to republish messages from clients without having to know about them at compile time. The only caveat to this approach is that the servers do not have the full textual definition of messages (as it is not stored in clients or part of the rosserial protocol). There is a provided Python shim which the servers may optionally use to acquire this information. Example launch files for serial and socket usage are provided in the package.", "The", "parameter to the server allows it to enforce that the client(s) must publish and subscribe to a certain set of topics. This is important because a serial connection provides no guarantee of delivery, and the rosserial protocol doesn't inherently contain any such checks.", "Use of the", "parameter is completely optional, but may be of value to users needing to deploy ROS-connected microcontrollers into environments where the occasional failed initialization is not acceptable.", "At this time,", "is experimental. It is missing key features of the", "-provided node, including parameters, logging, and services. If you require these features, please stick to the standard Python server for now."]},
{"url": "https://wiki.ros.org/trac_ik_kinematics_plugin", "package": "trac_ik_kinematics_plugin", "package_summary": ["A MoveIt! Kinematics plugin using TRAC-IK"], "package_details": []},
{"url": "https://wiki.ros.org/trajectory_msgs", "package": "trajectory_msgs", "package_summary": ["This package defines messages for defining robot trajectories. These messages are\n    also the building blocks of most of the", "actions."], "package_details": [": this package is now part of", ".  In previous releases, it was part of", ".", "Newly proposed, mistyped, or obsolete package. Could not find package \"trajectory_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/trajectory_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/wheeled_robin_apps", "package": "wheeled_robin_apps", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Please refer main", "page."]},
{"url": "https://wiki.ros.org/people", "package": "people", "package_summary": ["The people stack holds algorithms for perceiving people from a number of sensors."], "package_details": []},
{"url": "https://wiki.ros.org/ackermann_msgs", "package": "ackermann_msgs", "package_summary": ["ROS messages for robots using Ackermann steering."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"ackermann_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/ackermann_msgs/manifest.yaml", "This package provides ROS messages for vehicles using front-wheel Ackermann steering. It was defined by the", "."]},
{"url": "https://wiki.ros.org/wheeled_robin_simulator", "package": "wheeled_robin_simulator", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Please refer main", "page."]},
{"url": "https://wiki.ros.org/nao_path_follower", "package": "nao_path_follower", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosh", "package": "rosh", "package_summary": [], "package_details": ["is a Python-based shell and runtime environment for ROS.  It leverages the IPython shell environment to provide tab-completion introspection across various ROS APIs, like topics, services, parameters, and nodes.  It is similar to using tools like", "and", ", but with Pythonic semantics and the convenience of a Python interpreter.  You can also develop ROS nodes using rosh, which we call \"roshlets\".", "Please see the", ".", "See", "See", "In order customize your default", "shell, you can write a", ".", "See", "."]},
{"url": "https://wiki.ros.org/tf2_msgs", "package": "tf2_msgs", "package_summary": ["tf2_msgs"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"tf2_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/tf2_msgs/manifest.yaml", "This is the package grouping the Transform and Error messages used by", "and", "."]},
{"url": "https://wiki.ros.org/rtt_rosgraph_msgs", "package": "rtt_rosgraph_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/laptop_battery_monitor", "package": "laptop_battery_monitor", "package_summary": ["Simple script to check battery status"], "package_details": []},
{"url": "https://wiki.ros.org/sr_gui_bootloader", "package": "sr_gui_bootloader", "package_summary": ["A GUI plugin for bootloading the motors on the shadow etherCAT hand."], "package_details": []},
{"url": "https://wiki.ros.org/segbot_simulator", "package": "segbot_simulator", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/rtt_visualization_msgs", "package": "rtt_visualization_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/multi_level_map_server", "package": "multi_level_map_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/uav_optimal_coverage", "package": "uav_optimal_coverage", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/moveit_controller_multidof", "package": "moveit_controller_multidof", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_arm_move_ik", "package": "pr2_arm_move_ik", "package_summary": ["Move the pr2 arm using inverse kinematics"], "package_details": []},
{"url": "https://wiki.ros.org/typelib", "package": "typelib", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/slam_gmapping", "package": "slam_gmapping", "package_summary": ["slam_gmapping contains a wrapper around gmapping which provides SLAM capabilities."], "package_details": ["See the", "package for more details on mapping options.", "Also, see the"]},
{"url": "https://wiki.ros.org/urdf2inventor", "package": "urdf2inventor", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/navigation", "package": "navigation", "package_summary": ["A 2D navigation stack that takes in information from odometry, sensor\n        streams, and a goal pose and outputs safe velocity commands that are sent\n        to a mobile base."], "package_details": ["Available Translations:", "The Navigation Stack is fairly simple on a conceptual level. It takes in information from odometry and sensor streams and outputs velocity commands to send to a mobile base. Use of the Navigation Stack on an arbitrary robot, however, is a bit more complicated. As a pre-requisite for navigation stack use, the robot must be running ROS, have a", "transform tree in place, and publish sensor data using the correct ROS", ". Also, the Navigation Stack needs to be configured for the shape and dynamics of a robot to perform at a high level. To help with this process, this manual is meant to serve as a guide to typical Navigation Stack set-up and configuration.", "The following documentation assumes familiarity with the Robot Operating System. Documentation on ROS can be found here:"]},
{"url": "https://wiki.ros.org/urdf_transform", "package": "urdf_transform", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nao_bringup", "package": "nao_bringup", "package_summary": [], "package_details": ["Before starting, please make sure you meet all the required dependencies especially the packages", ",", "and", ".", "You can either install the official releases via your package manager or directly clone the necessary ros packages from github.", "Alternatively you can make use of the python SDK, which has to be installed and correctly setup in your PYTHONPATH environment variable. For more information on that, please refer to", "."]},
{"url": "https://wiki.ros.org/rosgraph", "package": "rosgraph", "package_summary": ["rosgraph contains the rosgraph command-line tool, which prints\n    information about the ROS Computation Graph. It also provides an\n    internal library that can be used by graphical tools."], "package_details": ["is a console version of", ". It periodically displays information about your current graph in a text format. To use it, simply type:", "For a graphical version of", ", please see", ".", "The", "package contains the", "module, which implements a Python library for interacting with the low-level ROS Master API.", "For other Python libraries for interacting with the ROS graph, see", ",", ",", ", and", ".", "There are no plans to update the", "tool at this time.  The Python API may expand as necessary to provide access to other ROS graph primitives, though those are currently covered by the", ",", ", and", "libraries as well."]},
{"url": "https://wiki.ros.org/rosserial_tivac", "package": "rosserial_tivac", "package_summary": ["rosserial for TivaC Launchpad evaluation boards."], "package_details": ["will communicate either through UART0 or USB0:", "See also", ".", "This package contains all necessary extensions on", "to bring two Tiva C Launchpad boards from", "to ROS.", "All boards can use both debug USB and device USB to communicate with rosserial.", "Due to changes in USB library of TivaWare.", "This package contains the prepares the required libraries for Energia's IDE and also prepares a build configuration for", "packages based on", "GNU compiler toolchain and TI's TivaWare libraries.", "The", "page of this package will walk you through the steps for setting up your environment, and demonstrate how to develop applications, both for Energia and catkin.", "The SystemTick interrupt service must be available for", "to use, so it can keep the execution time.", "After going through the", "you should have understood that each project requires a", "which calls the function", "to prepare the build files."]},
{"url": "https://wiki.ros.org/dataspeed_ulc_can", "package": "dataspeed_ulc_can", "package_summary": ["Package to translate ROS messages to and from CAN messages to interact with the Universal Lat/Lon Controller (ULC) firmware"], "package_details": []},
{"url": "https://wiki.ros.org/ur10_moveit_config", "package": "ur10_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the ur10 with the MoveIt Motion Planning Framework"], "package_details": ["This package is part of the", "program. It is the", "! configuration for the UR10 arm, generated automatically by the", "Setup Assistant.", "Install the package from package management, and run the MoveIt! planning demo:", "This is not a real simulation, just a demonstration of the planning capability and the MoveIt! and RViz integration. For true simulation of a UR10, see the", "package.", "See also the relevant sections in the", "on Github."]},
{"url": "https://wiki.ros.org/toposens_markers", "package": "toposens_markers", "package_summary": ["Rviz integration for TS sensor data."], "package_details": []},
{"url": "https://wiki.ros.org/visp_auto_tracker", "package": "visp_auto_tracker", "package_summary": ["Online automated pattern-based object tracker relying on visual servoing.\n\n    visp_auto_tracker wraps model-based trackers provided by ViSP visual\n    servoing library into a ROS package. The tracked object should have a\n    QRcode, Flash code, or April tag pattern. Based on the pattern, the object is\n    automaticaly detected. The detection allows then to initialise the\n    model-based trackers. When lost of tracking achieves a new detection\n    is performed that will be used to re-initialize the tracker.\n\n    This computer vision algorithm computes the pose (i.e. position and\n    orientation) of an object in an image. It is fast enough to allow\n    object online tracking using a camera."], "package_details": ["is part of", "stack.", "centralises most of its parameters inside a configuration file following the", "default format.", "This package wraps an automated pattern barcode based tracker using", "library. The tracker estimates the pattern position and orientation with respect to the camera. It requires the pattern 3d model and a configuration file.", "The package is composed of one node called", ".  This node tries to track the object as fast as possible. The viewer coming with", "package can be used to monitor the tracking result.", "Currently the", "package requires calibration information from a camera_info topic. To this end", "package can be used.", "This is an example of a valid QR-code pattern that can be downloaded", ".", "This is an example of a valid flash-code pattern that can be downloaded", ".", "You can run", "on a pre-recorded bag file that comes with the package, or on a live video from a camera.", "To run", "on a pre-recorded image sequence, just run:", "The pattern used in this example can be downloaded", ".", "You have a ready-to-use roslaunch file in", ". This works with a firewire (1394) camera. If you have an usb camera (like a webcam) you can use", "launch file.", "When set (", ") this parameter activates the tracking lost detection and recovery using", ",", "and", "point coordinates.", "When you track a model, you probably want a visual feedback. You can get one by connecting rviz to the outputed", "topic.", "does not have a dedicated viewer. It can use the viewer provided with", "package, specifically", "node.", "Without connecting another node, you can also open a debug graphical output directly from the", "node by setting the", "parameter.", "The following figure shows the debug output (left) next to the external", "/viewer (right) in the case of the hybrid model-based tracker with QR-code initialisation:", "Use GitHub to", "."]},
{"url": "https://wiki.ros.org/maggie_motor_controller_msgs", "package": "maggie_motor_controller_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"maggie_motor_controller_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/maggie_motor_controller_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/stdr_robot", "package": "stdr_robot", "package_summary": [], "package_details": ["(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "The", "package implements a simulated robot, all simulated sensors and its simulated motion controller. Till now the following sensors are implemented:", "The robot class is available using the", "interface, named", ". To load a new robot a", "has to be running. New robots/nodelets can be loaded only from", ", using either", "or command-line tools described below.", "A parser for YAML and XML files is also provided, to load or save robots, sensors etc. More details on how to use YAML and XML files with stdr_simulator", ".", "A robot provides tf transforms for the pose of itself and its sensors. All transforms are relative to", "frame. For more details about map tf frames see", ". An example with one spawned robot follows (using", "):", "The", "for each sensor is defined on loading a robot from GUI or when using a YAML/XML file to describe a sensor. Each sensor", "has to have a unique name per robot. To avoid naming collisions with other robots it is also (automatically) prefixed with robot's name. Example:", ".", "Each robot provides a tf transform with its current pose. The", "is automatically assigned and has the format", ". Example:", ".", "All topic names are prefixed with robot name. Example", ".", "All services are prefixed with the name", ". This is the name of the nodelet manager and should", "change.", "With the", "command-line tool you can add, delete and move a robot directly from the terminal. The following sections describe the available commands.", "For tutorials see", "."]},
{"url": "https://wiki.ros.org/sdf_tracker", "package": "sdf_tracker", "package_summary": [], "package_details": ["This package provides an implementation of the truncated Signed Distance Function tracking algorithm, proposed", ".", "The initial starting point of the camera is at the center of the specified volume, looking along the z-axis. To change the initial camera pose, relative to the volume set the", "parameter of the SDF_Parameter class and pass this to the constructor when initializing your SDFTracker, e.g.,", "In the interactive mode, pressing", "or", "sets a flag to notify the node that it's time to shut down. Terminating the program with ctrl-C works, but will not output triangles."]},
{"url": "https://wiki.ros.org/socketcan_interface", "package": "socketcan_interface", "package_summary": ["Generic CAN interface description with helpers for filtering and driver implementation. Further a socketcan implementation based on boost::asio is included."], "package_details": ["This packages provides a generic CAN interface class and a", "-based driver implementation.", "The listeners are based on", "(since melodic) and use RAII-pointers.", "The SocketCAN driver interface is based on", "and provides concurrent access to SocketCAN interfaces. It is the default CAN implementation used throughout ros_canopen and requires Linux kerner 2.6.25 or newer.", "The SocketCAN driver is exposed as \"can::SocketCANInterface\" with base class can::DriverInterface via", ". In addition the plugin library is announced to", ".", "Further options are availabe, please consult", ". For automatic set-up, the network can be configured in", ", e.g.:"]},
{"url": "https://wiki.ros.org/nextage_moveit_config", "package": "nextage_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the NextageOpen with the MoveIt Motion Planning Framework."], "package_details": []},
{"url": "https://wiki.ros.org/warthog_description", "package": "warthog_description", "package_summary": ["URDF robot description for Warthog"], "package_details": ["This package provides a", "model of", ". For an example launchfile to use in visualizing this model, see", ".", "Warthog has a suite of optional payloads called accessories. These payloads can be enabled and placed on Warthog using environment variables specified at the time the", "is rendered to URDF. Available accessory vars are:", "As an alternative to individually specifying each accessory, some fixed configurations are provided in the package. These can be specified using the", "arg to", ", and are intended especially as a convenience for simulation launch.", "Please see", "for more information on simulating Warthog."]},
{"url": "https://wiki.ros.org/nextage_calibration", "package": "nextage_calibration", "package_summary": ["This package provides .launch files and other tools for\n  calibrating the head-mount cameras to the NEXTAGE Open robot.\n  As of version 0.7.15/March 2017, only Kinect/Xtion is capable (i.e. Ueye\n  cameras, the ones the robot comes with on this head by default, are not yet\n  handled)."], "package_details": ["Some info on", "about this package is available."]},
{"url": "https://wiki.ros.org/roshlaunch", "package": "roshlaunch", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/svenzva_drivers", "package": "svenzva_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_tutorials", "package": "ros_tutorials", "package_summary": ["ros_tutorials contains packages that demonstrate various features of ROS,\n    as well as support packages which help demonstrate those features."], "package_details": []},
{"url": "https://wiki.ros.org/rail_pick_and_place_msgs", "package": "rail_pick_and_place_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rail_pick_and_place_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/rail_pick_and_place_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/moveit_ikfast", "package": "moveit_ikfast", "package_summary": [], "package_details": ["/!\\", ":From ROS", "onward, this package is renamed as", "."]},
{"url": "https://wiki.ros.org/wge100_camera_firmware", "package": "wge100_camera_firmware", "package_summary": ["Source for the WGE100 Ethernet camera: Verilog source for the\n    FPGA, Forth source for the camera firmware.  Intended for camera\n    developers.  Note that a built binary from this package is checked\n    in under wge100_camera/firmware_images/"], "package_details": ["The Willow Garage 100 Mbps Ethernet (WGE100) camera is a 752x480 Ethernet camera developed for the PR2 robot.  This package contains the source code for the camera hardware and firmware.  If you want to develop or change the camera firmware, everything you need is in this package.  If you only want to use the WGE100 cameras, see package", ".", "The Verilog source for the camera firmware is under", ", with the main Makefile in", ".  You will need Xilinx ISE Webpack 11.1 or 11.3 to build the FPGA .bit file.", "The Forth source code for the", "CPU is under", ", see", "for build details.  You do not need the Xilinx tools to update the camera firmware."]},
{"url": "https://wiki.ros.org/perception_blort", "package": "perception_blort", "package_summary": [], "package_details": ["Currently, BLORT makes use of GLSL (OpenGL Shading Language) and requires GPU in order to run the tracker node."]},
{"url": "https://wiki.ros.org/rail_face_detector", "package": "rail_face_detector", "package_summary": [], "package_details": ["This detector uses", "to perform face detection. It publishes faces found in images from a subscribed image topic. The face detector itself can be found here:", ".", "This package contains a single ROS node -", "- which serves as an interface between a ROS system and the trained face recognition network.", "Type:", "Type:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:"]},
{"url": "https://wiki.ros.org/rail_object_detection", "package": "rail_object_detection", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/vigir_pluginlib", "package": "vigir_pluginlib", "package_summary": [], "package_details": [": Ensure all above steps have been done right. Another very weird issue may arise if you try to load plugins from a package A which have been depended from another package B which exports plugins too. NEVER DO THAT!!! As the library from A may be linked into B, while loading library B the", "may invoke all PLUGINLIB_EXPORT_CLASS macros from A too while being under the namespace of package B. This confuses the class_loaders as all plugins from A seems now to be part of package B.", "Use GitHub to", ". [", "]", "The", "is based on the exisiting", "system. It extends the basic plugin system by a convenient plugin management tool which enables to gather specific plugins based on their provided functionality from a heterogeneous plugin database.", "Hereby the basic infrastructure remains identically to the original", "system as the", "is built on top. Using the", "allows analogously to load classes from a runtime library (i.e. shared object, dynamically linked library) without the application having any prior awareness of the library or the header file containing the class definition (for details see the", "documentation).", "The", "uses the C++ RTTI mechanism to determine the functionality of each instantiated plugin based on implemented parent classes. This information helps the plugin manager to resolve any kind of plugin request done by the application during runtime and allows to manage a heterogeneous plugin database. For clarification, heterogeneous denotes indeed that you can load plugins of different type in one single manager and therefore have convenient centralized access to all your plugins no matter which interface they actually implement. If you need a plugin implementing a specific interface, then the plugin manager tries best effort to deliver them. Polymorphic plugins are indeed allowed, thus a single plugin may implement the interfaces of multiple interface plugins and still will be retrieved correctly.", "As an example use case for such kind of plugin system, please take a look at the", "stack.", "The", "class provides the low level basic functionality needed by the plugin manager. Therefore each new interface plugin must be derived from this class.", "See", ".", "See", ".", "Please take also a look at the", ".", "A Plugin Aggregator is a collector for a set of plugins implementing a specified interface and simplifies handling of such sets. It obtains automatically all plugins from the plugin manager and provides the option to update parameters of those plugins. The plain", "class is ready for use, but may be extended as demonstrated", "to perform accumulative operations using the plugins.", "The", "comes with a", "widget providing full access to all running plugin manager instance. The widget allows to  monitor the current state of all plugins and even to add and remove plugins during runtime. In", "this widget is located in the", "menu. Alternatively you can launch the standalone version:", "The", "uses", "under the hood where many magic is happening. This can cause many unforeseen issues."]},
{"url": "https://wiki.ros.org/mqtt_bridge", "package": "mqtt_bridge", "package_summary": ["The mqtt_bridge package"], "package_details": ["provides a functionality to bridge between ROS and MQTT in bidirectional.", "uses ROS message as its protocol. Messages from ROS are serialized by json (or messagepack) for MQTT, and messages from MQTT are deserialized for ROS topic. So MQTT messages should be ROS message compatible. (We use", "for message conversion.)"]},
{"url": "https://wiki.ros.org/asr_fake_object_recognition", "package": "asr_fake_object_recognition", "package_summary": ["This package provides a 'perception algorithm'-independent simulation of 6-D object localization for 3D object search by a mobile robot: Based on the poses of the searched objects with respect to the current viewing frustum(s) of the robot, the detectability of the objects is estimated."], "package_details": ["This package offers two sets of parameters you can adjust, the static ones which you can set by adjusting the params.yaml file located in the param-directory of the package, and the dynamic ones which you can either set by adjusting the launch-file or during runtime by using", "."]},
{"url": "https://wiki.ros.org/map_merger", "package": "map_merger", "package_summary": [], "package_details": ["The map_merger node uses the", "to distribute local maps, i.e., maps created by each robot, to other robots which attempt to merge other robots' local maps into their own to create a global map. The following picture shows a global map created by merging local maps of two robots.", "Changes in local maps are detected by the map_merger node which then automatically distributes the changes in the network using the", ". Upon reception of map updates by other robots, the map_merger node integrates the update using an existing transformation. If no transformation is available, the remote map update is stored for later processing. Upon availability of a transformation, the remote map is merged into a robot's own map. The map_merger node regularly publishes the global map on a distinct topic (see below) to which other nodes are required to subscribe to in order to receive the global map.", "You may obtain the paper from", "or search in", "."]},
{"url": "https://wiki.ros.org/rail_manipulation_msgs", "package": "rail_manipulation_msgs", "package_summary": ["Common Manipulation Messages and Services Used in RAIL Manipulation Packages"], "package_details": []},
{"url": "https://wiki.ros.org/rosjava_build_tools", "package": "rosjava_build_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/myahrs_driver", "package": "myahrs_driver", "package_summary": [], "package_details": ["This is a driver package for the WITHROBOT's", "from", "and", ". The myAHRS+ is a low cost high performance AHRS(Attitude Heading Reference System) with USB/UART/I2C interface. The myAHRS+ board contains a 3-axis 16-bit gyroscope, a 3-axis 16-bit accelerometer and a 3-axis 13-bit magnetometer. The driver should also work with USB port.", "The myAHRS+ board used NED type. The myahrs_driver contained in this package converts to the frame conventions of ROS (use the east north up (ENU) convention and right hand rule) before publishing the msgs. The driver use the coordinate frame below. Please see", "for more information.", "The myAHRS+ protocol can be found", ". The Forum for myAHRS+ user can be found", "."]},
{"url": "https://wiki.ros.org/ur_kin_py", "package": "ur_kin_py", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rail_segmentation", "package": "rail_segmentation", "package_summary": ["Segmentation Functionality from the RAIL Lab"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rail_segmentation\" in rosdoc: /var/www/docs.ros.org/en/api/rail_segmentation/manifest.yaml", "The", "package provides tabletop segmentation functionality given a point cloud.  It also allows for segmentation within a robot's coordinate frame, so that objects stored on a robot's platform can be segmented.", "To install the", "package, you can install from source with the following commands:", "Segmentation zones can be defined in yaml config files, an example of which can be found in the config directory.  The", "file defines a segmentation zone that will segment objects on horizontal surfaces anywhere above the level of the floor.", "Each resulting segmented object is represented by a", "message, with the following data calculated and filled in:", "The", "package can be launched by running the rail_segmentation node:"]},
{"url": "https://wiki.ros.org/shadow_robot_ethercat", "package": "shadow_robot_ethercat", "package_summary": ["This stack contains the drivers and the controllers for Shadow Robot's EtherCAT Hand."], "package_details": ["Our documentation can now be found on", "."]},
{"url": "https://wiki.ros.org/carrot_planner", "package": "carrot_planner", "package_summary": ["This planner attempts to find a legal place to put a carrot for the robot to follow. It does this by moving back along the vector between the robot and the goal point."], "package_details": ["(", ", default: Resolution of the associated costmap)", "The", "is a simple global planner that adheres to the", "interface found in the", "package and can be used as a global planner", "for the", "node. The planner takes a goal point from an external user, checks if the user-specified goal is in an obstacle, and if it is, it walks back along the vector between the user-specified goal and the robot until a goal point that is not in an obstacle is found. It then passes this goal point on as a plan to a local planner or controller. In this way, the carrot planner allows the robot to get as close to a user-specified goal point as possible.", "The", "object exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "The C++", "class adheres to the", "interface found in the", "package. For detailed documentation, please see", "."]},
{"url": "https://wiki.ros.org/rwt_ros", "package": "rwt_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/spur_description", "package": "spur_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_props", "package": "pr2_props", "package_summary": [], "package_details": ["The goal of pr2_props, aside from just generally being awesome and making you feel good, is to demonstrate the PR2's ability to do dynamic human interaction. It has been designed to use low-latency real-time controller packages like", "and", "so that PR2 is capable of quickly and sensitively responding to a human slapping the robot's hand.", "Currently", "supports 3 main behaviors:", "If you have not previously built the real-time controller libraries associated with the", "package dependency it is important you build pr2_props prior to launching the robot.", "In the above commands the values inside () are optional. The robot is naturally right-handed if no hand is specified.", "and", "have the same effect."]},
{"url": "https://wiki.ros.org/ur_gazebo", "package": "ur_gazebo", "package_summary": ["Gazebo wrapper for the Universal UR5/10 robot arms."], "package_details": ["This package is part of the", "program.", "See also the sections", "and", "in the", "on Github."]},
{"url": "https://wiki.ros.org/industrial_extrinsic_cal", "package": "industrial_extrinsic_cal", "package_summary": [], "package_details": ["The", "package provides a generic tool for calibrating sensors to a known reference frame.  It is relevant to anyone using a system in which the relative position(extrinsics) of multiple pieces of equipment must be determined. Common equipment examples include positioning systems(i.e. robots, cartesian gantries), measurement/sensor systems (i.e. camera(s), laser scanner/trackers, radio) and fixturing(accurately produced parts for referencing objects of interest).", "The industrial extrinsic calibration package depends on the google", ".  The steps below walk through a minimal installation of Ceres on Ubuntu 14.04 as required for this package, more detailed instructions or different Ubuntu versions can be found", ".", "These instructions download and install dependencies from your home directory.  Once installed, these tarballs and directories can be deleted.", "Detailed design info can be found in this", "presented at ROSCon 2014."]},
{"url": "https://wiki.ros.org/turtlebot3_autorace_control", "package": "turtlebot3_autorace_control", "package_summary": ["TurtleBot3 AutoRace ROS package that controls TurtleBot3 Auto"], "package_details": []},
{"url": "https://wiki.ros.org/automotive_autonomy_msgs", "package": "automotive_autonomy_msgs", "package_summary": ["Messages for vehicle automation"], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/explore_lite", "package": "explore_lite", "package_summary": ["Lightweight frontier-based exploration."], "package_details": ["Use GitHub to", ". [", "]", "uses", "for navigation. You need to run properly configured", "node.", "subscribes to a", "and", "messages to construct a map where it looks for frontiers. You can either use costmap published by", "(ie.", ") or you can use map constructed by mapping algorithm (SLAM).", "This package provides greedy frontier-based exploration. When node is running, robot will greedily explore its environment until no frontiers could be found. Movement commands will be send to", ".", "Unlike similar packages,", "does not create its own costmap, which makes it easier to configure and more efficient (lighter on resources). Node simply subscribes to", "messages. Commands for robot movement are send to", "node.", "Depending on your environment you may achieve better results with either SLAM map or costmap published by", ". Advantage of", "costmap is the inflation which helps to deal with some very small unexplorable frontiers. When you are using a raw map produced by SLAM you should set the", "parameter to some reasonable number to deal with the small frontiers. For details on both setups check the", "and", "launch files.", "Before starting experimenting with", "you need to have working", "for navigation. You should be able to navigate with", "manually through", ". Please refer to", "for setting up", "and the rest of the navigation stack with your robot.", "You should be also able to to navigate with", "though unknown space in the map. If you set the goal to unknown place in the map, planning and navigating should work. With most planners this should work by default, refer to", "if you need to setup this for", "planner (but should be enabled by default). Navigation through unknown space is required for", ".", "If you want to use costmap provided by", "you need to enable unknown space tracking by setting", ".", "If you have", "configured correctly, you can start experimenting with", ". Provided", "should work out-of-the box in most cases, but as always you might need to adjust topic names and frame names according to your setup.", "This package was developed as part of my bachelor thesis at", "in Prague.", "This project was initially based on", "package by Charles DuHadway. Most of the node has been rewritten since then. The current frontier search algorithm is based on", "by Paul Bovbel."]},
{"url": "https://wiki.ros.org/utexas_gdc", "package": "utexas_gdc", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pose_base_controller", "package": "pose_base_controller", "package_summary": ["A node that provides the move_base action server interface, but instead of\n    planning simply drives towards the target pose using a control-based\n    approach."], "package_details": []},
{"url": "https://wiki.ros.org/dwa_local_planner", "package": "dwa_local_planner", "package_summary": ["This package provides an implementation of the Dynamic Window Approach to\n        local robot navigation on a plane. Given a global plan to follow and a\n        costmap, the local planner produces velocity commands to send to a mobile\n        base. This package supports any robot who's footprint can be represented as\n        a convex polygon or cicrle, and exposes its configuration as ROS parameters\n        that can be set in a launch file. The parameters for this planner are also\n        dynamically reconfigurable. This package's ROS wrapper adheres to the\n        BaseLocalPlanner interface specified in the", "package."], "package_details": ["(", ", default: 2.5)", "(", ", default: 0.05)", "(", ", default: 1.7)", "(", ", default: 32.0)", "(", ", default: 0.05)", "(", ", default:", ")", "The", "package provides a controller that drives a mobile base in the plane.  This controller serves to connect the path planner to the robot.  Using a map, the planner creates a kinematic trajectory for the robot to get from a start to a goal location. Along the way, the planner creates, at least locally around the robot, a value function, represented as a grid map.  This value function encodes the costs of traversing through the grid cells.  The controller's job is to use this value function to determine dx,dy,dtheta velocities to send to the robot.", "The", "object is a", "for a", "object that exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "There are a large number of ROS", "that can be set to customize the behavior of the", "wrapper. These parameters are grouped into several categories: robot configuration, goal tolerance, forward simulation, trajectory scoring, oscillation prevention, and global plan. Most of these parameters can also be changed using", "to facilitate tuning the local planner in a running system.", "For C++ level API documentation on the", "class, please see the following page:", "The", "provides implementations of the DWA and Trajectory Rollout algorithms described earlier. In order to use the", "with ROS, please use the", ". It is not recommended to use the", "on its own.", "For C++ level API documentation on the", ", please see the following page:"]},
{"url": "https://wiki.ros.org/rosjava_bootstrap", "package": "rosjava_bootstrap", "package_summary": [], "package_details": ["Please see", "."]},
{"url": "https://wiki.ros.org/webrtc", "package": "webrtc", "package_summary": ["WebRTC Native API"], "package_details": ["A package that exports the", "libraries for use by other packages.", "The", "package does not export any include directories, libraries, or compiler options directly. This is because there are a substantial number of options and libraries that may cause issues with other libraries. Instead", "exports a number of CMake variables that can be used. See", "for example usage."]},
{"url": "https://wiki.ros.org/turtlebot_arm_description", "package": "turtlebot_arm_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/stage_ros", "package": "stage_ros", "package_summary": ["This package provides ROS specific hooks for stage"], "package_details": ["(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(default: 0.2)", "(default: true)", "\u2192", "\u2192", "\u2192", "\u2192", "The", "node wraps the Stage 2-D multi-robot simulator, via libstage.  Stage simulates a world as defined in a", "file.  This file tells stage everything about the world, from obstacles (usually represented via a bitmap to be used as a kind of background), to robots and other objects.", "The .world file syntax is documented in the", ". stageros only exposes models created by a subset of the .world file syntax, specifically", ",", "and", "models.  For examples, see the", "directory in the", "and", "packages.", "If there is only one position model defined in the world file, all of these topics appear at the top namespace. However, if more than 1 position models exist, these topics are pushed down into their own namespaces, by prefixing the topics with", ", e.g.,", "etc.", "If there is only one position model defined in the world file, all of these topics appear at the top namespace. However, if more than 1 position models exist, these topics are pushed down into their own namespaces, by prefixing the topics with", ", e.g.,", "etc.", "The", "topic gives simulated odometry, which is affected by settings in the .world file, which can change its origin and noise model (the transforms mentioned below use the same data); see the", "for details on changing this behavior.  The", "topic always provides a perfect, globally referenced pose for the robot in the simulation, independent of .world file settings.  The", "data is intended for testing purposes; it should not be used in robot control loops (because it's unrealistic).", "Stage supports the use of \"controllers,\" which are chunks of code that control simulated robots from inside the simulator, instead of being on the other end of a ROS connection.  There are some situations in which it can be advantageous to use Stage controllers. For a discussion of when and how to use Stage controllers, see", "."]},
{"url": "https://wiki.ros.org/pr2_precise_trajectory", "package": "pr2_precise_trajectory", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/topic_tools", "package": "topic_tools", "package_summary": ["Tools for directing, throttling, selecting, and otherwise messing with\n    ROS topics at a meta level. None of the programs in this package actually\n    know about the topics whose streams they are altering; instead, these\n    tools deal with messages as generic binary blobs. This means they can be\n    applied to any ROS topic."], "package_details": []},
{"url": "https://wiki.ros.org/aruco_mapping", "package": "aruco_mapping", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Using", "to estimate full 6 DOF position only by means of single calibrated camera is well known approach that has been utilized for quite a long time now. This package leverages basic", "functionality and provides tools to create a map of detected markers in 2D/3D space. It is designed for", "scenario", "and can be used for various navigation tasks for UAVs, UGVs, etc.", "In order to achieve successfull mapping, everytime when a new marker is detected, previous marker needs to be visible in the actual image to allow computing new marker's position. (See", "for better understanding). Keep this principle in mind when placing markers in your environment and do not overdo their mutual distances.", "In order to to calibrate your camera and get results in INI format, we stongly suggest", "package.", "Here is an example of launch file to run", ",", "driver and", ":", "In case you use other camera driver, remap", "to your topic name. Do not forget to adopt", ",", "and other params to your setup. If everything is set and ready, launch the aruco_mapping by following command:", "If you are experiencing problems with basic aruco detector caused by lighting conditions (strong reflections, poor lighting, bad focus) try to include our", "into your processing pipeline in order to improve the raw image."]},
{"url": "https://wiki.ros.org/thingmagic_usbpro", "package": "thingmagic_usbpro", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/polar_scan_matcher", "package": "polar_scan_matcher", "package_summary": [], "package_details": ["The", "package is a wrapper around Polar Scan Matcher [1], courtesy of:", "Albert Diosi and Lindsay Kleeman", "Intelligent Robotics Research Centre (IRRC)", "Monash University", "The package allows to scan match between consecutive", "messages, and publish the estimated position of the laser as a", "or a", "transform.", "An estimation for theta can optionally be provided to improve accuracy, in the form of a", ". This message would typically be published by an IMU or other angular rate sensor.", "Alternatively, an estimation for x, y, and theta can optionally be provided to improve accuracy, in the form of a", "transform. This transform would typically be published by an odometry system. This has not yet been tested.", "You can run the", "on a pre-recorded bag file that comes with the package. First, make sure you have the", "stack downloaded and installed by following the instructions", ".", "Please use our", "to", "or", "."]},
{"url": "https://wiki.ros.org/vision_visp", "package": "vision_visp", "package_summary": ["Virtual package providing ViSP related packages."], "package_details": ["Get", "stack:", "Use GitHub to", "."]},
{"url": "https://wiki.ros.org/stereo_image_proc", "package": "stereo_image_proc", "package_summary": ["Stereo and single image rectification and disparity processing."], "package_details": []},
{"url": "https://wiki.ros.org/rc_tagdetect_client", "package": "rc_tagdetect_client", "package_summary": ["The ros client for roboception tag detection modules"], "package_details": ["Use GitHub to", ". [", "]", "See", "and", "for more details.", "This node provides ROS service calls and parameters for the", "module.", "For detail description of the", "module check the", "."]},
{"url": "https://wiki.ros.org/roscpp_tutorials", "package": "roscpp_tutorials", "package_summary": ["This package attempts to show the features of ROS step-by-step,\n    including using messages, servers, parameters, etc."], "package_details": ["contains a number of tutorial applications for programming with roscpp.", "You can browse these tutorials by", "-ing to the", "package, i.e."]},
{"url": "https://wiki.ros.org/rosh_robot_plugins", "package": "rosh_robot_plugins", "package_summary": [], "package_details": ["is a Python-based shell and runtime environment for ROS.  It leverages the IPython shell environment to provide tab-completion introspection across various ROS APIs, like topics, services, parameters, and nodes.  It is similar to using tools like", "and", ", but with Pythonic semantics and the convenience of a Python interpreter.  You can also develop ROS nodes using rosh, which we call \"roshlets\".", "To get started, please see the", "documentation.", "rosh_robot_plugins houses stacks related to the \"robot\" variant, which was introduced in", ". The robot variant focuses on on-robot capabilities, such as", "and", "libraries."]},
{"url": "https://wiki.ros.org/stereo_slam", "package": "stereo_slam", "package_summary": [], "package_details": ["stereo_slam is a ROS node to execute Simultaneous Localization And Mapping (SLAM) using only one stereo camera. The algorithm was designed and tested for underwater robotics. This node is based on the", "library for graph optimization and uses the power of", "to find loop closures between graph nodes. It uses a keyframe to multi-keyframe loop closing mechanism, based on keypoint clustering, to improve the SLAM corrections on feature-poor environments.", "See the documentation on", "."]},
{"url": "https://wiki.ros.org/turtlebot_interactive_markers", "package": "turtlebot_interactive_markers", "package_summary": [], "package_details": ["This", "will walk you through using interactive markers to control the", "."]},
{"url": "https://wiki.ros.org/topics_rviz_plugin", "package": "topics_rviz_plugin", "package_summary": ["Display topics values in a RViz plugin"], "package_details": ["Documentation is here:"]},
{"url": "https://wiki.ros.org/nextage_ros_bridge", "package": "nextage_ros_bridge", "package_summary": ["A main ROS interface for developers and users of", "dual-armed robot from Kawada Robotics Inc. Developers can build their own application that takes control over Nextage via this package. Interface for both ROS and", "is provided."], "package_details": ["is a python class that functions as a programming interface for the robot users. As seen in the api document, it extends", "class so that all the public methods are inherited from there on.", "The reason", "was created separately from", "is because of the", "design unique to", "robot."]},
{"url": "https://wiki.ros.org/explorer", "package": "explorer", "package_summary": [], "package_details": ["The", "utilizes frontier based exploration to discover environments autonomously operating a distributed multi-robot system. Beside frontier detection, coordinated and uncoordinated exploration strategies are available to select goal points. Coordinated exploration enhances robot distribution and reduces redundancy in exploration which result in improvement of efficiency in terms of exploration time.", "The", "comprises multiple functionalities to perform frontier based exploration. Frontier detection is utilized on local and global costmaps to further select navigation goals in the environment to proceed with exploration. The assignment of robots to goals is accomplished according to coordinated and uncoordinated exploration strategies being applied for the distributed multi-robot system.", "Auctioning thereby ensures negotiation among available goals to coordinate efficiently, distributing robots among the environment by minimizing the overall travel path. Additionally to frontier detection and selection, the", "is concerned with navigation to goal points by incorporating a simple action client utilizing", ".", "You may obtain the paper from", "or search in", "."]},
{"url": "https://wiki.ros.org/nav2d_remote", "package": "nav2d_remote", "package_summary": ["This package is used to manually control a robot that uses the operator and\n    navigator node from navigation_2d. Currently there is one node to control one\n    robot with a joystick and one to control multiple robots in simulation.\n    It can send commands directly to the operator or start and stop navigator actions."], "package_details": []},
{"url": "https://wiki.ros.org/reemc_description", "package": "reemc_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/slam_karto", "package": "slam_karto", "package_summary": ["This package pulls in the Karto mapping library, and provides a ROS\n     wrapper for using it."], "package_details": ["Part of the documentation is available in the previously maintained", ".", "Use github to", "."]},
{"url": "https://wiki.ros.org/ethercat_hardware", "package": "ethercat_hardware", "package_summary": ["Package for creating a hardware interface to the robot using the EtherCAT motor controller/driver"], "package_details": ["will respond with:", "The", "package's primary purpose is to provide a library for communicating with motor controller boards.  However, the package does provide the", "command-line tool for configuring these boards.  In practice, this tool is used during robot assembly, and should not be needed after initial bring-up of the robot.", "When running motorconf, you must specify the interface used to communicate with the EtherCAT devices.  Without any additional arguments,", "will enumerate all of the EtherCAT devices it can find.", "In order to program an unconfigured device, or re-program a device, you must specify a name, motor type, and board type for this motor.  If the name given (using the", "option) matches one of the names in the actuators configuration file (", ", by default), then the motor type and board type will be selected automatically.  The motor type can be specified explicitly with the", "option, and the board type can be specified with the", "option.  A list of valid actuator names and motor types can be found with the", "option.  In addition to the name, motor, and board types,", "needs to know which device in the EtherCAT chain to program.  The device number is specified with the", "option.  Finally, the", "option tells", "to actually program the board.  The following example programs device #2 to be the", ":", "actuators.conf is an XML file that specifies the motor parameters and common motor names to be programmed into the motor controller boards.  The file consists of a single <configuration> section.  The <configuration> section contains two subsections: <motors> and <actuators>.", "The <motors> subsection contains a series of <motor> definitions.  Each motor requires a", "attribute.  The <motor> also requires child elements <params> and <encoder>.  The <params> element contains the following attributes:", "The <encoder> element contains the following attributes:", "The <actuators> subsection contains a series of <actuator> definitions.  An <actuator> has the following attributes:", "For example, the following <actuator> definition states that the", "should be configured with the motor parameters specified in the previous example:"]},
{"url": "https://wiki.ros.org/move_slow_and_clear", "package": "move_slow_and_clear", "package_summary": ["move_slow_and_clear"], "package_details": ["(", ", default: 0.5)", "The", "is a simple recovery behavior that clears information in the", "and then limits the speed of the robot. Note, this recovery behavior is not truly safe, the robot may hit things, it'll just happen at a user-specified speed. Also, this recovery behavior is only compatible with local planners that allow maximum speeds to be set via", "such as the", ".", "The", "object exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "The C++", "class adheres to the", "interface found in the", "package. For detailed documentation, please see", "."]},
{"url": "https://wiki.ros.org/v4r_ellipses", "package": "v4r_ellipses", "package_summary": [], "package_details": ["Chen2004) Chen, Q.; Wu, H. & Wada, T. Pajdla, T. & Matas, J. (Eds.) Camera Calibration with Two Arbitrary Coplanar Circles Computer Vision - ECCV 2004, Springer Berlin Heidelberg, 2004, 3023, 521-532,"]},
{"url": "https://wiki.ros.org/libsick_ldmrs", "package": "libsick_ldmrs", "package_summary": ["A library for communication with the SICK LD-MRS series of laser scanners."], "package_details": ["Use GitHub to", ". [", "]", "This package contains a library for communicating with the SICK LD-MRS line of laser scanners. For a ROS wrapper, see", "."]},
{"url": "https://wiki.ros.org/svenzva_simulation", "package": "svenzva_simulation", "package_summary": [], "package_details": ["This package contains relevant files for running Svenzva robots in 3D simulations. Currently supported simulations are through Gazebo,", "!, or both Gazebo and Moveit!.", "For control of robot arms in simulation we use", "plugins for Gazebo.", "This provides software level controllers for each joint which likely will not translate 1-1 on the real robot.", "Tips on tuning PID parameters for", "can be found on Gazebo's", "plugin page (located", ") under the section \"Tuning PID Parameters\".", "The tutorial for 3D simulations using Gazebo and/or", "can be found at"]},
{"url": "https://wiki.ros.org/rc_visard", "package": "rc_visard", "package_summary": ["Roboception rc_visard support meta package"], "package_details": ["is a meta package of the ROS interface for the", "3D sensor.", "contains the packages", "and", ".", "The", "is the world\u2019s first 3D sensor that allows robots to perceive their environment in 3D and localize themselves in space.", "The", "package contains xacro and urdf files for the two baseline versions of the", "(", ",", ").", "The", "is the official ROS driver for the", "which provides ROS parameters (configuration), ROS services (control of", "s dynamic module) and ROS topics (sensor data: Images, Stereo Data, Point Clouds, Dynamic State i.e. poses and IMU data, TF).", "Purchase one of the rc_visard variants available right now and continue with the", ":"]},
{"url": "https://wiki.ros.org/sr_gazebo_plugins", "package": "sr_gazebo_plugins", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/warthog_gazebo", "package": "warthog_gazebo", "package_summary": ["Launchfiles to use Warthog in Gazebo."], "package_details": ["This package contains launch files to spawn", "in some example environments. Please see", "for usage."]},
{"url": "https://wiki.ros.org/rsv_balance_desktop", "package": "rsv_balance_desktop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/world_canvas_server", "package": "world_canvas_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/svenzva_ros", "package": "svenzva_ros", "package_summary": [], "package_details": ["Source code is available on", "which also contains instructions for installation and compilation.", "General tutorials, guides and discussions on implementation can be found on the svenzva_ros", "."]},
{"url": "https://wiki.ros.org/summit_x_common", "package": "summit_x_common", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", ", shared for real robot and simulation."]},
{"url": "https://wiki.ros.org/tf_remapper_cpp", "package": "tf_remapper_cpp", "package_summary": ["More efficient version of tf/tf_remap able to handle TFs at kHz with tens of subscribers."], "package_details": ["This package is an alternative to official ROS node", "with the following advantages:"]},
{"url": "https://wiki.ros.org/toposens", "package": "toposens", "package_summary": ["ROS support for Toposens 3D Ultrasound sensors."], "package_details": ["ROS packages for", "These packages support the", "ultrasonic sensor by Toposens."]},
{"url": "https://wiki.ros.org/tf2_kdl", "package": "tf2_kdl", "package_summary": ["KDL binding for tf2"], "package_details": ["Please see the", "for use."]},
{"url": "https://wiki.ros.org/rosparam", "package": "rosparam", "package_summary": ["rosparam contains the rosparam command-line tool for getting and\n    setting ROS Parameters on the", "using YAML-encoded files. It also contains an\n    experimental library for using YAML with the Parameter\n    Server. This library is intended for internal use only.\n\n    rosparam can be invoked within a", "file."], "package_details": ["uses a 1-to-1 correspondence between", "types and YAML types. For example:", "is a stable command-line tool within the ROS core toolchain. No major feature development is currently scheduled for this tool.", "YAML is a lightweight markup language that supports all parameter types. For more on YAML, see", ". For tips on entering YAML in at the command-line, please see the", "guide.", "YAML dictionaries can occur as the argument to the", "and", "commands of", ".  Dictionaries in this context are interpreted differently from namespace dictionaries that are set as the value of a parameter (e.g. from a C++ or Python node). Instead of", "a parameter namespace, dictionaries", "are unpacked into individual parameters to be set on the Parameter Server. Thus,", "dictionaries can be thought of as", "new values to a parameter namespace.", "The", "tag enables the use of the", "tool for loading and dumping parameters encoded in YAML files.  The", "tag can be put inside of a", "tag, in which case the parameter is treated like a", ".", "The", "tool enables command-line setting and getting of parameters as well as loading and dumping", "state to a file. The currently supported commands are:", "Command-line arguments to rosparam obey the", "environment variable (see", "). Parameter names that are not globally specified are resolved with respect to", ".", "NOTE:", "and", "are essentially the same command, as are", "and", ", with the only difference being whether or not a file is used."]},
{"url": "https://wiki.ros.org/ur_description", "package": "ur_description", "package_summary": ["URDF description for Universal UR3(e), UR5(e), UR7e, UR10(e), UR12e UR16e, UR15, UR20 and UR30 robots"], "package_details": ["This package is part of the", "program.", "To view and manipulate the arm models in", ", install the package from package management and launch the following:", "You should see an rviz window showing the UR5 in a lying-down position, and a separate window where the joint values may be manually specified. Note that this is not a simulation, just a visualization of the arm model. To simulate UR5 or UR10, see", "."]},
{"url": "https://wiki.ros.org/multi_level_map_msgs", "package": "multi_level_map_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/wheeled_robin_driver", "package": "wheeled_robin_driver", "package_summary": [], "package_details": ["This is a generic driver for", ". Port of pyrobot.py by Damon Kohler and", "by OSRF. For ROS bindings, please see", "."]},
{"url": "https://wiki.ros.org/universal_teleop", "package": "universal_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_ez_publisher", "package": "rqt_ez_publisher", "package_summary": ["The rqt_ez_publisher package"], "package_details": ["2. run as plugin of", "Plugins -> Topics -> Easy Message Publisher", "Input topic name -> You got GUI", "A. Click \"config (gear) icon\" -> set repeat interval [ms]"]},
{"url": "https://wiki.ros.org/ros_cvb_camera_driver", "package": "ros_cvb_camera_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qb_device_srvs", "package": "qb_device_srvs", "package_summary": ["This package contains the device-independent custom ROS services for qbrobotics\u00ae devices."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"qb_device_srvs\" in rosdoc: /var/www/docs.ros.org/en/api/qb_device_srvs/manifest.yaml", "Each", "device-independent custom ROS service is documented directly in its", "specification and it is designed to fit the Communication Handler requirements (cf.", "). We recommend not to use these services for other purposes outside the", "ecosystem."]},
{"url": "https://wiki.ros.org/rsv_balance_gazebo", "package": "rsv_balance_gazebo", "package_summary": [], "package_details": ["This package provides all the necessary URDF model extensions, worlds and launch files for successfully simulating", "'s self-balance platform.", "On", "package we have available 3 worlds:"]},
{"url": "https://wiki.ros.org/applanix_msgs", "package": "applanix_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_teleop", "package": "pr2_teleop", "package_summary": ["The pr2_teleop package"], "package_details": ["Note: before moving the robot base, you may want to", ".", "As with all applications, you must first", ".", "Before use, the PS3 controller must be \"paired\" with the robot. If your controller is not already paired, you can pair it by pressing the center button, shown in the image.  If you need to pair a new PS3 controller to the PR2 (i.e. not the controller that came with it), see", ".", "Note: The", ",", ",", ", and", "buttons are all labeled on the controller.", "Now you should be able to control the robot base with keyboard commands in the shell where you ran the above", "command."]},
{"url": "https://wiki.ros.org/bwi_guidance_concert", "package": "bwi_guidance_concert", "package_summary": [], "package_details": ["The", "package wraps this experiment to use the", "framework.", "This package currently wraps preliminary work on this project, where a central positioner node teleports each robot to a desired location using Gazebo's", "service. Additionally, each robot subscribes to an image stream which is displayed on its simulated robot screen (ex. '/robot1/image'), and these images are also published by the positioner.", "Apart from the positioner node, an experiment controller node decides which exact problem the user is facing, and a server node keeps track of which user is interfacing with the system. A user controls a human avatar inside the simulator using a web based GUI that talks to the rest of the system using", ".", "Once you get to the", "page, follow the instructions to run through the experiment!"]},
{"url": "https://wiki.ros.org/tuw_msgs", "package": "tuw_msgs", "package_summary": ["The tuw_msgs meta package"], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/fake_localization", "package": "fake_localization", "package_summary": ["A ROS node that simply forwards odometry information."], "package_details": ["The", "package provides a single node,", ", which substitutes for a localization system, providing a subset of the ROS API used by", ". This node is most frequently used during simulation as a method to provide perfect localization in a computationally inexpensive manner.", "Specifically,", "converts odometry data into pose, particle cloud, and transform data of the form published by", "."]},
{"url": "https://wiki.ros.org/rwt_image_view", "package": "rwt_image_view", "package_summary": ["The rwt_image_view package"], "package_details": []},
{"url": "https://wiki.ros.org/multimaster_fkie", "package": "multimaster_fkie", "package_summary": ["The metapackage to combine the nodes required to establish and manage a multimaster network. \n    This requires no or minimal configuration. The changes are automatically detected and synchronized."], "package_details": ["- Technical Report by Sergi Hernandez Juan and Fernando Herrero Cotarelo"]},
{"url": "https://wiki.ros.org/rosparam_handler", "package": "rosparam_handler", "package_summary": ["An easy wrapper for using parameters in ROS."], "package_details": []},
{"url": "https://wiki.ros.org/ddwrt_access_point", "package": "ddwrt_access_point", "package_summary": [], "package_details": ["Provides a node for controlling a Linksys WRT610Nv2 (or compatible) access point with the", "firmware. It has been tested with the firwmare version", ". Other dd-wrt firmware versions and access point models may be compatible with this node provided the web interface is the same.", "See", "and", "for more details."]},
{"url": "https://wiki.ros.org/sr_communications", "package": "sr_communications", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libsensors_monitor", "package": "libsensors_monitor", "package_summary": ["A ROS node for using libsensors to provide diagnostics information about the sensors on a computer system."], "package_details": []},
{"url": "https://wiki.ros.org/rospy_tutorials", "package": "rospy_tutorials", "package_summary": ["This package attempts to show the features of ROS python API step-by-step,\n    including using messages, servers, parameters, etc. These tutorials are compatible with the nodes in roscpp_tutorial."], "package_details": ["rospy_tutorials is a series of tutorials for using the", "client API. You can browse these tutorials by", "-ing to the", "package, i.e."]},
{"url": "https://wiki.ros.org/rtt_ros_comm", "package": "rtt_ros_comm", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/xbot_face", "package": "xbot_face", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tedusar_cartesian_controller", "package": "tedusar_cartesian_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/laser_joint_processor", "package": "laser_joint_processor", "package_summary": ["Computes joint angles associated with a specific set of detected checkerboard corners.\n     This package is experimental and unstable.\n     Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/rtt_ros_integration", "package": "rtt_ros_integration", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/speech_recognition_msgs", "package": "speech_recognition_msgs", "package_summary": ["speech_recognition_msgs"], "package_details": []},
{"url": "https://wiki.ros.org/toposens_sync", "package": "toposens_sync", "package_summary": ["Operational sync of multiple TS sensors."], "package_details": ["This package enables simultaneous use of multiple TS3 devices in a sensor system. It administers the lifecycle and ultrasonic emission characteristics of each sensor to coordinate incoming datastreams. Is is designed as a thin layer handling multiple", "::Sensor instances that individually encapsulate all the device communication and logic flow."]},
{"url": "https://wiki.ros.org/turtlebot_calibration", "package": "turtlebot_calibration", "package_summary": [], "package_details": ["To use this package please follow the"]},
{"url": "https://wiki.ros.org/asr_grid_creator", "package": "asr_grid_creator", "package_summary": ["This package can generate a grid for the current map. Each grid_point\n    defines a position where the robot has to move to. The grid can be used\n    later on in the asr_direct_search_manager as a basis to generate poses to\n    search the map. At each grid_point the robot will search around him. All\n    gird_points together should cover the map."], "package_details": ["(MarkerArray): Visualisation of the grid", "The path to a file where the generated grid should be saved", "the width of the grid", "the hieght of the grid !", ": the shape of each", "It can be Hex or Quad !", ": if the generated positions should make a", "or not", ": start postition of the robot (for sorting the postitions)", "roslaunch asr_robot_model_services RobotModelServiceSim.launch", "!", ": the size of each cell or rather the half of the distance between two neighbors of", ": horizontal translation offset applied to the grid", ": vertical translation offset applied to the grid", ": rotation offset applied to the grid", "The (", ") defines the ranges in which the generation took place. The best one will be saved at the end. The best grid is the one with the most", ".", "asr_robot_model_services:", ", GetDistance", "The generation of the grid is part of the", "."]},
{"url": "https://wiki.ros.org/phantomx_reactor_arm", "package": "phantomx_reactor_arm", "package_summary": [], "package_details": ["This package contains the different controllers and description files for"]},
{"url": "https://wiki.ros.org/khi_robot_control", "package": "khi_robot_control", "package_summary": ["ROS KHI robot controller package based on ros_control"], "package_details": []},
{"url": "https://wiki.ros.org/pi_trees", "package": "pi_trees", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "A Python implementation for using Behavior Trees and ROS for task management.  Please see the", "or the book \"", "\"."]},
{"url": "https://wiki.ros.org/rcll_ros", "package": "rcll_ros", "package_summary": [], "package_details": ["This is a meta package covering the ROS packages related to the", "and the", ".", "This metapackage pulls the", "and", "packages.", "You might also want to have a look at the simulation integration package", "."]},
{"url": "https://wiki.ros.org/moveit_full", "package": "moveit_full", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_opcua_impl_freeopcua", "package": "ros_opcua_impl_freeopcua", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package provides communication interface between ROS and", "communication standard using", "written in C++. This package currently implements an OPC UA Client with basic functionality. For more details see the node description.", "Check the", "page."]},
{"url": "https://wiki.ros.org/unique_id", "package": "unique_id", "package_summary": ["ROS Python and C++ interfaces for universally unique identifiers."], "package_details": ["This package provides Python and C++ interfaces for", ", as described in", "."]},
{"url": "https://wiki.ros.org/object_recognition_tabletop", "package": "object_recognition_tabletop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/fawkes_msgs", "package": "fawkes_msgs", "package_summary": ["Messages used by Fawkes to interact with ROS."], "package_details": ["This package contains the message types specific to the integration with the", ". It is used in several of the", ".", "It is used, for example, for the", "for ROS."]},
{"url": "https://wiki.ros.org/vrpn_client_ros", "package": "vrpn_client_ros", "package_summary": ["ROS client nodes for the", "library, compatible with VICON, OptiTrack, and other", "."], "package_details": ["To debug connection issues, try to use", "'s CLI tools, such as", ", to verify that a connection to the Tracker object of interest can be established. If you cannot get this to work, note that debugging networking or VRPN issues is outside the scope of this ROS interface package, and see", "for further guidance.", "Please check the", "for common problems, or open an", "if still unsolved. See sample configuration launch file", "."]},
{"url": "https://wiki.ros.org/segbot_gui", "package": "segbot_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot_arm_moveit_demos", "package": "turtlebot_arm_moveit_demos", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roslibjs_experimental", "package": "roslibjs_experimental", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/socketcan_bridge", "package": "socketcan_bridge", "package_summary": ["Conversion nodes for messages from SocketCAN to a ROS Topic and vice versa."], "package_details": ["The packages provides functionality to expose CAN frames from", "to a ROS Topic. Internally it uses the", "from the", "package, as such it is capable of dealing with both normal and extended CAN frames. For more information and hardware related information see", ".", "The functionality is offered in the form of three nodes:", ",", "and", ". To receive frames from and sent frames to the same CAN device, the", "needs to be used to prevent every sent message from being echoed to the receiving topic."]},
{"url": "https://wiki.ros.org/mjpegcanvas", "package": "mjpegcanvas", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sr_edc_controller_configuration", "package": "sr_edc_controller_configuration", "package_summary": ["contains the different launch files for Shadow Robot hand controllers. The actual configuration files are\n    stored in the sr_config stack."], "package_details": ["See", "for more details on the actual implementation of the controllers.", "The Parameters are saved in the different", "file:", "The package also contains one launch file per controller type. You can change which controller is started by default by editing", ".", "Just make sure you only have one type of controllers started (otherwise one of them is going to be ignored by the controller manager).", "The controller manager is started by the", "file (which is called from", "/sr_edc.launch file)."]},
{"url": "https://wiki.ros.org/roswtf", "package": "roswtf", "package_summary": ["roswtf is a tool for diagnosing issues with a running ROS system. Think of it as a FAQ implemented in code."], "package_details": ["will examine your ROS setup, such as your", ", and look for configuration issues. If you have a ROS system online, it will look at it and check for any potential issues.", ":", "performs those checks based on the directory you run it from. For example, if you run it in the", "stack, it will perform it's filesystem checks based on files in the", "stack and its dependencies.", "accepts the following command-line options:", "looks for many, many things, and the list is always growing. There are two categories of what it looks for: file-system issues and online/graph issues.", "produces a report containing both warnings and errors based on the checks it performed. In general, warnings are something that seems odd, but may be just fine. Errors are known problems that you should probably address if you are experiencing problems.", "will continue to evolve to try and diagnose more complex problems that may arise in large ROS systems. There are currently plans to do checks for multi-machine setups, as well as expand the range of its checks via the plugin API.  Recommendations for checks that can be performed are always welcome.", "Other than the general checks,", "has two usages.", "Or you can also run", "on a", "file:", "For file-system issues,", "looks at your environment variables, package configurations, stack configurations, and more. It can also take in a", "file and attempt to find any potential configuration issues in it, such as packages that haven't been built properly.", "For online issues,", "examines the state of your current graph and tries to find any potential issues. These issues might be unresponsive nodes, missing connections between nodes, or potential machine-configuration issues with", ".", "Please see", "."]},
{"url": "https://wiki.ros.org/vigir_footstep_planning", "package": "vigir_footstep_planning", "package_summary": [], "package_details": ["Before the direction commands become activated you have to select a parameter set from the parameter selection section.", "The terrain generator does only consider all point cloud data around the current robot pose to reduce computational cost. Therefore you should place a", "(hotkey \"p\") in RViz in a feasible region of the input pointcloud (see below) to obtain a world model.", "Use GitHub to", ". [", "]", "The", "stack provides an integrated full 3D footstep planner. It was originally based on the search-based", "(using A* from SBPL) and has been intensively extended/rewritten to enable the generation of feasible footstep placements based on perceived 3D data. It can cope with sloped terrain and uses overhanging steps to improve planning performance. The footstep planning system is designed to be easily deployable and adaptable to any humanoid bipedal robot. It can be either used as a 3D planner out of the box, as a research tool in bipedal search-based planning or for benchmarking walking controllers in difficult terrain.", "For improvement mission performance in real world scenarios, the footstep planner implements a comprehensive set of coactive footstep planning services. In this way, it enables human-in-the-loop planning to combine human intelligence and capable footstep placement algorithms to generate quickly a safe sequence of footstep placements through challenging terrain (examples see under", ").", "This allows for adaptive code execution even during runtime which is superior to classic parameter-based systems. Although plugins can provide new code for the pipeline, already existing code is kept untouched which simplifies code maintenance and improves code stability. In order to achieve this kind of versatile code management, the", "has been developed.", "See under", ".", "The", "stack consists of multiple repositories located at Git", "Hub:", "All generated step plan are published on", ".", "You can just place a start pose (", "(hotkey \"p\")) and goal pose (", "(hotkey \"g\")) to trigger planning. You should be able to follow the planning process and receive a result at the end.", "The planning system is also capable to provide manual step generation. For this purpose the", "widget can be launched by:", "Using this widget allows to lay down patterns of step placements manually. Each parameter can be set individually in this widget. It also includes an interface for the", "which manages step execution on the robot.", "For a quick demonstration of the 3D planning capabilities the", "package can be used here. In order to use that package clone and compile from", "Create the", "subfolder in the", "package. Download and extract the example pointcloud files from", "into this recently created directory. Afterwards you are able to launch the terrain generator test environment (while the footstep planning system is already running in the background):", "As already mentioned above, you need to set the fake robot pose by placing a", "(hotkey \"p\"). If you place it like illustrated in the image below, then you should get a nice world model of the pitch ramp scenario.", "Please wait a few seconds until the world model is reasonable dense. Now you can request footstep plans over the pitch ramp by placing a", "(hotkey \"g\"). After a few seconds you should see results similar to that demonstrated on the picture below:", "You can also use your own pointcloud data as the", "can accumulate data from any arbitrary source. Just launch the standalone", ":", "Now you can just publish your pointcloud data as incremental updates at", "in a common frame (e.g.", ").", "If you wish to just generate the terrain model from a single pointcloud, the data must be published on", ".", "The", "stack is accompanied by the", "package which enables seamless integration to the low-level motion layer. In particular, this includes step queue management and step queue spooling. Using this package should simplify integration to other robot platforms while providing high-level functionality such as continuous walking (by continuous updating the step queue).", "The", "stack takes heavy use of the", "package due to heavy use of plugins (see", "). In this step-by-step tutorial we do not discuss details about the", "as we refer to the", "documentation for details. We recommend to read through the basics of the", "to understand how the footstep planning system can be customized easily.", "Please take note of the", "which provides seamless low-level hardware integration and step queue management in order to simplify even more the migration process while providing a capable step queue management system that allows even for continuous walking.", "During the Humanoids@Robo", "Cup Demo 2016 at Leipzig, the footstep planner was used as well.", "If you would like to try it out in simulation by yourself, then just follow the install instruction of the basic THORMANG software", "which provides a fully working robot using Gazebo simulation.", "When Gazebo has started up, first unpause the simulator. Afterwards, you can bring the robot in", "mode by using the", ". You have to proceed following states with the robot:", "From this point, you can work with the", ". After selecting a parameter set you can command simple step patterns and directly execute them afterwards. As long you do not push the limits too hard, the robot will execute the steps safely in simulation.", "As explained", "you can use RViz to generate step plans. After a step plan has been generated you can hit the", "button in the", "which will then execute the recently generated plan."]},
{"url": "https://wiki.ros.org/kobuki_desktop", "package": "kobuki_desktop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rplidar_ros", "package": "rplidar_ros", "package_summary": ["The rplidar ros package, support rplidar A1/A2/A3/S1/S2/S3/T1/C1"], "package_details": []},
{"url": "https://wiki.ros.org/transform_graph", "package": "transform_graph", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "is a library for computing transformations between coordinate frames in an arbitrary graph structure.", "maintains the graph of transformations and is the primary interface to transform_graph:", "The library's generated documentation explains how to use", "in detail.", "Below are a few quick examples illustrating how it can be used.", "Add frames to the graph using", ":", "Get points in different frames using", ".", "In this example, we want to know what a point 10 cm in front of the robot's wrist is, expressed in the base frame:"]},
{"url": "https://wiki.ros.org/osg_interactive_markers", "package": "osg_interactive_markers", "package_summary": ["This package is basically an OpenSceneGraph (OSG) adaptation of the Interactive Markers client writen for rviz/Ogre."], "package_details": ["does not currently offer all the potential of Interactive Markers. However, the most frequent use cases should be supported.", "This package is basically an", "(OSG) adaptation of the", "client writen for rviz/Ogre. Most of the code has been taken from the rviz sources, and adapted to use OSG data types and facilities when possible. It allows the creation of Interactive Markers in", "applications.", "Let's have a look to the", "example, inside the", "package:", "The example above creates an", "application that listens for Interactive Markers in the", "topic. By running the above example and the", "tutorial in different terminals you should see something like the following:", "Let's have a look to the code required for setting the Interactive Markers client. First you need to create a", "instance and set the fixed frame where you expect the markers to be referenced to. After that,", "is the main class you have to instantiate, giving as input the topic where to listen to Interactive Markers, a node in your OSG scene that will hold the geometry, and a TF client:"]},
{"url": "https://wiki.ros.org/contact_handler", "package": "contact_handler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/network_detector", "package": "network_detector", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/win_dateutil", "package": "win_dateutil", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/uos_tools", "package": "uos_tools", "package_summary": ["Various helper utilities not associated with a particular stack"], "package_details": ["Use GitHub to", ". [", "]", "For installation instructions, see", "."]},
{"url": "https://wiki.ros.org/homer_robot_face", "package": "homer_robot_face", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/khi_rs080n_moveit_config", "package": "khi_rs080n_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the khi_rs080n with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/mvsim", "package": "mvsim", "package_summary": ["A lightweight multivehicle simulation framework."], "package_details": ["(", ")", "(", ")", "(", ")", "(default: 0.2)", "\u2192", "\u2192", "\u2192", "The", "node wraps Multi-Vehicle Simulator library (libmvsim). It loads a", "file and exposes vehicles, sensors and wheel forces via ROS.", "If there is only one vehicle defined in the world file, all of these topics appear at the top namespace. However, if more than one vehicle exist, topics are placed into their own namespaces like", ", e.g.,", "etc.", "If there is only one vehicle defined in the world file, all of these topics appear at the top namespace. However, if more than one vehicle exist, topics are placed into their own namespaces like", ", e.g.,", "etc.", "The", "topic gives simulated odometry, while", "always provides a perfect, globally referenced pose."]},
{"url": "https://wiki.ros.org/kuka_rsi_simulator", "package": "kuka_rsi_simulator", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/ros_ethercat_model", "package": "ros_ethercat_model", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_teleop", "package": "maggie_teleop", "package_summary": [], "package_details": ["This package provides an launch file for running", "in a configuration that allows it to run in parallel with the", "stack on the", "."]},
{"url": "https://wiki.ros.org/maggie_create_map", "package": "maggie_create_map", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/default_cfg_fkie", "package": "default_cfg_fkie", "package_summary": ["The configuration node loads a given launch configuration and offers services to \n     list or start the contained nodes. It provides additional description \n     extracted from launch file. This is used by node_manager_fkie."], "package_details": ["The", "node offers a list of nodes, which can be started by calling a service with name of the node. Thus the needed nodes can be launched on demand without knowing the details of the configuration to run those. To configure the list with nodes a ROS launch file is used.", "While loading a launch file by the", "some addtional parameters are parsed to obtain a description of robots, nodes and capabilities configured by the launch file. This description is used in", "to show additional information for nodes. The", "shows the usage of additional description.", "You can run the node without parameter and use the", "service to load a launch configuration."]},
{"url": "https://wiki.ros.org/nao_teleop", "package": "nao_teleop", "package_summary": [], "package_details": ["Then start", "either on your local machine or on the Nao (nao_walker and nao_controller are required by this node). By default, gamepad teleoperation starts paused. Just hit the \"toggle control button\" (#8 by default or #9 on PS3 controller) and start walking Nao around by setting the velocities for the OmniWalk engine with the two sticks on the gamepad (see below).", "You can teleoperate Nao using any joystick or gamepad configured in ROS with omnidirectional velocities, very similar to", ". The following commands are currently implemented (tested on a Logitech Cordless Rumblepad II, where the button numbering should be increased by one as it starts with \"1\"):"]},
{"url": "https://wiki.ros.org/ros_control_boilerplate", "package": "ros_control_boilerplate", "package_summary": ["Simple simulation interface and template for setting up a hardware interface for ros_control"], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/sr_gui_controller_tuner", "package": "sr_gui_controller_tuner", "package_summary": ["A GUI plugin for tuning the sr_mechanism_controllers"], "package_details": []},
{"url": "https://wiki.ros.org/asmach_tutorials", "package": "asmach_tutorials", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/odva_ethernetip", "package": "odva_ethernetip", "package_summary": ["Library implementing ODVA EtherNet/IP (Industrial Protocol)."], "package_details": []},
{"url": "https://wiki.ros.org/turtlebot3_autorace_core", "package": "turtlebot3_autorace_core", "package_summary": ["TurtleBot3 AutoRace ROS package that TurtleBot3 Auto's core"], "package_details": []},
{"url": "https://wiki.ros.org/rosh_desktop_plugins", "package": "rosh_desktop_plugins", "package_summary": [], "package_details": ["Please see the", "documentation to get started.", "rosh_desktop_plugins is an", "development stack for using", ". As rosh has APIs that reach across many ROS libraries, such as", ",", ", and ROS itself, this stack is being used to unify the development.  This stack is expected to disappear as", "and its related plugins mature.", "rosh_robot_plugins houses stacks related to the \"desktop\" variant, which was introduced in", ". The desktop plugins mainly focus on", "-based capabilities."]},
{"url": "https://wiki.ros.org/dense_laser_assembler", "package": "dense_laser_assembler", "package_summary": ["Stores streaming data from a laser sensor in a\n    dense representation. This allows the user to do 'image-like'\n    processing on the data, and can also be used for very fast approx\n    neighborhood searches.  This package is still experimental and unstable.\n    Expect its APIs to change."], "package_details": ["-", "- A single range/intensity reading from a laser scanner. Takes approx 17 \u03c5s to acquire", "-", "- Data collected during a single revolution of a laser scanner. Takes approx 25 ms to acquire, and consists of 100's of rays", "-", "- Data collected during monotonic motion of the tilting_stage on the PR2. Usually takes 2-10 seconds to acquire, and consists of 100's of scans", "A 'typical' Laser", "Scan message will also be published, providing config information for each scan. This includes info like min-angle, max-angle, angle-increment, time-increment, etc. Currently, we assume that the config information is consistent across all scans in a dense laser scan.", "It is likely that the Dense", "Point", "Cloud could end up using", "as the underlying data structure."]},
{"url": "https://wiki.ros.org/straf_recovery", "package": "straf_recovery", "package_summary": [], "package_details": ["The", "is a simple recovery behavior that attempts to move away from the nearest obstacle in the navigation stack's", ". It is designed only for omnidirectional robots. It adheres to the", "interface found in the", "package and can be used as a recovery behavior", "for the", "node."]},
{"url": "https://wiki.ros.org/interactive_marker_proxy", "package": "interactive_marker_proxy", "package_summary": ["A Proxy Server for Interactive Markers"], "package_details": []},
{"url": "https://wiki.ros.org/naoqi_dashboard", "package": "naoqi_dashboard", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/people_velocity_tracker", "package": "people_velocity_tracker", "package_summary": ["Track the output of the leg_detector to indicate the velocity of person."], "package_details": []},
{"url": "https://wiki.ros.org/rospeex_audiomonitor", "package": "rospeex_audiomonitor", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sentis_tof_m100", "package": "sentis_tof_m100", "package_summary": [], "package_details": [".", "Make sure your network is correctly configured. We recommend you to follow the API instructions to check whether the camera and your network are working without any problem.", "Network parameters cannot be changed at runtime.", "Following camera parameters and filtering methods can be accessed in runtime using the rqt_reconfigure.", "There is a new package (", ") that uses the new", "developed by Bluetechnix for interacting with their sensors.", "The", "' works with ROS versions groovy and hydro. You can use catkin workspaces or the previous rosbuild to configure, compile and get ready ROS.", "ROS tutorial:", "Be sure your libboost library version is >= 1.49. Previous versions as 1.46 generate error while compiling sentis_tof_m100_ros_pkg.", "Clone from repository:", "to the src/ folder in your catkin workspace. Now compile it with:"]},
{"url": "https://wiki.ros.org/motoman", "package": "motoman", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This stack is part of the", "program. It currently contains packages that provide nodes for communication with Motoman industrial robot controllers (DX100, FS100, DX200, YRC1000 and YRC1000micro), URDF models for various robot arms and associated", "configuration packages.", "Please see the", "page for more information.", "See the", "metapackage for additional packages, such as robot support packages and", "configuration packages.", "The packages in the main repository have been released into ROS Indigo on Ubuntu, making installation through", "or synaptic possible. Other Linux distributions will have to build from source.", "This installs all the dependencies as well. The controller must be installed/configured to work with ROS-Industrial as well.  The relevant software can be found in the", "package.  Installation instructions for the controller can be found in this", ".", "See the", "page for an overview of the available tutorials.", "See the", "page for details on alarms and errors when using the MotoROS driver."]},
{"url": "https://wiki.ros.org/kuka_kr210_support", "package": "kuka_kr210_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nodelet_core", "package": "nodelet_core", "package_summary": ["Nodelet Core Metapackage"], "package_details": [": the nodelet packages are now part of nodelet_core.  In previous releases, they were part of", ".", "For documentation on using nodelets, please see the", "package.  For nodelet libraries similar in function to the", "package, see", "."]},
{"url": "https://wiki.ros.org/kobuki_ftdi", "package": "kobuki_ftdi", "package_summary": ["Utilities for flashing and enabling Kobuki's USB connection.\n\t    This package contains tools for flashing the Kobuki's FTDI chip (usually done at the factory).\n\t    The special firmware for the FTDI chip (USB to serial converter) enables it to appear as\n\t    /dev/kobuki on the user's PC."], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb5400_support", "package": "abb_irb5400_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/schunk_svh_driver", "package": "schunk_svh_driver", "package_summary": ["ROS1 driver for the Schunk SVH five finger hand"], "package_details": ["The urdf of the node makes use of the", "tag which is currently only resolved by the robot joint state publisher. in order to generate TFs for the visualization and to get the angles of the coupled joints the node is used in conjunction with a joint state publisher and a robot state publisher. If you include the node without these nodes the TF tree will not be complete as the joints that use mimic are not working. See the URDF section for details on joints, their naming and relation.", ": The SVH uses relative encoders that need a hard stop to reset. Especially the finger spread however also contains springs that will lead to a slightly different pose than commanded in real execution. So please beware when you develop poses without the hardware in the loop.", "This package provides a way of controlling the", ". It provides the driver for the low level interface and enables an easy control of the hand via ROS", ".", "To use this package you will need a", ".  It communicates via RS485 protocol. Brainbox USB to Serial converter have proven to work well with the hand and are usually delivered in combination with the hand.", "this will copy the udev rules to", "and restart your udev service.", "If you have the fzi_icl_core or fzi_icl_comm package in your workspace you'll have to build it with", ", as those packages are plain cmake packages. See the", "for details.", "which will copy the udev rules into", "and restart your udev service.", "When using the launch file", "all parameters are read from yaml files residing in the folder", ". If you want to give custom parameters just edit the file", "if you are using the source installation. In case of an installation from deb you should first copy the file under", "to a folder with user write acces, make your changes and then use it by adding the argument", "when launching the node.", "If you want to go back to the original values (and have edited the file, residing in etc) you can simply delete the file and copy the", "to the name", "and start again. If no", "file is present the values of the default file will be used. If both files are missing or the node use used without the launch file hardcoded default values that are safe will be used.", "In any case", "as it sets up many variables, the parameter sets and some additional packages that are needed for correct operation and visualization.", "You can change the device used by adding the argument", "to the launch calls, change it via dynamic reconfigure and then do a reconnect or change it permanently by replacing the argument in the launch file.", "By using the", "argument the launchfile will start a joint state publisher for easy input. If you do not activate this as input you have to provide the target positions by another node or console input. The package folder comes with a file called \"quick_commands\" which gives you some examples how to controll the hand via rostopic.", "By default the node will await input from another node. To use the svh_controller with your project", "like this:", "The node will automatically show the input sliders if started with the standalone argument. If you additionally provide the", "argument as true an rqt gui will be opened when launching the node:", "The", "gui opens always to its default configuration (which is usually the last one). The SVH comes with the plugin", "which enables easy reset control of the hand. Additionally you can use dynamic_reconfigure to change some of the values and the RVIZ plugin to visualize the robot model of the SVH. A configuration file for rviz is provided with the package at \"urdf/svh.rviz\". Your configuration should look something like this to access all GUI functionalities:", "as with the real hardware you can choose to use the simulation (which is not really a simulation but just a visualisation) with convenient sliders or with the command line/ your own packages by using the", "argument:", "As a test to see if the hardware is properly working the very simple test node", "is provided. Make sure the hand can move freely and run the test with:", "In case you do not use the autostart feature of the controller you will have to connect and start the controller manually.  You should do this by using the", "plugin provided with the package. When the hardware is ready press the connect button. Afterwards you can either reset all or individual fingers by pressing reset. The fingers will be disabled after start but are automatically enabled once a target position is set.", "If the troubleshooting did not answer your questions you can ask the community via", "or contact the support offered by FZI on behalf of Schunk at svh-support AT fzi DOT de"]},
{"url": "https://wiki.ros.org/rosbag", "package": "rosbag", "package_summary": ["This is a set of tools for recording from and playing back to ROS\n    topics.  It is intended to be high performance and avoids\n    deserialization and reserialization of the messages."], "package_details": ["The", "package provides a command-line tool for working with", "as well as code APIs for reading/writing bags in", "and", ".", "The rosbag command-line tool and code APIs are", ".  Every effort will be made to maintain backwards compatibility.", "The main new feature being planned for", "is the addition of a ROS API for interacting with the playing and recording nodes via service calls."]},
{"url": "https://wiki.ros.org/reemc_bringup", "package": "reemc_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/tuw_multi_robot", "package": "tuw_multi_robot", "package_summary": ["This repository includes ros packages to plan routes for multiple robots on a search graph. It creates a search graph out of a pixel map and tries to find a path for multiple robots using an extended approach for prioritized planning. The inputs are the tuw_multi_robot_msgs/RobotInfo messages which include the robots pose, the map and the desired goal poses. The output are multiple synchronized routes given to the individual robots."], "package_details": ["Use GitHub to", ". [", "]", "B. Binder, F. Beck, F. K\u00f6nig and M. Bader, \"Multi Robot Route Planning (MRRP): Extended Spatial-Temporal Prioritized Planning,\" 2019 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), Macau, China, 2019, pp. 4133-4139, doi: 10.1109/IROS40897.2019.8968465 (", ")", "B. Binder. (2017), \"Spatio-Temporal Prioritized Planning (Master thesis)\", Retrieved from TU Wien Bibliothekssystem (Accession No. AC14520240) (", ")", "The following figure represents the current state and planed developments on the tuw_multi_robot framework.  The green boxes show already existing modules while the red boxes are not yet implmented/released.  The framework is designed to cover all tools needed for an automated delivery system with autonomous vehicles. The current implementation of the system allows one to set goals for multiple vehicles using RViz or by a configuration file. In the future we also want a order management integrated which is capable to assign vehicles for specific deliveries and to generate goals needed by the multi robot route planner. The system provides a simple local motion controller for all robots, which allows a high number (> 100) of vehicles to be controlled in real time using stage. Furthermore, the design allows the usage of existing individual controllers running on each vehicle such as DWA implemented in move_base."]},
{"url": "https://wiki.ros.org/ur_modern_driver", "package": "ur_modern_driver", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package is part of the", "program. It currently contains nodes that support communication with Universal Robots' industrial robot controllers.", "The following instructions assume that a", "has been created at $HOME/catkin_ws and that the source space is at $HOME/catkin_ws/src. Update paths appropriately if they are different on the build machine."]},
{"url": "https://wiki.ros.org/vrep_ros_plugin", "package": "vrep_ros_plugin", "package_summary": [], "package_details": ["contains all the objects in the scene to which we have added a custom data. The handlers are derived classes that redefines the functions of the", "in order to handle the object.", "Vrep_ros_plugin contains the main code of the bridge. We wrote Vrep_ros_plugin starting from a template called v_repExtPluginSkeleton, available in the V-REP folder \"/programming\" with the porpoise to create your own plugin. You can find more information about the plugins in V-REP", "."]},
{"url": "https://wiki.ros.org/sr_utilities", "package": "sr_utilities", "package_summary": ["sr_utilities contains different useful header libraries (math libraries, etc...)."], "package_details": ["Please note that the robot_state_publisher should soon implement this feature (with a cleaner implementation), as stated by Wim in the", ".", "The node subscribes to the two topics to merge:", "and", ". These are hard coded for the time being.", "Publishes the merged joint state messages to", "."]},
{"url": "https://wiki.ros.org/universal_robots", "package": "universal_robots", "package_summary": ["ROS-Industrial support for Universal Robots manipulators (metapackage)."], "package_details": ["Use GitHub to", ". [", "]", "This stack is part of the", "program. It currently contains packages that provide nodes for communication with Universal's industrial robot controllers, URDF models for various robot arms and the associated", "packages.", "On supported Linux distributions (Ubuntu, up to 16.04 (Xenial),", "and", "):", "The following instructions assume that a", "has been created at $HOME/catkin_ws and that the source space is at $HOME/catkin_ws/src. Update paths appropriately if they are different on the build machine.", "Refer to the", "for more information on building catkin workspaces.", "See the", "page for an overview of the available tutorials."]},
{"url": "https://wiki.ros.org/rosserial_windows", "package": "rosserial_windows", "package_summary": ["rosserial for Windows platforms."], "package_details": ["This package contains Windows-specific extensions required to run", "on an Windows. It will generate a package of headers and a few cpp files that you will need to add to your Visual Studios project in order to communicate with a ROS system, usually over a TCP socket.", "Please see the", "for examples of using rosserial_windows", "Visual Studio 2013 defaults to indenting using tabs. The ROS guidelines are for 2 spaces. To keep things consistent, all of the examples are with 2 spaces. You're welcome to use your editor however you like, but please do not submit code with tabs. See the following page from MSDN for how to set up your Visual Studios environment correctly:"]},
{"url": "https://wiki.ros.org/rc_cloud_accumulator", "package": "rc_cloud_accumulator", "package_summary": ["A viewer for the SLAM component of roboception based on ROS and PCL"], "package_details": ["The rc_cloud_accumulator ROS node subscribes to the following topics of the", "After starting the", ", execute", "The", "provides the following services"]},
{"url": "https://wiki.ros.org/rosparam_shortcuts", "package": "rosparam_shortcuts", "package_summary": ["Quickly load variables from rosparam with good command line error checking."], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/teraranger", "package": "teraranger", "package_summary": ["This package provides ros nodes for single sensors from Terabee"], "package_details": ["is the long range Time-of-Flight distance sensor of the", "product family.", "It provides calibrated distance readings in millimetres and has a range up to 60m, whilst remaining lightweight and small! Instead of laser,", "Evo uses LED technology.", "React faster and detect obstacles with greater assurance,", "is perfect for high-speed collision avoidance and object detection solution!", "With its 10cm to 3m range, 100Hz fixed update rate and greater accuracy(+/-2cm), the", ", is optimized for close-range distance measurement.", "Monitor heat variations, detect movement and capture the unseen! In a compact and affordable design, ideal for OEM integration in Smart City, Smart building, Robotics and Industrial applications.", "For more information about", ":", "is a lightweight, high-performance multi-pixel sensor based on infrared Time-of-Flight (ToF) technology.", "For more information about", ":", "is a lightweight, high-performance distance measurement sensor based on infrared Time-of-Flight (ToF) technology.", "Github: *", "This package works with", ",", ",", ",", ",", ",", ",", "and", ". You can find more information below.", "For more information about", ":", "*", "*", "*", "*", "For more information about", ":", "*", "*", "*", "*", "*", "*", "For more information about", ":", "*", "*", "For more information about", ":", "*", "*"]},
{"url": "https://wiki.ros.org/steer_drive_ros", "package": "steer_drive_ros", "package_summary": [], "package_details": ["An example of using the packages can be seen in", "."]},
{"url": "https://wiki.ros.org/moveit_sim_controller", "package": "moveit_sim_controller", "package_summary": ["A simulation interface for a hardware interface for ros_control, and loads default joint values from SRDF"], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/action/show/universal_robots?action=show&redirect=universal_robot", "package": "universal_robots?action=show&redirect=universal_robot", "package_summary": ["ROS-Industrial support for Universal Robots manipulators (metapackage)."], "package_details": ["Use GitHub to", ". [", "]", "This stack is part of the", "program. It currently contains packages that provide nodes for communication with Universal's industrial robot controllers, URDF models for various robot arms and the associated", "packages.", "On supported Linux distributions (Ubuntu, up to 16.04 (Xenial),", "and", "):", "The following instructions assume that a", "has been created at $HOME/catkin_ws and that the source space is at $HOME/catkin_ws/src. Update paths appropriately if they are different on the build machine.", "Refer to the", "for more information on building catkin workspaces.", "See the", "page for an overview of the available tutorials."]},
{"url": "https://wiki.ros.org/wire_core", "package": "wire_core", "package_summary": [], "package_details": ["The wire_core package it is the core of the", "stack. It takes detections and fuses them to a world state estimate. Technical details can be found here:", "J. Elfring, S. van den Dries, M.J.G. van de Molengraft, M. Steinbuch, Semantic world modeling using probabilistic multiple hypothesis anchoring, Robotics and Autonomous Systems, Volume 61, Issue 2, February 2013, Pages 95-105, (", ")", "An extended list of tutorials can be found", ".", "The package listens to", "generated by perceptual algortihms. It fuses the evidence using object class specific models. It includes multiple hypothesis-based data association and can be configured easily. See the", "for more information about the configuration of this package.", "First install the stack by following the steps mentioned", ". Then, launch:"]},
{"url": "https://wiki.ros.org/rtt_common_msgs", "package": "rtt_common_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/stdr_launchers", "package": "stdr_launchers", "package_summary": [], "package_details": ["The", "package provides ROS launchers for the basic", "functionalities. Specifically the launchers available are:", "Initializes a bare", ".", "Initializes an", "and automatically loads the", "map (found in the", "package).", "Initializes an", "and automatically loads the", "map (found in the", "package. Also an instance of", "is executed.", "Initializes an", "and automatically loads the", "map (see", "). Also an instance of", "is executed. Finally a robot of type", "(see", ") is spawned in the map.", "Wrapper launcher for the", ", modified so that the essential information about", "are visible."]},
{"url": "https://wiki.ros.org/sr_gui_movement_recorder", "package": "sr_gui_movement_recorder", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ridgeback_robot", "package": "ridgeback_robot", "package_summary": [], "package_details": ["Metapackage capturing software to be installed on", "."]},
{"url": "https://wiki.ros.org/rail_grasp_collection", "package": "rail_grasp_collection", "package_summary": [], "package_details": ["The", "package contains nodes to collect demonstration grasps for detected point cloud objects.  These demonstrations can then be used to build object models for recognition and manipulation using the", "package.  Demonstrations are stored in a grasp database, handled by", ".", "To install the", "package, you can install from source with the following commands:", "The", "package contains launch files for launching either the rail_grasp_collection node or the rail_grasp_retriever node individually, and for launching both nodes together.  These can be launched with the following commands, respectively:", "Grasp collection can also be run and executed with an rviz plugin found in", "."]},
{"url": "https://wiki.ros.org/pr2_mannequin_mode", "package": "pr2_mannequin_mode", "package_summary": ["The pr2_mannequin_mode package"], "package_details": ["As with all applications, you must first", "."]},
{"url": "https://wiki.ros.org/rospeex_msgs", "package": "rospeex_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_robot_plugins", "package": "rqt_robot_plugins", "package_summary": ["Metapackage of rqt plugins that are particularly used with robots\n   during its operation.", "To run any rqt plugins, just type in a single command \"rqt\", then select any plugins you want from the GUI that launches afterwards.", "rqt consists of three following metapackages:"], "package_details": ["See", ".", "Other than that, there's extra policy for this", ":"]},
{"url": "https://wiki.ros.org/velodyne_gazebo_plugins", "package": "velodyne_gazebo_plugins", "package_summary": ["Gazebo plugin to provide simulated data from Velodyne laser scanners."], "package_details": ["Documentation at"]},
{"url": "https://wiki.ros.org/qb_chain_description", "package": "qb_chain_description", "package_summary": ["This package contains the ROS description for complex chains of qbrobotics\u00ae devices."], "package_details": ["This package contains the description resources for", "device chains. It includes the", "/", "model of the chained systems exploiting single module descriptions, and extends them with additional parts when required."]},
{"url": "https://wiki.ros.org/rcll_ros_msgs", "package": "rcll_ros_msgs", "package_summary": [], "package_details": ["This package contains messages and services providing the interface to interact with the", "of the", "which is also used in the", ".", "In addition to this msgs package, you will also need the", "(see its documentation there for a description of the actual topics). But you may, for example, choose to keep the calling code on a different machine than the peer. The messages have a close relation to the respective protobuf message types of the referee box. We suggest also consulting the", "."]},
{"url": "https://wiki.ros.org/abb_irb2400_moveit_config", "package": "abb_irb2400_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/rb1_base_pad", "package": "rb1_base_pad", "package_summary": [], "package_details": ["-", "In this folder you will find the different config files available for the different possible joysticks", "-", "In this folder you will find the launch file to execute the node", "-", "In this folder you will find the source code", "In order to launch the", "node along with the personalized rb1_base joystick:"]},
{"url": "https://wiki.ros.org/rosfmt", "package": "rosfmt", "package_summary": ["fmt is an open-source formatting library for C++.\n\t\tIt can be used as a safe and fast alternative to (s)printf and IOStreams."], "package_details": []},
{"url": "https://wiki.ros.org/nav2d_msgs", "package": "nav2d_msgs", "package_summary": ["Messages used for 2D-Navigation."], "package_details": []},
{"url": "https://wiki.ros.org/uos_rotunit_snapshotter", "package": "uos_rotunit_snapshotter", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rc_common_msgs", "package": "rc_common_msgs", "package_summary": ["Common msg and srv definitions used by Roboception's ROS packages"], "package_details": []},
{"url": "https://wiki.ros.org/kuka_kr10_support", "package": "kuka_kr10_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/coverage_path", "package": "coverage_path", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The following packages of the", "are required:", "The following packages of the", "are required:", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/kurt_base", "package": "kurt_base", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rwt_utils_3rdparty", "package": "rwt_utils_3rdparty", "package_summary": ["The rwt_utils_3rdparty package"], "package_details": []},
{"url": "https://wiki.ros.org/slime_ros", "package": "slime_ros", "package_summary": ["Extensions for slime to assist in working with ROS packages"], "package_details": ["This is an extension of", "(a \"contrib\") that helps you to deal with ASDF systems in ROS packages. It also adds a REPL shortcut", "to the slime REPL.", "Then call the initialization script that generates", "in your home directory for configuring your SBCL.", "And then add the following to your", ":", "The most up-to-date version of", "code can be found", ". Installation instructions are in the README file.", "What you'll need to do will be something like the following:", "If you've set up your emacs init file correctly you should be able to start the REPL by typing", ". Now, by pressing", "(coma) in an empty REPL prompt, you can select the shortcut", ". Press enter and select a ROS package and an ASDF system inside this ROS package. Slime will set the variable", "and perform a load operation on the selected system.", "The package contains one customization variable,", ". It allows the user to select ido mode completion or similar completion mechanisms. To change its value, use", "."]},
{"url": "https://wiki.ros.org/sciurus17", "package": "sciurus17", "package_summary": ["ROS package suite of Sciurus17"], "package_details": []},
{"url": "https://wiki.ros.org/view_controller_msgs", "package": "view_controller_msgs", "package_summary": ["Messages for (camera) view controllers"], "package_details": ["This package provides the messages necessary for controlling the behaviour of the RViz view controller plugin provided by the", "package.", "This package has been released into Hydro and Indigo. Installation through", "is easiest in most cases (note that installation of", "should install this package as a dependency automatically):", "See the", ",", "and", "Python scripts installed in the packages directory for examples of how to use the messages provided by this package."]},
{"url": "https://wiki.ros.org/v4r_ros", "package": "v4r_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nao_dcm_bringup", "package": "nao_dcm_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/khi_robot", "package": "khi_robot", "package_summary": ["Meta package for khi_robot"], "package_details": []},
{"url": "https://wiki.ros.org/msvc_runtime", "package": "msvc_runtime", "package_summary": [], "package_details": ["These scripts can't be run without a", "extension on windows and even then, can't be run in the shell without directly calling python first. Alot of the ros architecture expects these to be directly executable, so rather than modifying the whole ros architecture, we sub in executables that indirectly execute the python scripts.", "Simply copy one of the existing .exe's and rename it (they are self-calling). More permanently, modify", "in the src folder."]},
{"url": "https://wiki.ros.org/kuka_rsi_hw_interface", "package": "kuka_rsi_hw_interface", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page.", "This package can be used with both KR C2 (", ") and KR C4 (", ") controllers.", "See the", "page for a listing of common errors and possible solutions."]},
{"url": "https://wiki.ros.org/kuka_resources", "package": "kuka_resources", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/pattern_manager", "package": "pattern_manager", "package_summary": [], "package_details": ["A list of tutorials for getting started with pattern_manager can be found on the tutorials page", ". These tutorials cover interaction with the pattern_manager node via ROS service calls using CLI.", "An RQt-plugin has also been created as a GUI for pattern_manager. It can be found", ".", "Currently,", "only exists as source files on", ", although an official release is planned for sometime in the future."]},
{"url": "https://wiki.ros.org/rqt_nav_view", "package": "rqt_nav_view", "package_summary": ["rqt_nav_view provides a gui for viewing navigation maps and paths."], "package_details": []},
{"url": "https://wiki.ros.org/maggie_motor_drivers", "package": "maggie_motor_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_ethercat_hardware", "package": "ros_ethercat_hardware", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_plugs_common", "package": "pr2_plugs_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_bringup", "package": "maggie_bringup", "package_summary": [], "package_details": ["is a package that collects together the scripts,", "files, and dependencies that are required to bring the social robot", "into a running state.", "For running all the system is necessary the file", ". This launch file contains all nodes to run the complete", "robot.", "For running the basic of the robot is necessary the file", ". This launch file contains all nodes to run the complete", "robot."]},
{"url": "https://wiki.ros.org/mingw_cross", "package": "mingw_cross", "package_summary": [], "package_details": ["You can of course install the mingw cross environment directly yourself following the instructions at the", ". Alternatively:", "Installation location can be moved if the", "environment variable is set before running", ".", "See the", "for usage patterns."]},
{"url": "https://wiki.ros.org/ros_ethercat_loop", "package": "ros_ethercat_loop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/industrial_trajectory_filters", "package": "industrial_trajectory_filters", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For more detailed examples see the", "page."]},
{"url": "https://wiki.ros.org/urdf_traverser", "package": "urdf_traverser", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_msgs", "package": "kobuki_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"kobuki_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/kobuki_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/industrial_robot_client", "package": "industrial_robot_client", "package_summary": ["industrial robot client contains generic clients for connecting \n     to industrial robot controllers with servers that adhere to the\n     simple message protocol."], "package_details": ["Use GitHub to", ". [", "]", "The", "package provides a standardized interface for controlling industrial robots, based on the ROS-Industrial", ".  This package includes a C++ reference implementation of the specification, using the", "protocol to communicate with a compatible server running on a standalone industrial robot controller.", "Primarily, this package provides the industrial_robot_client library.  The intent is for robot-specific implementations to reuse code from this library using standard C++ derived-class mechanisms, to avoid much of the copy/paste duplication in current industrial-robot driver implementations.", "This package also provides generic nodes exposing the base industrial_robot_client functionality.  If a robot does not require any specific client-side code, then it may be sufficient to run these standard nodes.", "describes this usage in more detail.", "The Simple Message (SimpleMessage) protocol defines the message structure between the ROS driver layer and the robot controller itself.", "Refer to", "for a description of the protocol.", "Rather than make a new copy of the entire ROS client codebase, it is recommended that the integrator use a derived-class approach to only re-implement the minimal functionality required.  Wherever possible, the new code should call the base class reference-implementation functions to avoid code duplication and maintain consistent operations.  It may be helpful to review the library's", "to determine which functionality may need replacing.  Simple joint reordering and renaming can be handled through existing capabilities, as described", "."]},
{"url": "https://wiki.ros.org/rr_openrover_basic", "package": "rr_openrover_basic", "package_summary": [], "package_details": ["This package is depracated. It has been replaced by", "which is part of"]},
{"url": "https://wiki.ros.org/pr2_arm_kinematics", "package": "pr2_arm_kinematics", "package_summary": ["This package provides a kinematics implementation for the PR2 robot. It can be used to compute forward and inverse kinematics."], "package_details": ["The pr2_arm_kinematics package is a PR2 specific package that provides IK solutions for the PR2 robot arms. The recommended interface is through ROS. The node provides multiple interfaces (listed in the ROS API below) and can be used to compute the closest IK solution to an initial guess. More information on using this package can be found in the API documentation. Example code for using this package can be found in the", ".", "pr2_arm_kinematics provides services for IK computation. It can be configured using ROS parameters. The ROS API is explained in greater detail below. To get a collision free version of this node, check out the", ".", "Tutorials for this package can be found in the", "."]},
{"url": "https://wiki.ros.org/nao_description", "package": "nao_description", "package_summary": [], "package_details": ["Nao's URDF description contains all joints and links according to the", "for V3 and V4 Naos. In accordance with", "and", "the root link is", ", directly connected to", ". The camera frames are", "and", ".", "publishes the", "transform and a", "frame, projected between the feet on the ground. The defined links for the end effectors are", "for the arms and", "for the feet."]},
{"url": "https://wiki.ros.org/mpc_local_planner", "package": "mpc_local_planner", "package_summary": ["The mpc_local_planner package implements a plugin\n    to the base_local_planner of the 2D navigation stack.\n    It provides a generic and versatile model predictive control implementation\n    with minimum-time and quadratic-form receding-horizon configurations."], "package_details": ["Use GitHub to", ". [", "]", "The best way to get started is to look at one of the example configurations in the", ".", "The", "directory contains several example", "configurations.", "It is", "to be familiar with the", "stack and all its components (global planner, local planner, costmap_2d, ...).", "It might also be helpful to be familiar with the", "as the planners are very similar from the API and parameter point of view (the teb_local_planner wiki page already provides several tutorials which do not exist for this planner yet).", "Please also have a look at the repository's", "."]},
{"url": "https://wiki.ros.org/motoman_sia5d_moveit_config", "package": "motoman_sia5d_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/maggie_rfid", "package": "maggie_rfid", "package_summary": [], "package_details": ["This device supports all the drivers implemented in the", "package."]},
{"url": "https://wiki.ros.org/khi_duaro_ikfast_plugin", "package": "khi_duaro_ikfast_plugin", "package_summary": ["The khi_duaro_ikfast_plugin package"], "package_details": []},
{"url": "https://wiki.ros.org/naoqi_driver_py", "package": "naoqi_driver_py", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/urdf_viewer", "package": "urdf_viewer", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/soem", "package": "soem", "package_summary": ["ROS wrapper for the Simple Open EtherCAT Master SOEM.\n    This is an updated version of the original SOEM wrapper released into ROS now including\n    the upstream Repo as a git subtree."], "package_details": ["See", "in the repository for further information."]},
{"url": "https://wiki.ros.org/velo2cam_calibration", "package": "velo2cam_calibration", "package_summary": ["The velo2cam_calibration package"], "package_details": [",", ", Arturo de la Escalera, Fernando Garc\u00eda", "Other size may be used for convenience. If so, please configure node parameters accordingly.", "The", "software implements a state-of-the-art automatic calibration algorithm for pair of sensors composed of LiDAR and camera devices in any possible combination, as described in this paper:", "See the", "for detailed instructions on how to use this software.", "To test the algorithm in a virtual environment, you can launch any of the calibration scenarios included in our", ".", "A previous version of this tool is available", "and was described on this", "."]},
{"url": "https://wiki.ros.org/tuw_multi_robot_goal_generator", "package": "tuw_multi_robot_goal_generator", "package_summary": ["The tuw_multi_robot_goal_generator package was designed to generate, store, and read goal lists for the tuw_multi_robot_router.\n    The goal_saver is able to store publish goal msgs of type tuw_multi_robot_msgs::RobotGoalsArray in a human readable form. \n    The goal_server is able to read and publish this msgs and to read patches of saved goals for testing.\n    The goals_random node subscribes to the occupancy grid and is able to auto generate valid goals for testing."], "package_details": ["(", ")", "(", "default: \"/tmp/goals.txt\")", "(", "default: \"false\")", "(", ")", "(", "default: \"/tmp/goals.txt\")", "(", "default: \"1.0\")", "(", "default: \"false\")", "(", "default: \"true\")", "(", ")", "(", ")", "(", ")", "(", "default: \"-\")", "(", "default: \"-1\")", "(", "default: \"map\")", "(", "default: \"robot_\")", "(", "default: \"0.5\")", "(", "default: \"2.0\")", "(", "default: \"0.2\")", "(", "default: \"1000\")", "Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/pr2_mechanism_msgs", "package": "pr2_mechanism_msgs", "package_summary": ["This package defines services that are used to communicate with\n     the realtime control loop. It also defines messages\n     that represent the state of the realtime controllers, the joints\n     and the actuators."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"pr2_mechanism_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/pr2_mechanism_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/raspimouse_sim", "package": "raspimouse_sim", "package_summary": ["ROS package suite for Raspberry Pi Mouse Simulator"], "package_details": []},
{"url": "https://wiki.ros.org/rotors_gazebo_plugins", "package": "rotors_gazebo_plugins", "package_summary": ["The rotors_gazebo_plugins package"], "package_details": []},
{"url": "https://wiki.ros.org/rail_face_detection", "package": "rail_face_detection", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/simple_message", "package": "simple_message", "package_summary": ["simple_message defines a simple messaging connection and protocol for communicating \n\twith an industrial robot controller.  Additional handler and manager classes are \n\tincluded for handling connection limited systems.  This package is part of the ROS-Industrial \n\tprogram."], "package_details": ["Use GitHub to", ". [", "]", "The Simple Message (SimpleMessage) protocol defines the message structure between the ROS driver layer and the robot controller itself.", "Refer to", "for a description of the protocol.", "The message protocol allows for an arbitrary data payload for message and communications types.  However, the client/server model requires that both understand the data payload associated with the different message and communications types.  The typed message class enforces the data payload structure.  The typed message base class provides methods for creating topic, reply, and request messages.  If used in both the client and server, the developer need not understand the structure of the data payload.  Unfortunately, a typical robot controller cannot use C++ classes, and thus the developer must understand the message protocol and payload data structure in order to parse it on the robot controller side.  The documentation on message specific structures can be found in the source header files.  For convenience the message structure is also shown here for common message types.  For a more detailed example of a typed message structure and how it is used see the following", ".", "The simple message utilizes a abstract connection (SmplMsgConnection) interface to send messages to the industrial robot controller.  The interface makes two assumptions:", "The Message Manager and Handler (MessageManager and MessageHandler) classes can be used to manage a connection that allows for multiple message types to be handled.  The message manager contains a list of message handlers and executed the appropriate handler when a message is received.  These classes are particularly useful on robot controllers which may have a limited number of connections available to them.", "A Lua Wireshark dissector plugin for the simple message protocol is available from", "at GitHub. See the readme for information on how to install it."]},
{"url": "https://wiki.ros.org/master_discovery_fkie", "package": "master_discovery_fkie", "package_summary": ["Discover the running ROS Masters in local network. The \n     discovering is done by sending an echo heartbeat messages to a defined \n     multicast group.\n     The alternative is to use a zeroconf/avahi daemon to register the ROS \n     master as service and discover other ROS masters."], "package_details": ["This package contains discovery nodes to detect a ROS master in a multi robot system. There are currently two nodes 'master_discovery' and 'zeroconf' which uses different discovery strategies. 'zeroconf' node uses an avahi implementation of zeroconf technique. The 'master_discovery' node sends periodically a multicast message to notify about an available ROS master.  Furthermore the ROS master will be monitored for changes. On changes other discovery nodes are notified using a timestamp. This feature is used e.g. by", "to syncronize the ROS masters. Moreover an XML-RPC server created by a discovery node helps to avoid a lot of requests on remote ROS master for a synchronization.", "To use", "for discovering you need to run:"]},
{"url": "https://wiki.ros.org/pr2_computer_monitor", "package": "pr2_computer_monitor", "package_summary": ["Monitors the computer's processor and hard drives of the PR2 and publishes data to diagnostics."], "package_details": ["uses command line tools to monitor the CPU. These commands are called in timer threads every 10 seconds or so to keep load down.", "uses command line tools to monitor the HD.", "will only check the disk usage if the home directory argument is set from the command line.", "uses ntpdate to check the offset in clocks, using the NTP protocol.", "Each computer has two times: the time", "thinks it is, and the system time. When they disagree,", "slowly slews the system time until they match again. When you do", "you compare host's chrony time with the local system time. Doing", "allows you to verify that the chrony time and the system time match.", "The", "script uses the command:", "With proper system dependencies,", "can work on almost any linux system. Use", "to install required packages from the operating system:", "It's a good idea to verify the installation of", ". To contact", "(which measures hard drive temperature), pr2_computer_monitor opens a socket to the", "daemon.", "First, verify that the", "daemon is running.", "If", "isn't up and running, start it by typing:", "Now, check if you have", "installed correctly. If you choose not to use ipmitool to monitor CPU temperature and fan speed, disable it with", "parameter to False.", "If this command returns with an error (below), then you will need to disable the ipmitool checks using the", "parameter.", "The", "command needs to work properly without a password. If the above command asks for a \"sudo\" password, you'll need to edit the sudoers file:", "Add the following line to use", "without typing your password:", "If your computers uses NFS, then you should enable the", "parameter for CPU monitor. The NFS status messages will have no data if not enabled.", "CPU monitor will warn if the CPU cores start throttling below 2240 MHz. This is appropriate for the PR2, but if your computer is different, disable the", "parameter."]},
{"url": "https://wiki.ros.org/kuka_kr6_support", "package": "kuka_kr6_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_camera_synchronizer", "package": "pr2_camera_synchronizer", "package_summary": [], "package_details": ["This section gives an overview of the PR2's camera systems. Some readers may want to skip directly to", "for a more practical discussion of how to use the robot's cameras, or to the", "for a detailed description of the pr2_camera_synchronizer parameters.", "This section shows how to use the", "to set these parameters, they can be set just as easily using any other", "mechanism as demonstrated in", ".", "Frame rates and projector modes should be set using", "on the pr2_camera_synchronizer_node. For example:", "The synchronizer will make a best-effort attempt at using the rates and modes you requested, but may have to", ". In that case, the GUI and parameter will reflect the rates and modes that were actually set.", "Many WGE100 settings not managed by the synchronizer can be set directly with the cameras by using", ". A detailed list of which parameters can be set in this way without conflicting with the synchronizer can be found", ".", "For the forearm cameras, the camera node (", "or", ") should be configured directly. For the stereo pairs, the wge100_multi_configurator node (", "or", ") should be configured; this node controls both cameras of a stereo pair, and will dispatch configuration changes to both underlying camera nodes.", "For the wide stereo camera:", "For the narrow stereo camera:", "For the right forearm camera:", "For the left forearm camera:", "Please refer to the", "documentation for details on what these parameters mean.", "The following parameters can be set:", ",", ",", ",", ",", ",", ",", ",", ",", ".", "Please refer to the", "documentation for details on what these parameters mean.", "Note 1: the", "stored in the camera is only valid for the region of interest parameters that were used when it was created. The", "will refuse to use", "with the wrong width and height, but will not detect changes in the other parameters.", "Images from the wide stereo camera and forearm cameras are published in the", ",", "and", "namespaces, whether they are textured or not.", "To facilitate using the narrow stereo camera in", "mode, textured images from the narrow stereo camera are always published in the", "namespace, and untextured images are always published in the", "namespace.", "Due to unresolved firmware bugs, it may happen that a WGE100 camera will become unresponsive. The unresponsiveness of the camera can be verified by running:", "The easiest way to reset all the WGE100 cameras while ROS is running on the PR2 is to use the", "option to true in the", "options. This will raise the camera's trigger signal for a few seconds, telling the camera to reset itself. The reset will take about 5-10 seconds.", "Alternatively, a single camera can be reset when ROS is not running by using the", "utility in", ". For example:", "In a running PR2, many cameras may be simultaneously in use by different users. Whether the projector should be on at any given time is a combination of the operating modes requested by the user of each camera. The settings of a user's camera depend on whether the projector is on or off. To avoid spurious changes in the settings of one user's camera when another user's camera is reconfigured, the pr2_camera_synchronizer is organized so that there is a master", "setting, and a", "setting for each camera.", "Users request the", "that their camera should be in, and the synchronizer decides on the projector state based on the current", ". For a given", ", the pr2_camera_synchronizer ensures that the settings of one camera do not depend on the", "of the other cameras. In a typical use of the synchronizer, the", "is set once and for all by a high-level decision, and users can adjust", "at will.", "The recommended operating mode is", ".", "can be used if longer exposures are needed or if the projector is deemed too unpleasant.", "will most likely not be used in practice.", "In many cases, the camera frame rate must be some suitable divisor of the", ". When a user sets the frame rate for a camera, the synchronizer will round that rate to the nearest suitable rate, and report the rounded value back to the user via the", "mechanism.", "The", "is not affected by the camera settings. When it is set, it is simply rounded to the nearest divisor of 1 kHz. Again the rounded value is reported back via the", "mechanism.", "To avoid having texture in images taken by the Prosilica camera, the", "option can be turned on. In this case, an exposure signal from the Prosilica camera directly inhibits firing of the projector. When the projector is inhibited the WGE100 cameras will continue to be triggered as if the projector was active, so some frames that should be textured may be partially textured or not textured at all.", "On the other hand, the Prosilica camera projector inhibition will not work between robots. Therefore, Prosilica images from one robot may see texture projected by the other, even if", "is true."]},
{"url": "https://wiki.ros.org/imu_monitor", "package": "imu_monitor", "package_summary": ["This package contains a single node that monitors the drift of the IMU\ngyroscopes. The results are published to the '/diagnostics' topic and\nare aggregated in the PR2 dashboard."], "package_details": []},
{"url": "https://wiki.ros.org/maggie_ir_drivers", "package": "maggie_ir_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/segbot_logical_translator", "package": "segbot_logical_translator", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kurt_driver", "package": "kurt_driver", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For installation instructions, see", "."]},
{"url": "https://wiki.ros.org/iot_bridge", "package": "iot_bridge", "package_summary": [], "package_details": ["There is a different access to the REST APIs of", "and", ". Specifically, this means that the header has changed.", "The iot_bridge for openHAB 2 can be found at", ". For openHAB 3 there is a fork at", ".", "When iot_bridge receives a name/value pair from the ROS", "topic, it publishes those to openHAB  and openHAB sends that command to the device specified.  The value must be valid for that device.  See", "for a summary of valid values.", "A ROS program wants to turn on a ceiling light.  It publishes the following to the", "topic:", "When the iot_bridge receives a name/value pair from the ROS", "topic, it publishes those to openHAB and openHAB updates the status for the item specified (e.g. indicate that a switch is now ON).", "A ROS program running Facial Detection detects that Sarah is present.  It publishes the following to the", "topic:", "The IoT bridge receives updates from openHAB and publishes those as name/value pairs to the", "ROS topic.", "For example:  A motion detector is triggered in openHAB.  The openHAB bridge will publish the following to the", "topic in ROS", "A ROS program publishes the following to the", "topic:", "If you want to test e.g. ROS and openHAB, but have not yet installed the corresponding devices and items, you can try the", ". These are so-called", "for each", "of openHAB.", "Use GitHub to"]},
{"url": "https://wiki.ros.org/reemc_controller_configuration", "package": "reemc_controller_configuration", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/master_sync_fkie", "package": "master_sync_fkie", "package_summary": ["Synchronize the local ROS master to the remote masters \n     discovered by master_discovery_fkie node. The registration\n     of topics and services is only perform by local ROS master."], "package_details": ["in the current state the", "will be not synchronized.", "do not rename the master_sync node! If it does, use the ignore_nodes filter to prevent synchronization of the master_sync nodes, otherwise unpredictable effects will occur", "This package contains a node to synchronize the local ROS master to remote ROS masters discovered by", "node. For synchronization the", "will be used. Thereby the regitration of topics/services are performed only on the local ROS master. To obtain a complete synchronization of two ROS master one master_sync node in each \"ROS system\" have to be started.", "The syncronization will be performed on each time the remote ROS master is changed. The change detection is done by the", "node. To avoid multiple calls over unreliable connections e.g.", ", needed for a synchronization, the XML-RPC server of the", "node is used to get the current state of the remote ROS master.", "Run the", "node first."]},
{"url": "https://wiki.ros.org/rcll_fawkes_sim_msgs", "package": "rcll_fawkes_sim_msgs", "package_summary": [], "package_details": ["This package contains the relevant message types to interface with the", "of the", "(RCLL) that is also used for the", ". The simulation environment is based on", "and", ". Detailed information about the simulation is available on the", "."]},
{"url": "https://wiki.ros.org/nav2d_navigator", "package": "nav2d_navigator", "package_summary": ["This package provides a node for higher level navigation of a mobile\n    robot in a planar environment. It needs a map and the robot's position\n    within this map to create a plan for navigation. When used together with\n    a SLAM module it can also be used to perform autonomous exploration of\n    the robot's workspace."], "package_details": ["The", "is a ROS node that implements a path planner for navigation and is supposed to be used in conjunction with the 'operator' node. Beside this, the whole functionality is provided by the", "class, which is exported by this package and can be used from within other nodes as well.", "Interaction with the Navigator is implemented using the", "interface. This allows other nodes (e.g. some high level mission control) to start actions like goal navigation or exploration, monitor the progress and eventually cancel an action in progress. The following four actions are available:", "See the", "for an example how to setup the Navigator in Stage with a given map of the environment."]},
{"url": "https://wiki.ros.org/pose_follower", "package": "pose_follower", "package_summary": ["A implementation of a local planner that attempts to follow a plan as closely as possible."], "package_details": []},
{"url": "https://wiki.ros.org/naoqi_bridge", "package": "naoqi_bridge", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package is the meta-package for packages that create a bridge with Aldebaran's", "(versions 1.14 and 2.1)."]},
{"url": "https://wiki.ros.org/usb_cam_hardware", "package": "usb_cam_hardware", "package_summary": ["The usb_cam_hardware package"], "package_details": ["This package contains an USB camera driver which is almost compatible to", "but based on", ". Major enhancements over usb_cam are;", "See the", "."]},
{"url": "https://wiki.ros.org/irb_2400_moveit_config", "package": "irb_2400_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/qb_move_hardware_interface", "package": "qb_move_hardware_interface", "package_summary": ["This package contains the hardware interface for qbrobotics\u00ae qbmove device."], "package_details": ["This package is barely usable alone since it provides only the hardware interface for the", "device."]},
{"url": "https://wiki.ros.org/motoman_bmda3_support", "package": "motoman_bmda3_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rovio", "package": "rovio", "package_summary": [], "package_details": ["To install the", "stack, you can choose to either install from source, or from the Ubuntu package:", "Each control package contains a", "file which should be edited with the appropriate ROS parameters (e.g. hostname, username, and password to login to your Rovio). These launch files launch the necessary nodes for reading sensor information and control of the Rovio. Additional information on each launch file is given in their respective package wiki pages.", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/mpc_local_planner_examples", "package": "mpc_local_planner_examples", "package_summary": ["The mpc_local_planner_examples package"], "package_details": []},
{"url": "https://wiki.ros.org/pheeno_ros_description", "package": "pheeno_ros_description", "package_summary": ["The pheeno_ros_description package"], "package_details": ["Documentation for our package can be found", ". We will also be adding documentation to this ROS page in the coming weeks."]},
{"url": "https://wiki.ros.org/industrial_msgs", "package": "industrial_msgs", "package_summary": ["The industrial message package containes industrial specific messages \n\tdefinitions. This package is part of the ROS-Industrial program."], "package_details": ["Use GitHub to", ". [", "]", "This package is part of the", "program. It contains message definitions used by other packages in the", "metapackage."]},
{"url": "https://wiki.ros.org/nav2d_localizer", "package": "nav2d_localizer", "package_summary": ["Wrapper around Particle Filter implementation.\n    The SelfLocalizer can be used as library or as a ros-node."], "package_details": []},
{"url": "https://wiki.ros.org/visual_pose_estimation", "package": "visual_pose_estimation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_msgs", "package": "motoman_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/agvs_robot_control", "package": "agvs_robot_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lex_node", "package": "lex_node", "package_summary": ["Package providing a ROS node for interacting with Amazon Lex"], "package_details": [": Amazon Lex is a service for building conversational interfaces into any application using voice and text. Amazon Lex provides the advanced deep learning functionality of automatic speech recognition (ASR) for converting speech to text, and natural language understanding (NLU) to recognize the intent of the text, to enable you to build applications with highly engaging user experiences and lifelike conversational interactions. With Amazon Lex, the same deep learning technologies that power Amazon Alexa are now available to any developer, enabling you to quickly and easily build sophisticated, natural language, conversational bots (\u201cchatbots\u201d).", "The ROS", "node enables a robot to comprehend natural language commands by voice or textual input and respond through a set of actions, which an Amazon Lex Bot maps to ROS messages. Out of the box this node provides a ROS interface to communicate with a specified Amazon Lex bot (configured via lex_config.yaml) and requires configuration of AWS credentials. The Amazon Lex bot needs to be defined with responses and slots for customer prompts. A set of default slots and mappings are demonstrated in the", "and include actions as \u201cCreate <location_name>,\u201d \u201cGo to <location_name>\u201d and \u201cStop.\u201d Additional guides on configuring bots with are available at", ".", "The ROS", "wraps the", "in a ROS service API.", "The source code is released under an", "."]},
{"url": "https://wiki.ros.org/nao_moveit_config", "package": "nao_moveit_config", "package_summary": [], "package_details": ["Please, find the documentation on the github page", "."]},
{"url": "https://wiki.ros.org/ugv_random_walk", "package": "ugv_random_walk", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The following packages of the", "are required:", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/korg_nanokontrol", "package": "korg_nanokontrol", "package_summary": [], "package_details": ["Where", "is the MIDI ID of your input device. On my system, the", "is usually device 3."]},
{"url": "https://wiki.ros.org/arbotix", "package": "arbotix", "package_summary": ["ArbotiX Drivers"], "package_details": ["check out the latest code from our repository:", "Please see the individual packages within this stack for documentation. ArbotiX and Arbotix-M RoboControllers can be purchased from", ".", "Bug reports, feature requests and patches are welcome. Please post new issues on our", "site."]},
{"url": "https://wiki.ros.org/pioneer_teleop", "package": "pioneer_teleop", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "The package is compatible with any robot using ROS ecosystem, but is originally implemented for Adept", "Pioneer and Pioneer-compatible robots (Including Pioneer 2, Pioneer 3, Pioneer LX,", ",", ",", ",", ", Seekur and Seekur Jr.).", "In case you have a different robot, please read", "section", "You need first to get and install", "package", "The expected commands are \"", "\", \"", "\", \"", "\" or \"", "\"", "The expected commands (", "argument) are \"", "\", \"", "\", \"", "\" or \"", "\"", "The velocity commands are published in", "topic (see the next section).", "You modify the .launch scripts to remove the pionner_bringup call, or you execute directly the python scripts located in", "folder.", "By default, the scripts publish velocity commands to", "topic.", "In case your velocity commands topic has a different name, or you are not using Pionner-compatible robots, you will have to remap your velocity topic to", "or change the topic name in the python scripts which are located in", "folder"]},
{"url": "https://wiki.ros.org/jsk_smart_gui", "package": "jsk_smart_gui", "package_summary": [], "package_details": ["Documentation is available", "."]},
{"url": "https://wiki.ros.org/mrpt_bridge", "package": "mrpt_bridge", "package_summary": ["C++ library to convert between ROS messages and MRPT classes"], "package_details": ["This package held a set of functions to convert between common ROS messages and MRPT C++ classes, a functionality which is now (2022) exposed directly via", "and", "C++ libraries, part of the", "ROS package."]},
{"url": "https://wiki.ros.org/nav2d_karto", "package": "nav2d_karto", "package_summary": ["Graph-based Simultaneous Localization and Mapping module.\n    Includes OpenKarto GraphSLAM library by \"SRI International\"."], "package_details": []},
{"url": "https://wiki.ros.org/arbotix_python", "package": "arbotix_python", "package_summary": ["Bindings and low-level controllers for ArbotiX-powered robots."], "package_details": ["The arbotix_python package provides a basic ROS interface to an", "over a USB serial connection, or XBEE wireless radios.", "The", "package also offers several controllers which add higher-level interfaces to common hardware. These include:", "The ControllerGUI is a test/teleop node that allows you to control a mobile base and/or your Dynamixel servos. The ControllerGUI publishes geometry_msgs/Twist commands to the", "topic, and commands to individual servos. It will automatically determine the names and limits of your servos from your YAML specification file. Launching the ControllerGUI is as easy as:", "Moving the red dot up drives the robot forward, moving left/right turns in place, etc. The slider bars move servos, but must be checked to be enabled. When not enabled, they will be updated with the values of the last joint_states message, so that when enabled they will not", "to a position, but just torque-on in place. In the above image, only head_pan and head_tilt are enabled.", "Working with Dynamixel servos often requires some setup of the servos themselves. This is made easy with the ArbotiX terminal tool. The terminal works like a typical Linux terminal, you can type", "to query which servos are attached,", "will", "the servo with ID 1 to an ID of 2, etc:", "The terminal has several other commands. Typing", "will list all commands:"]},
{"url": "https://wiki.ros.org/qb_chain_control", "package": "qb_chain_control", "package_summary": ["This package contains the ROS node to control multiple qbrobotics\u00ae devices simultaneously."], "package_details": []},
{"url": "https://wiki.ros.org/agvs_pad", "package": "agvs_pad", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ainstein_radar_rviz_plugins", "package": "ainstein_radar_rviz_plugins", "package_summary": ["Radar message type plugins for RViz."], "package_details": []},
{"url": "https://wiki.ros.org/motoman_driver", "package": "motoman_driver", "package_summary": [], "package_details": [": this is required for the", ".", "The MotoROS application and source is available for public download.  However, ordering this part number will ensure your controller is updated with correct system software, the MotoROS driver is installed, and all internal parameters are properly configured.", ": This is", ", but will allow you to modify the MotoROS driver which runs on the robot controller. The MotoPlus SDK is", "required to be able to develop ROS applications, it is only needed if the MotoROS application is to be changed.", "The software will work on all", ",", ",", ",", "and", "robot controllers.  However, for DX100 controllers, a specific software option must be explicitly ordered from Motoman in order to enable ROS-Industrial integration (see the", "section below).", "For more detailed information, please contact one of the support resources listed on", "or", ".", "The latest MotoROS binary (", "or higher) requires the following controller firmware (or a newer version):", "Please note that the MotoROS application is now compatible with the Human Collaborative HC series robots. Please review the", "document to understand the functionality and limitations.", "The Motoman driver communicates with ROS through the", "interface, with a few additional Motoman-specific message types.  Trajectories are streamed to the controller using a message format that captures all the ROS", "data: joint positions, velocities, accelerations, and path timing.  The controller buffers these points and interpolates between them to send commands to the controller at the required timing.  More detail on the internal operations and required", "commands is documented", ".", "See the", "page for details on installing and using the MotoROS software.", "See the", "page for details on alarms and errors when using the MotoROS driver."]},
{"url": "https://wiki.ros.org/mdm_library", "package": "mdm_library", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_navigation", "package": "maggie_navigation", "package_summary": [], "package_details": ["The", "stack provides configuration files for running the", "stack on", "robot in a number of common configurations. For example, the package holds files that configure the", "node to operate in an odometric frame, and configure the sensors for autonomous navigation. These configuration files are intended for use as building blocks for applications that wish to use autonomous navigation as a component."]},
{"url": "https://wiki.ros.org/segbot_bringup", "package": "segbot_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pepper_description", "package": "pepper_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/realsense2_camera", "package": "realsense2_camera", "package_summary": ["RealSense Camera package allowing access to Intel T265 Tracking module and SR300 and D400 3D cameras"], "package_details": ["This package provides ROS node(s) for using the Intel\u00ae", "\u2122 SR300 and D400 cameras.", "Installation instructions can be found", "The library is a ROS Debian packaging of the more generic cross-platform library. The packaging and release is maintained by the team supporting the various ROS", "packages. Please", "concerning this package to the realsense_camera", "Issues.", "For updated details on this library see the", "."]},
{"url": "https://wiki.ros.org/pr2_tuck_arms_action", "package": "pr2_tuck_arms_action", "package_summary": ["The pr2_tuck_arms_action package"], "package_details": ["See"]},
{"url": "https://wiki.ros.org/uvc_camera", "package": "uvc_camera", "package_summary": ["A collection of node(let)s that stream images from USB cameras (UVC)\n     and provide CameraInfo messages to consumers. Includes a\n     two-camera node that provides rough synchronization\n     for stereo vision.\n\n     Currently uses the base driver from Morgan Quigley's uvc_cam package."], "package_details": ["Please use another driver, such as", "(", ").", "This package provides drivers for USB Video Class (UVC) cameras. This standard covers almost all consumer webcams.  The source is on github", "It works with the ROS", "like other streaming", ". Its", "supports binocular streams, publishing synchronized image pairs from two cameras.", "The drivers are implemented as nodes and as", "."]},
{"url": "https://wiki.ros.org/app_manager", "package": "app_manager", "package_summary": ["app_manager"], "package_details": ["See", "in the Building Manager project."]},
{"url": "https://wiki.ros.org/naoqi_sensors_py", "package": "naoqi_sensors_py", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/urdf_parser_plugin", "package": "urdf_parser_plugin", "package_summary": ["This package contains a C++ base class for URDF parsers."], "package_details": []},
{"url": "https://wiki.ros.org/prosilica_camera", "package": "prosilica_camera", "package_summary": ["A ROS driver node for AVT/Prosilica Gigabit Ethernet (GigE) cameras."], "package_details": ["This package contains a ROS driver node for", ". It is built on top of the", ".", "The ROS API of this package is stable. The driver node has been tested extensively with the", "model, which was used in the Willow Garage", ". The node should work with any AVT/Prosilica GigE camera, and we welcome reports of use with other cameras.", "This page and the", "cover expected use of this package. Features of interest to advanced users only are documented", ".", "For basic vision processing of camera images, see the", ".", "Sets the camera to a fixed IP address. The camera must be visible to", ", and must be the only camera listed. The camera must be unopened (i.e.", "should not be running). This tool is normally used once to configure a new camera (see the", ")."]},
{"url": "https://wiki.ros.org/rospeex", "package": "rospeex", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/velodyne_simulator", "package": "velodyne_simulator", "package_summary": ["Metapackage allowing easy installation of Velodyne simulation components."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_gazebo_plugins", "package": "pr2_gazebo_plugins", "package_summary": ["Gazebo Plugins for various PR2-specific sensors and actuators on the robot."], "package_details": ["plugin provides ROS topic and service interfaces similar to those provided by the", "on PR2.", "plugin provides ROS topics and services similar to those provided by", "on physical PR2.", "plugin provides similar ROS interface as", "on the physical PR2 robot.  This plugin is written in a way that", "works transparently with either this simulated plugin or the", "hardware.  For more information on using", "or", "with this plugin, please see", ".", "This package contains dynamic plugins for", "and", "integration with simulated hardware.", "Please see", "for additional supported hardware components in simulation.", "This stack will be updated with new features as the PR2 hardware itself is updated. Future versions will also incorporate", "options to match ORS driver functionality."]},
{"url": "https://wiki.ros.org/slime_wrapper", "package": "slime_wrapper", "package_summary": ["ROS wrapper for slime"], "package_details": ["This is a ROS wrapper around", ", more precisely, the", "branch of it, see", "."]},
{"url": "https://wiki.ros.org/video_player", "package": "video_player", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/unique_identifier", "package": "unique_identifier", "package_summary": ["ROS messages and interfaces for universally unique identifiers. Not needed for wet packages, use only to resolve dry stack dependencies."], "package_details": ["This stack defines a ROS message for a", ", as described in", ".", "This stack was originally released for Fuerte (without the", "C++ API).", "For Groovy, the C++", "API was added.", "For Hydro, the packages were converted to build using", ". The", "stack became an empty meta-stack, depending on", "and", "for backwards compatibility with rosbuild stacks. Catkin packages should depend on those packages directly, not depending on", ".", "The interface is now", "."]},
{"url": "https://wiki.ros.org/ucl_drone", "package": "ucl_drone", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ardrone_autonomy", "package": "ardrone_autonomy", "package_summary": [], "package_details": ["Documentation is hosted", "."]},
{"url": "https://wiki.ros.org/rosemacs", "package": "rosemacs", "package_summary": ["ROS tools for those who live in Emacs."], "package_details": ["(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "maintains information about current ROS topics.  The topic list is used for tab completion, both in the shell and emacs commands, of topics in the appropriate places.", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "(", ")", "is an Emacs extension that allows you to write snippets, which are templates for recurring patterns in source code.  Rosemacs (trunk) provides a few ros-specific ones in the", "directory.  E.g., if you enable snippets support and set up your path as per the above instructions, if you open up a new file", "in the", "package and type", "followed by", ", it will:", "This is an emacs extension for dealing with ros.  Simplifies navigating the package system, tracking topics and nodes, and running various commands (", ",", ",", ") directly from emacs.", "Setting up", "defines a set of ROS-related emacs commands.  These can be either called using the full command names given below (using", ") or using a keyboard shortcut, if you've set a prefix for the ros-keymap.  For example, given the setup below,", "will find a package or file using rospack.  Type", "to see if there's a shortcut for a given command.  Type", "to see the entire list of keyboard shortcuts.  In this document, we'll list the keyboard shortcut with each command, which has to be preceded with whatever prefix you're using (in our case", ").", "If you are a Lisp developer you'll probably need the", "package. It installs", "automatically as a dependency.", "The most up-to-date version of rosemacs code can be found", ". Installation instructions can be found in the README file.", "What you'll need to do will be something like the following:", "IMPORTANT: Make sure the standard ROS variables are always set in the emacs process environment.  For example, if you use bash, follow the standard ROS installation instructions about sourcing", "in your", ", and launch emacs from a bash shell.", "Update your", ", e.g.:", "For troubleshooting consult the", "file.", "Put the following in your", "(e.g.", "):", "The", "buffer contains a timestamped list of noteworthy events in the ros system.  Useful for answering the question \"did something unexpectedly die?\" when your system is behaving strangely.  Currently, it keeps track of nodes starting and stopping.", "By default, ROS tab completion does not work if you use shell-mode in emacs.", "fixes this and adds completion of current nodes and topics.", "You can add the following expression to the customization", ":", "Invoking rosemacs makes files with extension", ",", "and", "open in Emacs's gdb-script-mode for syntax highlighting.  You can override this behavior by updating the", "variable after calling", ".", "Emacs 23 and later includes", "which, given a RELAX NG schema, validates xml documents online as you edit them and provides intelligent completion.  Rosemacs includes schemas for roslaunch and manifest.xml files.  This is now automatically setup (with Emacs 23 and later).", "For more information on programming ROS packages in Lisp see the", "package wiki.", "There are various customizable options.  You can set these using emacs's customization system (in the", "customization group), or by just doing", "in your .emacs."]},
{"url": "https://wiki.ros.org/lanelet2", "package": "lanelet2", "package_summary": ["Meta-package for lanelet2"], "package_details": ["is a C++ library for handling map data in the context of automated driving. It is designed to utilize high-definition map data in order to efficiently handle the challenges posed to a vehicle in complex traffic scenarios. Flexibility and extensibility are some of the core principles to handle the upcoming challenges of future maps.", "Use GitHub to", ". [", "]", "Lanelet2 is the successor of the old", "that was developed in 2013.", "For more information, please refer to our", ".", "If you are using Lanelet2 for scientific research, we would be pleased if you would cite our", ":"]},
{"url": "https://wiki.ros.org/rovio_shared", "package": "rovio_shared", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rovio_shared\" in rosdoc: /var/www/docs.ros.org/en/api/rovio_shared/manifest.yaml", "The", "package contains a library that is used to communicate with the Rovio. This package and library are intended to be used with the packages provided in the", "stack; however, it is possible to compile and use the library in your own packages as well.", "To install the", "stack, you can choose to either install from source, or from the Ubuntu package:", "While the", "library was constructed primarily for use within the", "stack's packages, it is possible to utilize its functionality in any ROS node.", "The example below has the Rovio drive forwards until the user issues a", "command. Other information on the", "library can be found in the", ".", "Create a", "object by supplying it with the username and password to your Rovio. This object with use", "to communicate to the Rovio's HTTP server.", "Here we construct and send an HTTP command based on the", ". In this example we will tell to Rovio to drive forwards at speed 5. This function will return a pointer to a 'rovio_response' struct containing the response from the Rovio. Even if this information is not need it is important to always free this struct once you are finished to prevent a memory leak.", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/kuka", "package": "kuka", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program.", "See the", "metapackage for additional packages, such as", "configuration packages and", "plugins.", "For questions related to the KUKA support or ROS Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/nao_vision", "package": "nao_vision", "package_summary": [], "package_details": ["The", "package allows easy control and access of the NAO's vision via ROS. These packages have been tested with", ".", "To install the", "stack, simply run the following commands in your shell:", "The", "package contains a", "file which should be edited with the hostname and port of your NAO. Additionally, if your local", "does not include the path to your NAOqi /lib folder, an optional parameter can be set in the launch file. Parameters are also included to configure the resolution and the camera (bottom or top) that will be streamed. These are set to the default values in the given launch file. This file launches an instance of the", "node. To launch this node, the following commands can be used:", "With the above node running, you can test video streaming with the", "package using the following command:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/dbw_pacifica_can", "package": "dbw_pacifica_can", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qb_hand", "package": "qb_hand", "package_summary": ["This package contains the ROS interface for qbrobotics\u00ae qbhand device."], "package_details": []},
{"url": "https://wiki.ros.org/tuw_multi_robot_msgs", "package": "tuw_multi_robot_msgs", "package_summary": ["The tuw_multi_robot_msgs package contains messages for sending graph, route and sync data over topics."], "package_details": ["Use GitHub to", ". [", "]", "This package provides messages to the", "package to send graphs over topics."]},
{"url": "https://wiki.ros.org/kobuki_description", "package": "kobuki_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/blink1", "package": "blink1", "package_summary": [], "package_details": ["This node provides a ROS service that manipulates", ". Accompanies the node an API that facilitates the use of the service.", "Create a catkin workspace. For instructions on how to create the workspace go", ". Download and compile the package:", "To permanently change the permissions of the device and run the node in the user mode, please refer to the", "."]},
{"url": "https://wiki.ros.org/arni_rqt_overview_plugin", "package": "arni_rqt_overview_plugin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_testsuite", "package": "kobuki_testsuite", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/aruco", "package": "aruco", "package_summary": ["The ARUCO Library has been developed by the Ava group of the Univeristy of Cordoba(Spain).\n    It provides real-time marker based 3D pose estimation using AR markers."], "package_details": []},
{"url": "https://wiki.ros.org/kuka_kr16_support", "package": "kuka_kr16_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/urdfdom_headers", "package": "urdfdom_headers", "package_summary": [], "package_details": ["This is now an upstream package, and can be found here:"]},
{"url": "https://wiki.ros.org/velodyne_utils", "package": "velodyne_utils", "package_summary": [], "package_details": ["In Hydro it is", ", but still provided. Catkin stacks should never use it, but rosbuild stacks depending on", "should still work.", "In Indigo, all references must be changed to use", "directly.", "See", ", the only package."]},
{"url": "https://wiki.ros.org/pepperl_fuchs_r2000", "package": "pepperl_fuchs_r2000", "package_summary": ["The Pepperl+Fuchs R2000 laser range finder driver package"], "package_details": ["(from the official datasheet with permission from Pepperl+Fuchs)", "The driver is based upon the widespread boost asio library (", ")", "The driver comes as a library, which contains the actual driver, and has additionally a ROS-Node interface to the Robot Operating System (", "), which can be used optionally.", "Official Website:", "Datasheet OMD10M-R2000 (en):", "Datasheet OMD30M-R2000 (en):", "The ROS package", "consists of the driver library and a node named", ", which is linked to the library. This is the actual driver node. The", "is only needed if you want to display the sensors data using the", "method mentioned below.", "Copy the driver in your ROS workspace and compile it. Set the IP-Address of the scanner in", "and run the following command:", "This starts", "(", ") and the driver and you should see the measuring output of the scanner.", "There exists a file", "in the", "directory. Replace", "with it to compile the driver without ROS:", "This builds a SHARED library which can be used in your program.  To build a static library remove the", "in the", "command in the", ".", "The driver is commented in doxygen style.  You can create a latex and html documentation in the", "directory  by entering the following command in the", "directory:"]},
{"url": "https://wiki.ros.org/nodelet", "package": "nodelet", "package_summary": ["The nodelet package is designed to provide a way to run multiple\n    algorithms in the same process with zero copy transport between\n    algorithms.\n\n    This package provides both the nodelet base class needed for\n    implementing a nodelet, as well as the NodeletLoader class used\n    for instantiating nodelets."], "package_details": ["Nodelets are designed to provide a way to run multiple algorithms on a single machine, in a single process, without incurring copy costs when passing messages intraprocess. roscpp has optimizations to do zero copy pointer passing between publish and subscribe calls within the same node.  To do this nodelets allow dynamic loading of classes into the same node, however they provide simple separate namespaces such that the nodelet acts like a seperate node, despite being in the same process.  This has been extended further in that it is dynamically loadable at runtime using", ".", "For command line and launch file examples see this tutorial", "These are nodelet aware wrappers around", "macros.  They include verbosity levels DEBUG, INFO, WARN, ERROR, and FATAL.  These macros will only compile inside nodelet methods.", "If you want the no-copy pub/sub to work you must publish your messages as", "s.  See", "for more details.", "Following commands are helpful to list all nodelets available on your system found in", ". Note that it's NOT the list of currently running nodelet nor nodelet managers.", "Or list the nodelet xml files for", "by:"]},
{"url": "https://wiki.ros.org/multimaster_msgs_fkie", "package": "multimaster_msgs_fkie", "package_summary": ["The messages required by multimaster packages."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"multimaster_msgs_fkie\" in rosdoc: /var/www/docs.ros.org/en/api/multimaster_msgs_fkie/manifest.yaml", "The", "describes a discovered ROS Master by", "and", ". It offers also additional information about corresponding", "node and timestamps of last detected changes of the ROS Master. The", "service returns the list with current discovered ROS Masters. The changes of each ROS Master are annonced by", ".", "The", "and", "messages offers additional information about the link quality to discovered ROS Master machines.", "The", "service uses", "respectively", "messages to return the all currently synchronized", "and", ".", "The services", "and", "returns the nodes and their description. The", "service can then be used to launch one of these nodes. See", "for additional information."]},
{"url": "https://wiki.ros.org/industrial_utils", "package": "industrial_utils", "package_summary": ["Industrial utils is a library package that captures common funcitonality for the ROS-Industrial distribution."], "package_details": ["Use GitHub to", ". [", "]", "The industrial utilities package provides a common package library for", "functions.  The functions in this package apply across package boundaries.  Utility functions for single packages should not be included in this package."]},
{"url": "https://wiki.ros.org/adi_driver", "package": "adi_driver", "package_summary": ["The adi_driver package"], "package_details": ["Use GitHub to", ". [", "]", "Documentation for", "is now", "."]},
{"url": "https://wiki.ros.org/arbotix_sensors", "package": "arbotix_sensors", "package_summary": ["Extends the arbotix_node package with a number of more sophisticated ROS wrappers for common devices."], "package_details": ["The arbotix_sensors package contains several sensor modules that add additional layers of ROS interface onto the basic structure of", "."]},
{"url": "https://wiki.ros.org/ping360_sonar", "package": "ping360_sonar", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_image_snapshot_recorder", "package": "pr2_image_snapshot_recorder", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/leptrino_force_torque", "package": "leptrino_force_torque", "package_summary": [], "package_details": ["ROS driver package for", "force-torque sensor", ",", ", both of which seemingly only Japanese available as of Sep. 2016)."]},
{"url": "https://wiki.ros.org/mir_description", "package": "mir_description", "package_summary": ["URDF description of the MiR robot"], "package_details": []},
{"url": "https://wiki.ros.org/rospeex_launch", "package": "rospeex_launch", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_robot", "package": "maggie_robot", "package_summary": [], "package_details": ["The user's interface to the", "stack is", ", which provides launch files that can be used to bring up the robot. The other packages in this stack are used during the bringup process, and are not usually accessed directly by users.", "Starting up the robot is not any different from launching a normal ROS program. Launch the", "file.", "Check out the", "that guide you through all the steps for running the Maggie devices.", "Go to", ".", "Report new issues on"]},
{"url": "https://wiki.ros.org/rospeex_samples", "package": "rospeex_samples", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/agvs", "package": "agvs", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation.", "1."]},
{"url": "https://wiki.ros.org/nav2d_exploration", "package": "nav2d_exploration", "package_summary": ["This package holds a collection of plugins for the RobotNavigator, that provide\n    different cooperative exploration strategies for a team of mobile robots."], "package_details": []},
{"url": "https://wiki.ros.org/ros_additive_manufacturing", "package": "ros_additive_manufacturing", "package_summary": [], "package_details": ["Documentation is here:"]},
{"url": "https://wiki.ros.org/robot_pose_ekf", "package": "robot_pose_ekf", "package_summary": ["The Robot Pose EKF package is used to estimate the 3D pose of a robot, based on (partial) pose measurements coming from different sources. It uses an extended Kalman filter with a 6D model (3D position and 3D orientation) to combine measurements from wheel odometry, IMU sensor and visual odometry. The basic idea is to offer loosely coupled integration with different sensors, where sensor signals are received as ROS messages."], "package_details": ["The", "node does not require all three sensor sources to be available all the time. Each source gives a pose estimate and a covariance. The sources operate at different rates and with different latencies. A source can appear and disappear over time, and the node will automatically detect and use the available sensors.To add your own sensor inputs, check out", "All the sensor sources that send information to the filter node can have their own", "reference frame, and each of these", "reference frames can drift arbitrary over time. Therefore, the", "sent by the different sensors cannot be compared to each other. The node uses the", "of each sensor to update the extended Kalman filter.", "As a robot moves around, the uncertainty on its pose in a world reference continues to grow larger and larger. Over time, the covariance would grow without bounds. Therefore it is not useful to publish the covariance on the pose itself, instead the sensor sources publish how the covariance changes over time, i.e. the covariance on the velocity.", "Imagine the robot pose filter was last updated at time t_0. The node will not update the robot pose filter until at least one measurement of", "sensor arrived with a timestamp later than t_0. When e.g. a message was received on the", "topic with timestamp t_1 > t_0, and on the", "topic with timestamp t_2 > t_1 > t_0, the filter will now update to the latest time at which information about all sensors is available, in this case to time t_1. The odom pose at t_1 is directly given, and the imu pose at t_1 is obtained by linear interpolation of the imu pose between t_0 and t_2. The robot pose filter is updated with the relative poses of the odom and imu, between t_0 and t_1.", "The above figure shows experimental results when the PR2 robot started from a given initial position (green dot), driven around, and returned to the initial position. A perfect odometry x-y plot should show an exact loop closure. The blue line shows the input from the wheel odometry, with the blue dot the estimated end position. The red line shows the output of the", ", which combined information of wheel odometry and imu, with the red dot the estimated end position."]},
{"url": "https://wiki.ros.org/patrolling_sim", "package": "patrolling_sim", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_moveit_tutorials", "package": "pr2_moveit_tutorials", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rsv_balance_simulator", "package": "rsv_balance_simulator", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_ir_controller", "package": "maggie_ir_controller", "package_summary": [], "package_details": ["The", "file contains all possible commands to use with a TV. To generate new commands for another TV consult the Users Manual.", "This device supports all the drivers implemented in the", "package."]},
{"url": "https://wiki.ros.org/kobuki_core", "package": "kobuki_core", "package_summary": ["Non-ROS software for Kobuki, Yujin Robot's mobile research base."], "package_details": ["Driver documentation is provided by", ".", "For ros-related information about kobuki, visit either the", "or the", "pages."]},
{"url": "https://wiki.ros.org/abb_irb6600_support", "package": "abb_irb6600_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rail_object_detector", "package": "rail_object_detector", "package_summary": [], "package_details": [": recognize objects in the latest image from the camera stream", ".  Takes no input, and outputs a list of detected, labeled objects and a corresponding image.  Only advertised if", "is true.", ": recognize objects in an image passed to the service.  Takes an image as input, and outputs a list of detected, labeled objects and a corresponding image. Only advertised if", "is true.", "This package includes two object detectors which you may choose between, YOLOv2 and Deformable R-FCN (DRFCN). Detections from YOLOv2 are a bit faster, >10fps compared to ~4fps (on a Titan X), but less accurate than the detections from DRFCN.", "The YOLOv2 detector uses", "to perform object detection. It provides the ability to query for objects in an image through both services as well as from a topic.", "The", "detector is built on MXNet, and provides the ability to query for objects from a topic.", "The nodes in this package publish a list of", "within a given image, each of which has the following properties:", "The DRFCN detector requires a CUDA and cuDNN capable GPU, so it is not installed by default. In order to use it, we recommend getting this code from Github and following the instructions in the", ". The rest of this documentation covers instructions for a CPU-only install of this package that uses darknet.", "This package contains a single ROS node -", "- which serves as an interface between a ROS system and the trained object recognition network.", "Type:", "Type:", "Type:", "Topic with object detections performed in the background by grabbing images at a specified interval. Only advertised if", "is true.", "Type:", "Default:", "Number of asynchronous threads that can be used to service each of the services.", "implies the use of one thread per processor", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "Type:", "Default:", "A good set of weights, to complement the default trained labels can be obtained from", ".", "To build using CUDA, obtain the package from Github and follow the instructions in the", ". This is necessary if you wish to use the Deformable R-FCN detector.", "The underlying Darknet code has been copied as is. So the detector can be trained and retrained following instructions on the", ".", "The same is true for the Deformable R-FCN. Check the", "for details."]},
{"url": "https://wiki.ros.org/rwt_speech_recognition", "package": "rwt_speech_recognition", "package_summary": ["The rwt_speech_recognition package"], "package_details": []},
{"url": "https://wiki.ros.org/rospack", "package": "rospack", "package_summary": ["ROS Package Tool"], "package_details": ["is a command-line tool for retrieving information about ROS", "available on the filesystem. It implements a wide variety of commands ranging from locating ROS packages in the filesystem, listing available packages, to calculating the dependency tree of packages. It is also used in the ROS", "for calculating build information for packages.", "For an equivalent tool for", ", see", ".", "Prior to ROS", ",", "was included in the", "stack.  Since Fuerte, it is a standalone tool.", "Documentation is available", "."]},
{"url": "https://wiki.ros.org/visualization_msgs", "package": "visualization_msgs", "package_summary": ["visualization_msgs is a set of messages used by higher level packages, such as", ", that deal in visualization-specific data.\n\n    The main messages in visualization_msgs is", ".\n    The marker message is used to send visualization \"markers\" such as boxes, spheres, arrows, lines, etc. to a visualization environment such as", ".\n    See the rviz tutorial", "for more information."], "package_details": [": this package was moved from", "to", ".", "Newly proposed, mistyped, or obsolete package. Could not find package \"visualization_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/visualization_msgs/manifest.yaml", "is the", "top-level message for sending data from the interactive marker server", "to the client (i.e. rviz).  The update message has an array of", "messages which are", "new or which need to be updated.  It also has an array of", "messages for", "sending only pose updates to existing interactive markers.", "A useful overview of", "types can be found at", ".", "An introduction to the InteractiveMarker messages is given in the interactive marker tutorial at", ".", "Each", "message has an", "array of", "s", "which describe its subcomponents.  Each", "has an array", "of", "s which together describe the", "shape of the control.", "The", "message also has", "an array of", "s which together", "define a context menu which should appear when the appropriate action", "happens in the client (like a right-click).  Although the entries are", "sent in a flat array, each one contains an id and a parent_id to", "specify a tree structure.  This is described in", "."]},
{"url": "https://wiki.ros.org/abb_common", "package": "abb_common", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/asr_flock_of_birds_tracking", "package": "asr_flock_of_birds_tracking", "package_summary": ["This package controls a motorized robot head (a sensor setup equipped with a PTU) in order to ensure that the hand of a human user remains inside its field of view. The human hand is tracked with the help of an Ascension - Flock of Birds system. The purpose of this package is to enable continuous localization of objects during their manipulation through the tracked hand."], "package_details": ["First of all, the position of magnet tracker (p) is transformed into the PTU's coordinate frame. Azimuth (a_xy) and altitude (a_yz) are calculated with the arccos of dot-Product divided by euclidiean distance. The following equations shows this:", "To successfully run this tool the whole kinematic chain of the PbD -Dome has to be started (PTU and Flock of Birds) first and the correct topic- and framenames have to set in \"", "\". With keys \"R\" or \"L\" the PTU can look at the right or left tracker (autonomous tracking). In addition the PTU can be moved with the arrwokeys (direct PTU controlling)."]},
{"url": "https://wiki.ros.org/joint_state_publisher_js", "package": "joint_state_publisher_js", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rviz", "package": "rviz", "package_summary": ["3D visualization tool for ROS."], "package_details": [".  [", "]", "rviz does not have a builtin capability to record movies.  You can, however, use an application like", "(or", ") to do so.  The", "page has more information on recording and encoding."]},
{"url": "https://wiki.ros.org/qb_device_driver", "package": "qb_device_driver", "package_summary": ["This package contains a device-independent API wrapper for qbrobotics\u00ae devices."], "package_details": ["This is the only package among the ones in", "which can be used as a stand-alone ROS node, called", ". It wraps the", "API, manages the shared resources and provides a multi-node from/to multi-device communication interface.", "The", "node manages the serial communication from the ROS ecosystem to the physical", "devices connected to it through any serial ports, and vice versa. The need of such a mediator is demanded to the possibility to connect several devices together (i.e. in a chain) and access them through a single serial port. Each ROS node representing a device has to request services to the owner of the shared resources, i.e. the Communication Handler.", "To start an instance of the Communication Handler node, execute the following command from a terminal (it", "any configuration parameters):"]},
{"url": "https://wiki.ros.org/ainstein_radar_msgs", "package": "ainstein_radar_msgs", "package_summary": ["ROS message definitions for Ainstein radars."], "package_details": []},
{"url": "https://wiki.ros.org/sf30_node", "package": "sf30_node", "package_summary": [], "package_details": ["This is a ROS node for", "The node assume the following setup for the laser (I used the", "terminal from the manufacture):", "Create a catkin workspace. For instructions on how to create the workspace go", ". Download and compile the package:", "The message of type", "will be published in topic /sf30/range at 50Hz. The intensities field on this message means data confidence. It is 1 if we can trust the given range."]},
{"url": "https://wiki.ros.org/pacifica_dbw", "package": "pacifica_dbw", "package_summary": ["A ROS interface to the New Eagle Raptor drive-by-wire controller"], "package_details": ["The raptor_dbw", "is a collection of packages for interacting with the New Eagle Raptor DBW controllers. The primary goal of this stack is to facilitate ROS-based DBW kit development and provide a set of ROS-CAN interface tools.", "The current development branch is", "and targets ROS", "and", ".", "For more on New Eagle Raptor controllers see:"]},
{"url": "https://wiki.ros.org/qb_hand_control", "package": "qb_hand_control", "package_summary": ["This package contains the ROS control node for qbrobotics\u00ae qbhand device."], "package_details": ["This package contains the ROS control node and its structures to control the", "or the", "device. It exploits the features provided by the base device-independent control library (cf.", ") and the specific hardware interface (cf.", ").", "The launch files start a ROS node for the", "or the", "to control it through a GUI and through predefined configurable waypoints (stored in the", "). In both cases the controllers setup can be found in the", "; it is recommended not to change the default settings though.", "This launch file calls the template", "with the default settings to bringup a full control node for the device based on GUI inputs. It also starts the Communication Handler and therefore it is recommended not to start other driver nodes while using this one (cf.", "to control several devices together).", "This launch file calls the template", "with the default settings to bringup a full control node for the device based on waypoint inputs. It also starts the Communication Handler and therefore it is recommended not to start other driver nodes while using this one (cf.", "to control several devices together).", "This control library specifically designed for the robotic hand extends the", "and exploits the", ", therefore it provides all the ROS resources and requires all the specifications of this two base packages."]},
{"url": "https://wiki.ros.org/pr2_plugs_msgs", "package": "pr2_plugs_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"pr2_plugs_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/pr2_plugs_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/pr2_ethercat", "package": "pr2_ethercat", "package_summary": ["Main loop that runs the robot."], "package_details": ["is usually executed from a launch file, such as", "/pr2.launch.  Common configuration:", "is a utility that allows a regular user to run", "with appropriate capabilities. See the section in", "on \"Permissions.\"", "is a simple command-line script that calls the", "service.", "(formerly", "in Groovy and earlier)", "Running", "requires the following \"capabilities\":", "Superuser has these capabilities, but they can also be granted to another executable by setting file system attributes on the executable file.  The", "program is a setuid-root program which copies", "to a part of the filesystem where attributes can be set (", "), and then grants the necessary capabilities to be able to run", "."]},
{"url": "https://wiki.ros.org/motoman_sia20d_support", "package": "motoman_sia20d_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav2d_tutorials", "package": "nav2d_tutorials", "package_summary": ["Contains a set of tutorials that run 2D-Navigation within Stage-Simulator."], "package_details": []},
{"url": "https://wiki.ros.org/innok_heros_driver", "package": "innok_heros_driver", "package_summary": [], "package_details": ["ROS driver for the", "robot plattform."]},
{"url": "https://wiki.ros.org/odometry_publisher_tutorial", "package": "odometry_publisher_tutorial", "package_summary": ["The odometry_publisher_tutorial package"], "package_details": ["This package provides the code for the", "tutorial."]},
{"url": "https://wiki.ros.org/kobuki_bumper2pc", "package": "kobuki_bumper2pc", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qb_device_description", "package": "qb_device_description", "package_summary": ["This package contains a device-independent description utilities for qbrobotics\u00ae devices."], "package_details": ["This package is barely usable alone since it provides only templates to create more structured launch files in the derived packages (cf.", ").", "The two launch file templates come in help when loading the description package of a device. It could seem unlikely to split the two files (and actually they are often called sequentially), but it guarantees in a", "to be able to load every single robot description in each device namespace (which is required to setup their control nodes) and to load the whole robot model complete with", ",", "and", "only once."]},
{"url": "https://wiki.ros.org/applanix_driver", "package": "applanix_driver", "package_summary": [], "package_details": ["The", "stack provides a comprehensive ROS interface to", ", which integrate GPS, IMU, and DMI data into a high accuracy position and orientation fix.", "These packages have not (yet) been released for Indigo or newer versions, but can be build from source in your catkin workspace. Refer to the", "for more information on building catkin workspaces.", "If you're looking for the topic for a particular Applanix group, please consult the file", ".", "The", "package provides a direct translation of the Applanix binary format into ROS messages and services. The remaining packages provide helper nodes which further convert those messages into familiar ROS messages (", ",", ",", ", etc), and offer some support for configuration via ROS parameters.", "The applanix_msgs package contains a ROS", "for each Applanix data group and command message, as well as", ", which controls the naming of the resultant ROS topics and service. The applanix_generated_msgs package contains a script which creates a wrapper", "for each command message, and also assembles a mega AllMsgs.msg file. This structure allows a natural service-oriented interface to configuring and commanding the Applanix hardware, while still allowing the user to subscribe to a single topic to receive a snapshot of the device's configuration at a given time."]},
{"url": "https://wiki.ros.org/schunk_canopen_driver", "package": "schunk_canopen_driver", "package_summary": [], "package_details": ["If you have the fzi_icl_core or fzi_icl_can package in your workspace you'll have to build it with", ", as those packages are plain cmake packages. See the", "for details.", "The simpler", "-interface accepts series of waypoints which the robot will drive to with internal interpolation. It is not guaranteed (and might almost never happen), that all joints finish moving at the same time. If multiple waypoints are given, a new waypoint is started for all joints at the same time as soon as the last joint reached it's previous destination. Ramping up and down between waypoints is done by the robot internally depending on it's configuration. The ramping setup will be treated later on.", "The", "-interface provides a position controller in joint space which will interpolate between waypoints inside the controller (on the host PC). You can set joint velocities and time constraints for each waypoint which the controller will take care of.", "This launchfile gives a ready-to-use action interface for ros_control. It loads controllers defined in", "(This can be changed in the ros_control.launch file). Parameters:", "If your robot arm does use custom canopen IDs, you can modify those in the", "file. When modifying the canopen IDs you will also have to modify the node mapping in", "which will perform the mapping between the canopen IDs and the URDF joint names. See the example config file for a syntax explanation.", "When using the simple profile position mode Ramping up and down is controlled by the hardware. The velocity and acceleration can be configured in the", "file. Also, targets can be commanded as a relative motion to the current position or as an absolute position relative to the home position (which is the default). Change the", "parameter if you like to change this behavior.", "Canceling a goal at high speeds seems to set the robot into a fault state. This comes from within the used position controller as it commands the robot to hold a position which is too far away to be reached within one control cycle. As a workaround prefer the", "service"]},
{"url": "https://wiki.ros.org/nao_audio", "package": "nao_audio", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kuka_lbr_iiwa_support", "package": "kuka_lbr_iiwa_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosrun", "package": "rosrun", "package_summary": [], "package_details": ["is part of the", "suite. Documentation moved to", "."]},
{"url": "https://wiki.ros.org/razor_imu_9dof", "package": "razor_imu_9dof", "package_summary": ["razor_imu_9dof is a package that provides a ROS driver for the Sparkfun OpenLog Artemis, 9DoF Razor IMU M0, 9DOF Razor IMU and 9DOF Sensor Stick. It also provides Arduino firmware that runs on the board, and which must be installed on it for the system to work. A node which displays the attitude (roll, pitch and yaw) of the board (or any IMU) is provided for testing."], "package_details": []},
{"url": "https://wiki.ros.org/rb1_base_common", "package": "rb1_base_common", "package_summary": [], "package_details": ["This package contains the launch and configuration files needed to start the localization process as well as the mapping process. By default,", "is the localization algorithm and for mapping the default node is", ".", "This package contains the launch and configuration files needed to use the", ". It uses move_base package to move the robot to a desired map-based position."]},
{"url": "https://wiki.ros.org/libccd", "package": "libccd", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/navigation_layers", "package": "navigation_layers", "package_summary": ["Extra navigation layers."], "package_details": []},
{"url": "https://wiki.ros.org/pepper_sensors_py", "package": "pepper_sensors_py", "package_summary": [], "package_details": ["Wraps the camera node from", "Starts two sonar nodes (from", ") to get the data from the front and the back sonar"]},
{"url": "https://wiki.ros.org/ainstein_radar_tools", "package": "ainstein_radar_tools", "package_summary": ["Tools for monitoring and validating radar data."], "package_details": []},
{"url": "https://wiki.ros.org/segbot", "package": "segbot", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/pr2_kinematics", "package": "pr2_kinematics", "package_summary": ["The pr2_kinematics package"], "package_details": ["To learn how to use the kinematics nodes for the PR2 through a ROS API, check out", "."]},
{"url": "https://wiki.ros.org/rotors_comm", "package": "rotors_comm", "package_summary": ["RotorS specific messages and services."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rotors_comm\" in rosdoc: /var/www/docs.ros.org/en/api/rotors_comm/manifest.yaml"]},
{"url": "https://wiki.ros.org/agvs_description", "package": "agvs_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_full_pr2", "package": "moveit_full_pr2", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/khi_rs_ikfast_plugin", "package": "khi_rs_ikfast_plugin", "package_summary": ["The khi_rs_ikfast_plugin package"], "package_details": []},
{"url": "https://wiki.ros.org/micros_swarm_framework", "package": "micros_swarm_framework", "package_summary": [], "package_details": ["note: we could define", "structure using the simple type, for example int, float, string. For the user-defined data-type, we need to use the Macro definition defined in the micros_swarm_framework to serialize in order to store and transport data of this type. We provided two Macro definition:BOOST_SERIALIZE, MEMBER:"]},
{"url": "https://wiki.ros.org/maggie_base", "package": "maggie_base", "package_summary": [], "package_details": ["This device supports all the drivers implemented in the", "package."]},
{"url": "https://wiki.ros.org/predicate_manager", "package": "predicate_manager", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_teleop_general", "package": "pr2_teleop_general", "package_summary": ["pr2_teleop_general"], "package_details": ["(", ", default:", ")", "(", ", default:", ")", "Note: This package originated as", "and wasn't released before", ".", "The base control is accessible by pushing the top left front button.  Base and torso controls are essentially the same as that described in", "."]},
{"url": "https://wiki.ros.org/pr2_app_manager", "package": "pr2_app_manager", "package_summary": ["Scripts and tools for running the application manager on the PR2."], "package_details": ["If you have the old version, you will be asked if you want to set up your SSH keys.  Answer \"Y\" for yes.  You should see a random ASCII art square.  Then type", "to log back out of the \"applications\" user account.", "If you have the new version, you will not be asked anything, you will just get a regular shell prompt.  Type", "to log out of the \"applications\" account.", "The QR codes for the PR2s are specified with a variety of attributes stored in YAML to help connect to them. They are generated using", ". To create the QR codes, use the \"Text\" mode, type in the text (examples below) and click generate. When you are finished, you can right click and save or print the QR code image. To avoid the hassle of printing, many devices can read the QR code directly off of your PC screen."]},
{"url": "https://wiki.ros.org/keyboard", "package": "keyboard", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_comm", "package": "ros_comm", "package_summary": ["ROS communications-related packages, including core client libraries (roscpp, rospy) and graph introspection tools (rostopic, rosnode, rosservice, rosparam)."], "package_details": ["Use GitHub to", ". Please use 'ros_comm:' at the beginning of the title. [", "]", "The", "stack contains the ROS middleware/communications packages. These packages are collectively known as the ROS \"Graph\" layer. They provide implementations and tools for", ",", ",", ", and", ". This includes the supported ROS client libraries:", ",", ", and", ".", "C Turtle has an empty version of the", "stack. This is provided so that stacks may update their dependencies for Diamondback but not break dependency compatibility with a C Turtle release.", "ros_comm developers only:"]},
{"url": "https://wiki.ros.org/velodyne_description", "package": "velodyne_description", "package_summary": ["URDF and meshes describing Velodyne laser scanners."], "package_details": ["Documentation at"]},
{"url": "https://wiki.ros.org/rotate_recovery", "package": "rotate_recovery", "package_summary": ["This package provides a recovery behavior for the navigation stack that attempts to clear space by performing a 360 degree rotation of the robot."], "package_details": ["(", ", default: 0.017)", "(", ", default: 0.05)", "The", "is a simple recovery behavior that attempts to clear out space in the navigation stack's", "by rotating the robot 360 degrees if local obstacles allow. It adheres to the", "interface found in the", "package and can be used as a recovery behavior", "for the", "node.", "The", "object exposes its functionality as a", ". It operates within a ROS namespace (assumed to be", "from here on) specified on initialization. It adheres to the", "interface found in the", "package.", "Example creation of a", "object:", "The", "object assumes that the local planner used by the", "node is the", "documented in the", "package and reads some of its parameters accordingly. It will work on its own, but this requires the user to specify additional parameters.", "These parameters are already set when using the", "local planner, they only need to be set explicitly for the", "recovery behavior if a different local planne is used with the", ".", "The C++", "class adheres to the", "interface found in the", "package. For detailed documentation, please see", "."]},
{"url": "https://wiki.ros.org/nodelet_topic_tools", "package": "nodelet_topic_tools", "package_summary": ["This package contains common nodelet tools such as a mux, demux and throttle."], "package_details": ["represent a mux nodelet for topics: it takes N (<=8) input topics, and publishes all of them on one output topic. One implementation of", "can be found in", ".", "represent a demux nodelet for topics: it takes 1 input topic, and publishes on N (<=8) output topics. One implementation of", "can be found in", ".", "can throttle a topic in a nodelet to a specified rate. Note that this tool is in the", "namespace.", "The", "package contains a MUX (", ") and a DEMUX (", ") nodelet.", "The above accepts data from", "and", ", and republishes it on", ".", "To compile the", "nodelet in your library, add something like:", "(replace", "with the message type of choice).", "The above accepts data from", ", and republishes it on", "and", ".", "To compile the", "nodelet in your library, add something like:", "(replace", "with the message type of choice).", "To compile the", "nodelet in your library, add something like:", "(replace", "with the message type of choice)."]},
{"url": "https://wiki.ros.org/abb_irb2400_support", "package": "abb_irb2400_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kvh_geo_fog_3d", "package": "kvh_geo_fog_3d", "package_summary": ["Provides a driver node for KVH GEO FOG 3D INS sensors, messages, and rviz plugins."], "package_details": ["ROS package for the", "set of GNSS/INS sensors."]},
{"url": "https://wiki.ros.org/rotors_evaluation", "package": "rotors_evaluation", "package_summary": ["The dataset evaluation package for the RotorS simulator."], "package_details": []},
{"url": "https://wiki.ros.org/s3000_laser", "package": "s3000_laser", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_keyop", "package": "kobuki_keyop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pepper_robot", "package": "pepper_robot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roscpp", "package": "roscpp", "package_summary": ["roscpp is a C++ implementation of ROS. It provides\n    a", "that enables C++ programmers to quickly interface with\n    ROS", ",", ",\n    and", ".\n\n    roscpp is the most widely used ROS client library and is designed to\n    be the high-performance library for ROS."], "package_details": ["Please refer to the", "package", "For usage documentation and more in-depth treatment than the tutorials, please see the", "For a detailed API reference, please consult the"]},
{"url": "https://wiki.ros.org/pr2_run_stop_auto_restart", "package": "pr2_run_stop_auto_restart", "package_summary": ["This package provides a node that monitors the state of the run stops of the pr2_robot. When the state of the\n   run stop changes from off to on, this node will automatically enable the power to the motors, and reset\n   the motors. This allows you to use the run stop as a 'pause' button. By using the run stop as a tool to\n   power up the robot, the run stop is also in reach of the user once the robot starts moving."], "package_details": []},
{"url": "https://wiki.ros.org/ros_ethercat", "package": "ros_ethercat", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_sia20d_moveit_config", "package": "motoman_sia20d_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/nao_interaction_launchers", "package": "nao_interaction_launchers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_mh5_support", "package": "motoman_mh5_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_bringup", "package": "pr2_bringup", "package_summary": ["Launch files and scripts needed to bring a PR2 up into a running state."], "package_details": ["is a package that collects together the scripts,", "files, and dependencies that are required to bring a PR2 robot into a running state.", "The user's entry point for this package is the file", ".  This launch file contains all nodes to run a complete PR2 system. However, you cannot use pr2.launch to start up the robot (see", "for instructions), because pr2.launch requires another launch file to load the robot description and robot analyzer on the parameter server first.", "To disable the", "set the \"no-prosilica\" arg to \"true\" in \"/etc/ros/robot.launch\" when launching your PR2:", "This manual will take you step by step through starting the PR2 robot,", ". Note: If you have a PR2 that is running both ROS Groovy and ROS Hydro, this is then the start sequence:", "When the PR2 starts up for the first time since a power down, it will move its arms, casters, head and later platform to find the reference position of each joint.  This is done by the calibration script", ". When finished, the PR2 joint calibration script stores the joint reference positions locally in the motor controller board (MCB) of the corresponding joint.  So the next time you start the PR2, it will remember the reference positions and won't have to repeat the same calibration routine over and over again."]},
{"url": "https://wiki.ros.org/qb_device_utils", "package": "qb_device_utils", "package_summary": ["This package contains a device-independent utility functions for qbrobotics\u00ae devices."], "package_details": ["This package contains a device-independent utility functions for", "devices."]},
{"url": "https://wiki.ros.org/uav_simple_tracking", "package": "uav_simple_tracking", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/rb1_common", "package": "rb1_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/roslisp_repl", "package": "roslisp_repl", "package_summary": ["This package provides a script that launches Emacs with Slime (the\n    Superior Lisp Interaction Mode) ready for Lisp development and\n    roslisp."], "package_details": ["is distributed through the ROS release infrastructure.", "This package provides you with a Lisp REPL configured to be used to program ROS packages as well as an integrated IDE for programming in Common Lisp with Emacs (see", ").", "The most up-to-date version of", "code can be found", ". Installation instructions are in the README file.", "What you'll need to do will be something like the following:", "To use the", "just run the executable:", "If you're on earlier versions of ROS, look through the", "configuration file,", "and copy-paste the relevant code into your Emacs config file."]},
{"url": "https://wiki.ros.org/planner_msgs", "package": "planner_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qt_paramedit", "package": "qt_paramedit", "package_summary": ["A GUI application for viewing and editing ROS parameters."], "package_details": ["Note: This package replaces groovy's", "in hydro."]},
{"url": "https://wiki.ros.org/phantomx_reactor_arm_description", "package": "phantomx_reactor_arm_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_pr2_dashboard", "package": "rqt_pr2_dashboard", "package_summary": ["rqt_pr2_dashboard is a GUI for debugging and controlling low-level state of the PR2.  It shows things like battery status and breaker states, as well as integrating tools like rqt_console and robot_monitor."], "package_details": ["A successor of", "with enhancements based on", "framework.", "(see", "for more installation details)"]},
{"url": "https://wiki.ros.org/pepper_control", "package": "pepper_control", "package_summary": [], "package_details": ["Is used within", "and", "packages"]},
{"url": "https://wiki.ros.org/nao_interaction", "package": "nao_interaction", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kuka_experimental", "package": "kuka_experimental", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program. It contains experimental packages that will be moved to the", "repository once they've received sufficient testing and review.", "Refer to the", "for more information.", "For the generic ROS-Industrial tutorials, please see the ROS-Industrial", ".", "For questions related to the KUKA support or ROS-Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/pr2_controller_configuration_gazebo", "package": "pr2_controller_configuration_gazebo", "package_summary": ["A copy of the pr2_controller_configuration package, for use in \n    the PR2 simulator.  We maintain two copies to allow for controller\n    gains to be set differently between hardware and simulation."], "package_details": ["Please see", "for details of all the configuration and launch scripts."]},
{"url": "https://wiki.ros.org/mir_actions", "package": "mir_actions", "package_summary": ["Action definitions for the MiR robot"], "package_details": []},
{"url": "https://wiki.ros.org/dbw_pacifica_msgs", "package": "dbw_pacifica_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kuka_kr120_support", "package": "kuka_kr120_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/marti_common_msgs", "package": "marti_common_msgs", "package_summary": ["marti_common_msgs"], "package_details": []},
{"url": "https://wiki.ros.org/um6", "package": "um6", "package_summary": ["The um6 package provides a C++ implementation of the CH Robotics serial protocol, and a\n    corresponding ROS node for publishing standard ROS orientation topics from a UM6."], "package_details": ["A rosbuild branch is also available in the repository, for users working with rosbuild workspaces under Fuerte or Groovy.", "The UM6 is available for purchase", ". Alternatively, the UM6 is available as a standard supported accessory from Clearpath Robotics\u2014for example, for use with", ".", "For further information about this device and its configuration, please see its", ".", "Please see", "for more information.", "At", ", we use a configuration which subscribes to the magnetometer as a raw data feed, and fuses it into the orientation as a process external to the device. This functionality is provided via the", "package."]},
{"url": "https://wiki.ros.org/map_merge_3d", "package": "map_merge_3d", "package_summary": ["Merging multiple 3D maps, represented as pointclouds,\n  without knowledge of initial positions of robots."], "package_details": ["Use GitHub to", ". [", "]", "finds robot maps automatically and new robots can be added to the system at any time. 3D maps are expected as", ", other map messages are not supported.", "The ROS node can merge maps from the arbitrary number of robots. It expects maps from individual robots as ROS topics and does not impose any particular messaging between robots. If your run multiple robots under the same ROS master then", "may work for you out-of-the-box, this makes it easy to setup a simulation experiment.", "In the multi-robot exploration scenario your robots probably run multiple ROS masters and you need to setup a communication link between robots. Common solution might be", ". You need to provide maps from your robots on local topics (under the same master). Also if you want to distribute merged map and", "transformations back to robots your communication must take care of it.", "Recommended topics names for robot maps are", ",", "etc. However the names are configurable. All robots are expected to publish map under", ", where topic name (", ") is configurable, but must be the same for all robots. For each robot", "is of cause different, but it does not need to follow any pattern. Further, you can exclude some topics using", "parameter, to avoid merging unrelated point clouds.", "Estimating transforms between maps is cpu-intesive so you might want to tune", "parameter to run the re-estimation less often.", "Alongside ROS node", "provides command-line tools to work with point cloud maps saved in", "files. Both tools accept any of the", ".", "The tools use PCL command-line parsing module. PCL command-line parsing has some limits (PCL users won't be surprised): it supports only", "format,", "is not accepted. Unknown options are ignored. Options may be arbitrarily mixed with filenames. There are no short versions for parameters.", "Tool for merging maps offline. Produces", "with merged global map. This tool can merge arbitrary number of maps.", "After one step of the estimation a visualisation window appears. You can freely navigate the point cloud, save a screenshot or camera parameters (press", "to see all shortcuts). After the window is closed, estimation continues with the next phase and the next visualisation window appears. Details about estimation progress are printed to", ".", "This package was developed as part of my master thesis at", "in Prague."]},
{"url": "https://wiki.ros.org/uuid_msgs", "package": "uuid_msgs", "package_summary": ["ROS messages for universally unique identifiers."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"uuid_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/uuid_msgs/manifest.yaml", "This package defines a ROS message for a", ", as described in", "."]},
{"url": "https://wiki.ros.org/moveit_simple_grasps", "package": "moveit_simple_grasps", "package_summary": [], "package_details": ["Extensive documentation available on"]},
{"url": "https://wiki.ros.org/navigation_experimental", "package": "navigation_experimental", "package_summary": ["A collection of navigation plugins and tools: Various recovery behaviors,\n    local and global planner plugins for move_base, a teleop filter for\n    obstacle avoidance, a simple control-based move_base replacement\n    etc."], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/rosbash_params", "package": "rosbash_params", "package_summary": ["Tools for writing ros-node-like bash scripts"], "package_details": ["This Bash env-hook adds a \"node-like\" interface to your code written in Bash. The main thing it adds is ROS-like command-line parameter parsing (", "), so that you can easily call the Bash script from a launch file like"]},
{"url": "https://wiki.ros.org/v4r_uvc", "package": "v4r_uvc", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rwt_robot_monitor", "package": "rwt_robot_monitor", "package_summary": ["The rwt_robot_monitor package"], "package_details": []},
{"url": "https://wiki.ros.org/nerian_sp1", "package": "nerian_sp1", "package_summary": [], "package_details": ["(", ")", "(", ", default:", ")", "The", "by Nerian Vision Technologies is a stand-alone processing system for performing stereo matching in real time. It is connected to two industrial USB cameras that provide input image data.  The SP1 correlates the images of both cameras and produces a disparity map, which is transmitted through gigabit ethernet. The disparity map describes a mapping of image points from the left camera image to corresponding image points in the right camera image. With this information it is possible to reconstruct the 3D location of the corresponding scene points.", "The data delivered by the SP1 can be received using the available open source API. Using the API directly is recommended for high performance applications. Alternatively the", "ROS node can be used for publishing the received data as ROS messages.", "The behaviour of the node can be configured through various parameters. An example parameterization can be found in the included launch file", ". The following parameters are supported:", "The topics published by the nerian_sp1 node can be viewed with", ". The disparity map can also be visualized with the", "node. In this case color coding should be activated such that the disparity map can be displayed on a screen. In order to do so, please launch the image_view node as follows:"]},
{"url": "https://wiki.ros.org/navigation_stage", "package": "navigation_stage", "package_summary": ["This package holds example launch files for running the ROS navigation stack in stage."], "package_details": ["This package holds example launch files for running the", "stack in", "."]},
{"url": "https://wiki.ros.org/khi_rs_gazebo", "package": "khi_rs_gazebo", "package_summary": ["The khi_rs_gazebo package"], "package_details": []},
{"url": "https://wiki.ros.org/khi_rs007n_moveit_config", "package": "khi_rs007n_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the khi_rs007n with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/urdf_sim_tutorial", "package": "urdf_sim_tutorial", "package_summary": ["The urdf_sim_tutorial package"], "package_details": []},
{"url": "https://wiki.ros.org/global_planner", "package": "global_planner", "package_summary": ["A path planner library and node."], "package_details": ["Path follows the grid boundaries.", "Slightly different calculation for the potential. Note that the original potential calculation from", "is a quadratic approximation. Of what, the maintainer of this package has no idea.", "Note that a lot less of the potential has been calculated (indicated by the colored areas). This is indeed faster than using Dijkstra's, but has the effect of not necessarily producing the same paths.  Another thing to note is that in this implementation of A*, the potentials are computed using 4-connected grid squares, while the path found by tracing the potential gradient from the goal back to the start uses the same grid in an 8-connected fashion.  Thus, the actual path found may not be fully optimal in an 8-connected sense.  (Also, no visited-state set is tracked while computing potentials, as in a more typical A* implementation, because such is unnecessary for 4-connected grids).  To see the differences between the behavior of Dijkstra's and the behavior of A*, consider the following example.", "For reproducing paths just like", "did.", "This package provides an implementation of a fast, interpolated global planner for navigation. This class adheres to the", "interface specified in the", "package. It was built as a more flexible replacement to", ", which in turn is based on", ".", "The orientation of point i is calculated using the positions of", "and `i +", "orientation_window_size`. The window size can be altered to smoothen the orientation calculation."]},
{"url": "https://wiki.ros.org/netft_utils", "package": "netft_utils", "package_summary": [], "package_details": ["This package builds on the original", "package by Derek King, written in 2008 but not updated since ROS groovy.", "(You may have to do this every time you open a new terminal window, or add this line to your bashrc:", ") Build the package", "The IP address should be the IP address of your sensor. You should see a steady stream of", "data.", "The following code covers the gist of how to declare and use a netft object with C++. Do", "to see it in action (you will have to adjust the IP address of the sensor in the source code, as it's hardcoded to 192.168.1.84.", "If the program Seg Faults immediately, you may have specified an incorrect IP address for the sensor. Follow this", "to see a list of IP addresses on your network and find the right one.", "If the network latency increases significantly after launching the F/T sensor, it is probably pushing too much data. You can reduce its data transmission rate through the Netbox's web interface. Simply navigate to the sensor's IP in a browser, e.g.:", "Reduce the data transmission rate downward via \"RDT Output Rate.\""]},
{"url": "https://wiki.ros.org/maggie_labjack_drivers", "package": "maggie_labjack_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_devices", "package": "maggie_devices", "package_summary": [], "package_details": ["ROS packages for the devices of the robot", "."]},
{"url": "https://wiki.ros.org/qb_hand_description", "package": "qb_hand_description", "package_summary": ["This package contains the ROS description for qbrobotics\u00ae qbhand device."], "package_details": ["This package contains the description resources for the", "and", "devices. It includes the", "/", "model of the hands with their simplified meshes and their configuration setup.", "This launch file calls the template", "with the default settings to visualize the desired qb", "Research in", "(and nothing more)."]},
{"url": "https://wiki.ros.org/micros_mars_task_alloc", "package": "micros_mars_task_alloc", "package_summary": [], "package_details": ["The main APIs are shown below. The parameter names present the parameter function clearly. As mentioned above, each motivational behavior is responsible for activating a forwarder to forward the messges sent from the attached behavior set. So the '", "' class should have a parameter named 'forwarder_name' indicating that which forwarder it activates. The paramters of the topics in 'Forwarder' indicate which behavior set they attach.", "The experimental videos can be downloaded and watched here."]},
{"url": "https://wiki.ros.org/twist_recovery", "package": "twist_recovery", "package_summary": ["A recovery behavior that performs a particular used-defined twist."], "package_details": []},
{"url": "https://wiki.ros.org/visualization_rwt", "package": "visualization_rwt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pepper_moveit_config", "package": "pepper_moveit_config", "package_summary": [], "package_details": ["Please, find the documentation on the github page", "."]},
{"url": "https://wiki.ros.org/ar_track_alvar_msgs", "package": "ar_track_alvar_msgs", "package_summary": ["This package is a ROS wrapper for Alvar, an open source AR tag tracking library."], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb2400_moveit_plugins", "package": "abb_irb2400_moveit_plugins", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/v4r_artoolkitplus", "package": "v4r_artoolkitplus", "package_summary": [], "package_details": ["This package uses the ARToolKitPlus to detect visual tags encoded with an id. Details to the tag detection can be found at", "There are a large number of ROS", "that can be set to customize the behavior of the", "wrapper. Most of these parameters can also be changed using", "but some of them must be set at start-up."]},
{"url": "https://wiki.ros.org/abb", "package": "abb", "package_summary": ["ROS-Industrial support for ABB manipulators (metapackage)."], "package_details": ["Use GitHub to", ". [", "]", "See the", "metapackage for additional packages.", "For more information on what is required to be able to use these packages with your ABB controller and manipulator, see the", "page.", "See the", "page for an overview of the available tutorials."]},
{"url": "https://wiki.ros.org/rqt_moveit", "package": "rqt_moveit", "package_summary": ["An rqt-based tool that assists monitoring tasks\n   for", "motion planner\n   developers and users. Currently the following items are monitored if they\n   are either running, existing or published:"], "package_details": ["Follow", "'s general installation guide", ".", "On", ",", "is available as binary pkg that comes within", "meta package.", "If you happened to find any problem, follow the usual steps (defined at", "), namely, Google search it,", "if you haven't found a solution/workaround, and possiblly open a issue report or enhancement request ticket on Issue/Bug tracker listed above."]},
{"url": "https://wiki.ros.org/rgbd_launch", "package": "rgbd_launch", "package_summary": ["Launch files to open an RGBD device and load all nodelets to \n     convert raw depth/RGB/IR streams to depth images, disparity images, \n     and (registered) point clouds."], "package_details": ["contains all the common launch files required by a driver specific launch package such as", "or", ". There are 2 important launch files:", "contains many internal launch files to split up processing. Only the following launch files should be used externally:", "contains some example configurations that you can run and test running nodelets in the system:", "This package contains launch files for using RGB-D devices such as the Microsoft Kinect in ROS. It creates a", "graph to transform raw data from the device driver into point clouds, disparity images, and other products suitable for processing and visualization."]},
{"url": "https://wiki.ros.org/tuw_multi_robot_rviz", "package": "tuw_multi_robot_rviz", "package_summary": ["Presents rviz plugins to set goal positions for the planner and a tool to visualize generated graphs."], "package_details": ["Figure: goal selector.", "Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/kvh_geo_fog_3d_msgs", "package": "kvh_geo_fog_3d_msgs", "package_summary": ["kvh_geo_fog_3d_msgs contains raw messages for the KVH GEO FOG 3D INS devices."], "package_details": []},
{"url": "https://wiki.ros.org/move_basic", "package": "move_basic", "package_summary": ["Simple navigation package"], "package_details": ["This package provides the", "ROS Node a very basic navigation node.", "The", "node performs basic navigation tasks. Path planning consists of rotating in place to face the goal and then driving straight towards it. It is designed to provide the same software interfaces as", ", that is, it implements a", "(similar to", ", see", "), that queues up to two goals containing", "messages.", "It is assumed that we are dealing with imperfect localization data:", "->", "is accurate but may be delayed and is at a slow rate and", "->", "is more frequent, but drifts, particularly after rotating. To counter these issues,", "plans in the", "frame, and waits a short time after each step, and executes movement in the", "frame. If goals in the", "frame are received, they are interpreted as relative to the robot's current position.  This behavior is different to that of", ", which will not accept goals in the", "frame.", "Some of the data produced by", "can be visualized with", ".  In the screen shot below, the portion of the laser scan data (in white) which is currently in the path of the robot is depicted as a red line.  The light purple line shows the path planned by the robot.   A navigation goal can be sent to", "by", "by pressing the", "button and clicking on the map.", "To move forward one meter using", "(note that", "completion will provide an empty message that can be filled out):", "This is an example of a relative goal, since the", "is set to", ". The position of the target pose is set to 1 meter in the forward direction, and the orientation is the identity quaternion."]},
{"url": "https://wiki.ros.org/laser_scan_publisher_tutorial", "package": "laser_scan_publisher_tutorial", "package_summary": ["The laser_scan_publisher_tutorial package"], "package_details": ["This package provides the code for the", "tutorial for the navigation stack."]},
{"url": "https://wiki.ros.org/abb_irb120_support", "package": "abb_irb120_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/arni_gui", "package": "arni_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ainstein_radar_drivers", "package": "ainstein_radar_drivers", "package_summary": ["ROS drivers (interfaces) and nodes for Ainstein radars."], "package_details": ["To configure the radar type prior to testing, use the provided", "script which depends on", ". Using eg.", "is also useful debugging tool to monitor CAN traffic on the SocketCAN interface.", "These CAN radars require a", "node publishing CAN frames to the", "ROS topic (see the launch file below for an example).  This package can be installed with:", "The file k79_node.cpp implements a ROS node using the", "interface class to create a UDP socket bound to the host IP address and port (which must match the radar's configuration), launch a thread to read and publish data to the", "message type.", "The python script", "can be used to configure the network parameters and flash new firmware. See the tutorials for more information.", "The easiest way to get started with any particular radar is to use the corresponding", "."]},
{"url": "https://wiki.ros.org/pioneer_bringup", "package": "pioneer_bringup", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "is used to communicate with Pioneer robots hardware:", "A ROS package providing roslaunch scripts for starting the Adept", "Pioneer and Pioneer-compatible robots (Including Pioneer 2, Pioneer 3, Pioneer LX,", ",", ",", ",", ", Seekur and Seekur Jr.)", "Please refer to the", "for more information.", "All the bringup modes call first", "package which is responsible to link ROS with the robot hardware.", "Sometimes however,", "need to communicate throught USB port, and then, you need to replace the followin line in the minimal.launch file:", "For more information about this modification, please refer to", ":"]},
{"url": "https://wiki.ros.org/maggie_serial_comm_drivers", "package": "maggie_serial_comm_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_drivers", "package": "maggie_drivers", "package_summary": [], "package_details": ["ROS packages for the devices of the robot", "."]},
{"url": "https://wiki.ros.org/qb_device_msgs", "package": "qb_device_msgs", "package_summary": ["This package contains the device-independent custom ROS messages for qbrobotics\u00ae devices."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"qb_device_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/qb_device_msgs/manifest.yaml", "Each", "device-independent custom ROS message is documented directly in its", "specification and it is designed to fit most of the users needs. Indeed we recommend to use these messages as they are whenever it is possible. However we understand that your application may require few specific additional information. Since it is difficult to provide one-size-fit-all messages, integrate your specification in a new coherent custom message, and feel free to propose your changes with a Pull Request in our repository if you think that it could be helpful for someone else."]},
{"url": "https://wiki.ros.org/moveit_tutorials", "package": "moveit_tutorials", "package_summary": ["The moveit_tutorials package"], "package_details": []},
{"url": "https://wiki.ros.org/network_interface", "package": "network_interface", "package_summary": ["Network interfaces and messages."], "package_details": []},
{"url": "https://wiki.ros.org/collision_distance_field_ros", "package": "collision_distance_field_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/move_base", "package": "move_base", "package_summary": ["The move_base package provides an implementation of an action (see the", "package) that, given a goal in the world, will attempt to reach it with a mobile base. The move_base node links together a global and local planner to accomplish its global navigation task. It supports any global planner adhering to the nav_core::BaseGlobalPlanner interface specified in the", "package and any local planner adhering to the nav_core::BaseLocalPlanner interface specified in the", "package. The move_base node also maintains two costmaps, one for the global planner, and one for a local planner (see the", "package) that are used to accomplish navigation tasks."], "package_details": ["(", ")", "(", ")", "This package provides the", "ROS Node which is a major component of the", ". A detailed description of this Node and its configuration options is found below.", "The", "node provides a ROS interface for configuring, running, and interacting with the", "on a robot. A high-level view of the move_base node and its interaction with other components is shown above. The blue vary based on the robot platform, the gray are optional but are provided for all systems, and the white nodes are required but also provided for all systems. For more information on configuration of the", "node, and the navigation stack as a whole, please see the", "tutorial.", "Running the", "node on a robot that is properly configured (please see", "for more details) results in a robot that will attempt to achieve a goal pose with its base to within a user-specified tolerance. In the absence of dynamic obstacles, the move_base node will eventually get within this tolerance of its goal or signal failure to the user. The", "node may optionally perform recovery behaviors when the robot perceives itself as stuck. By default, the", "node will take the following actions to attempt to clear out space:", "First, obstacles outside of a user-specified region will be cleared from the robot's map. Next, if possible, the robot will perform an in-place rotation to clear out space. If this too fails, the robot will more aggressively clear its map, removing all obstacles outside of the rectangular region in which it can rotate in place. This will be followed by another in-place rotation. If all this fails, the robot will consider its goal infeasible and notify the user that it has aborted. These recovery behaviors can be configured using the", "parameter, and disabled using the", "parameter.", "The", "node provides an implementation of the", "(see", "), that takes in goals containing", "messages. You can communicate with the", "node over ROS directly, but the recommended way to send goals to", "if you care about tracking their status is by using the", ". Please see", "for more information.", "The", "node contains components that have their own ROS APIs. These components may vary based on the values of the", ",", ", and", "respectively. Links to the APIs for the default components can be found below:", "Class Diagram (partially & not strictly drawn) is available", "."]},
{"url": "https://wiki.ros.org/kobuki_auto_docking", "package": "kobuki_auto_docking", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/abseil_cpp", "package": "abseil_cpp", "package_summary": ["The abseil_cpp package"], "package_details": []},
{"url": "https://wiki.ros.org/pepper_bringup", "package": "pepper_bringup", "package_summary": [], "package_details": ["You can start Pepper either with a", "or", "version. The pepper_bringup package thus contains two launch files.", "See the", "and", "for further details."]},
{"url": "https://wiki.ros.org/naoqi_dcm_driver", "package": "naoqi_dcm_driver", "package_summary": [], "package_details": ["*", "*", "*"]},
{"url": "https://wiki.ros.org/vrpn", "package": "vrpn", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rospeex_if", "package": "rospeex_if", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pdu_msgs", "package": "pdu_msgs", "package_summary": ["Control messages for the PDU"], "package_details": []},
{"url": "https://wiki.ros.org/qb_device_hardware_interface", "package": "qb_device_hardware_interface", "package_summary": ["This package contains a device-independent hardware interface for qbrobotics\u00ae devices."], "package_details": ["This package is barely usable alone since it provides only the common features to be exploited and expanded in the derived packages (cf.", "and", ")."]},
{"url": "https://wiki.ros.org/pioneer_mrs", "package": "pioneer_mrs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/vigir_generic_params", "package": "vigir_generic_params", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/rtt", "package": "rtt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_tilt_laser_interface", "package": "pr2_tilt_laser_interface", "package_summary": ["Provides a set of tools/actions for manipulating the pr2's tilting\n    laser. Simplifies previously complex tasks, such as fetching\n    a single sweep, given a set of desired parameters for both the laser\n    driver and tilting platform."], "package_details": []},
{"url": "https://wiki.ros.org/rotors_control", "package": "rotors_control", "package_summary": ["RotorS control package"], "package_details": []},
{"url": "https://wiki.ros.org/velo2cam_gazebo", "package": "velo2cam_gazebo", "package_summary": ["Metapackage allowing easy installation of velo2cam_gazebo components."], "package_details": [",", ", Arturo de la Escalera, Fernando Garc\u00eda", "Note: The models included in this repository were designed for evaluating the LIDAR-camera calibration algorithm described in [1] and [2], whose code is provided", ".", "Velodyne plugin providing", "with same structure as driver (x, y, z, intensity, ring) and simulated Gaussian noise. (Code from", ", although minor patch for vertical resolution issue is included)", "A previous version of this tool is available", "and was described on this", "."]},
{"url": "https://wiki.ros.org/asr_mild_base_fake_driving", "package": "asr_mild_base_fake_driving", "package_summary": ["The asr_mild_base_fake_driving package provides a simulation system for the robot driving. It simulates the desired driven way which is calculated by the navigation."], "package_details": ["Look at", "on how to start the simulated navigation with fake driving,. All simulation launch files use the fake driving.", "cmd_vel (", ")", "odom (", ")"]},
{"url": "https://wiki.ros.org/tuw_voronoi_graph", "package": "tuw_voronoi_graph", "package_summary": ["Contains different nodes to generate routing graphs for the robot router. voronoi_graph_generator generates a voronoi graph out of a map. dxf_to_graph generates a graph out of a dxf file and segments_to_graph creates a graph using a config file with line segments as input."], "package_details": ["(", ")", "(", ")", "(", ")", "(", "default: \"0.1\" [m])", "(", "default: \"0.9\")", "(", "default: \"0.2\")", "(", "default: \"0.4\")", "(", "default: \".\")", "(", "default: \"\")", "(", "default: \"false\")", "(", ")", "(", "default: \"segments.yaml\")", "(", "default: \"/segments\")", "(", "default: \"0.9\")", "Use GitHub to", ". [", "]", "This package includes the", ", which generates a voronoi graph out of a pixel map and the", ", which generates a graph out of segments.", "Receives a pixel map (occupancy_grid) and converts it into a", "message spanning the whole free space of the map. Additionally the graph is saved to a given folder. If a map is already converted to a graph the graph is loaded from memory to save computation time.", "This is a standard executable which takes a .dxf file as input and generates a graph which is saved to be loaded with the", ".", "Receives a pixel map (occupancy_grid) and converts it into a", "message spanning the whole free space of the map. Additionally the graph is saved to a given folder. If a map is already converted to a graph the graph is loaded from memory to save computation time."]},
{"url": "https://wiki.ros.org/mongodb_log", "package": "mongodb_log", "package_summary": ["The mongodb_log package"], "package_details": ["This package provides nodes that can record any and all data transmitted via ROS topics and stores them in the document-oriented database", "replicating the message type as document structure. Afterwards, data can be used and queried independently of a particular robot software framework using the existing MongoDB query features with indexes, data locality (sharding) and", ". This means you can also freely mix in data acquired from other sources, for example using", ".", "This project is joint work of the", "at The Robotics Institute of the Carnegie Mellon University and the", "at the RWTH Aachen University. For more details please visit the", ". Around 2014 it was taken within the STRANDS Project to log data from long-term autonomous robots.", "You can obtain mongodb_log either via the official ROS repositories (e.g.", ") or install via source. Source code is available with the", ". The original source for the project can be found in", ".", "The logger regularly creates graphs based an a round-robin database (RRD) using", ". Additionally, the", "script can be run to create graphs showing the performance of MongoDB. Example graphs look like the following.", "The", "package provides two functionalities. For one there is a node to store all messags of one specific topic to the database, for another it provides a library for other nodes to interact with the database. This mongodb_log package compares to the former part.", "The", "node of the", "package stores incoming messages as serialized blobs, much like rosbag does. This way, queries can only be made based on the time of the message. More powerful queries and usage of the data is only possible of a specific node has been created or modified to record data in more verbose documents.", "The upper graphs shows CPU and memory usage of rosbag, the generic mongodb_log python logger, and the specific C++ logger mongodb_log_tf, all recording the /tf topic at the same time, with transform messages containing 5 transforms at a rate of 100 Hz. We see that the MongoDB C++ logger and rosbag perform with about the same overhead. However, MongoDB is more efficient when writing, because rosbag writes the message type specification for each recorded message (note that MongoDB was writing two topics, one for the Python and the C++ logger each, while rosbag logged only one). The generic Python logger is much more demanding in terms of both, CPU and memory usage. The problem is the inherent Python overhead for deserializing message, which we had also analyzed when developing roslua (cf.", "). Hence, logging many unknown topics can put a considerable burden on your logging machine.", "The data acquired can be useful for a plethora of tasks. We have used it for fault analysis and performance evaluation, as described on the", "and in the", ". More information will be provided at a later point in time.", "If you want to get in touch please contact", ". Feel free to fork the", "and let us know about your changes. Please report issues on the", "."]},
{"url": "https://wiki.ros.org/hector_uav_msgs", "package": "hector_uav_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/arni_nodeinterface", "package": "arni_nodeinterface", "package_summary": [], "package_details": ["is used to gather the current temperature of the host, maybe.", "It can be found", "."]},
{"url": "https://wiki.ros.org/abb_experimental", "package": "abb_experimental", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This stack is part of the", "program. It contains experimental packages that will be moved to the", "package once they've received sufficient testing and review.", "Packages in distribution branches (ie:", ") may be expected to be compatible with the corresponding ROS distribution (ie: the", "branch is usable on Indigo). In the absence of major differences between subsequent ROS releases, the", "branch may be expected to be compatible with the next release as well (ie:", "may be used on Jade, as long as no", "branch exists).", "Refer to the", "for more information on building catkin workspaces.", "See the", "page for more information."]},
{"url": "https://wiki.ros.org/kuka_kr5_support", "package": "kuka_kr5_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_tuckarm", "package": "pr2_tuckarm", "package_summary": ["Tucks the arms of the PR2 robot into a safe position for moving the base of the robot.\n     This also moves the arms out of the view of the tilting laser scanner, as much as possible."], "package_details": ["As with all applications, you must first", ".", "The tuck arm application is a Python script,", ":", "The tuck arm application is a Python script,", ":"]},
{"url": "https://wiki.ros.org/ainstein_radar_gazebo_plugins", "package": "ainstein_radar_gazebo_plugins", "package_summary": ["Radar sensor plugins for the Gazebo simulator."], "package_details": ["This package is intended to contain a collection of simulated radar sensor plugins for different Ainstein products. All radar plugins are based on the existing laser", "with additional processing to convert laser range detections to radar targets and publish them as", "messages.", "While the", "shared library (plugin) is intended to be generic enough to simulate any Ainstein radar, it currently only is valid for 1d radars (a vertical scan dimension could be added and used to fill the elevation angle data), does not support target speed (this might be able to be computed numerically from successive scans) and the SNR is filled from the returned ray intensity (this has not really been tested and may be a bad idea).", "Once the package has been built (as normal in the catkin workspace), copy the folder(s) inside the", "directory to somewhere on your", ", eg.", "which can be added to your model path (if it isn't already) by adding this to your", ":", "Also, make sure that", "is on your", "as this is where the shared library will be built. To do this, add the following to your", ":", "To test that the sensor is able to be loaded correctly in Gazebo (before adding it to another model), use the provided test.launch file to attempt to start Gazebo with the radar sensor. If you see an error about not finding the .so file, check your", "."]},
{"url": "https://wiki.ros.org/qb_device_bringup", "package": "qb_device_bringup", "package_summary": ["This package contains a device-independent bringup utilities for qbrobotics\u00ae devices."], "package_details": ["This package is barely usable alone since it provides only templates to create more structured launch files in the derived packages (cf.", "and", ").", "This launch file calls the other templates", ",", "and", "to bringup a control node for a single device without starting", ",", "and", ".", "Since the only difference w.r.t. the", "launch file is the includes of the", "rather than the", ", the parameters are exactly the same as the other a part from", "which is not used.", "This launch file calls the other templates", ",", "and", "to bringup a complete control node for a single device.", "It provides basically the same configuration parameters as the other launch files a part from", "and", "of the", "which are not exported outside."]},
{"url": "https://wiki.ros.org/sicktoolbox_wrapper", "package": "sicktoolbox_wrapper", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/outlet_pose_estimation", "package": "outlet_pose_estimation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mpc_local_planner_msgs", "package": "mpc_local_planner_msgs", "package_summary": ["This package provides message types that are used by the package mpc_local_planner"], "package_details": []},
{"url": "https://wiki.ros.org/segbot_apps", "package": "segbot_apps", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/vapor_master", "package": "vapor_master", "package_summary": [], "package_details": ["Vapor_master is a drop in replacement for", "enabling high availability ROS service discovery. Vapor removes the single point of failure fundamental to ROS1 enabling new options for achieving greater scale, up-time and resiliency in ROS 1.x solutions.", "Vapor implements the", "as well as the", "utilizing a modern micro services approach. Unlike rosmaster, which does only supports an in-memory datastore, vapor persists data to a mongodb database. This enables instances of vapor to come and go without the need to stop all other ROS nodes left running on other computers.", "In assembly lines and mobile robots utilizing 3 or more computers, vapor_master can be deployed to all compute nodes. While mongodb can be deployed to a minimum of 3 nodes. In this scenario the ROS_MASTER_URI can be set to", "as if each node were its own rosmaster. In this way an given compute node can come and go as needed without preventing ros parameter access or service discovery."]},
{"url": "https://wiki.ros.org/actionlib", "package": "actionlib", "package_summary": ["The actionlib stack provides a standardized interface for\n    interfacing with preemptable tasks. Examples of this include moving\n    the base to a target location, performing a laser scan and returning\n    the resulting point cloud, detecting the handle of a door, etc."], "package_details": ["To accomplish tasks using actions, we introduce the notion of a goal that can be sent to an ActionServer by an ActionClient. In the case of moving the base, the goal would be a PoseStamped message that contains information about where the robot should move to in the world.  For controlling the tilting laser scanner, the goal would contain the scan parameters (min angle, max angle, speed, etc).", "Feedback provides server implementers a way to tell an ActionClient about the incremental progress of a goal. For moving the base, this might be the robot's current pose along the path.  For controlling the tilting laser scanner, this might be the time left until the scan completes.", "A result is sent from the ActionServer to the ActionClient upon completion of the goal. This is different than feedback, since it is sent exactly once.  This is extremely useful when the purpose of the action is to provide some sort of information.  For move base, the result isn't very important, but it might contain the final pose of the robot.  For controlling the tilting laser scanner, the result might contain a point cloud generated from the requested scan.", "Suppose you have defined", "in the", "package. The following snippet shows how to send a goal to a DoDishes ActionServer called \"do_dishes\".", "For the C++", ", the", "method will only work if a separate thread is servicing the client's callback queue. This requires passing in", "for the", "option of the client's constructor, running with a multi-threaded spinner, or using your own thread to service ROS callback queues.", "Suppose you have defined", "in the", "package. The following snippet shows how to write a DoDishes ActionServer called \"do_dishes\".", "Suppose you have defined", "in the", "package. The following snippet shows how to write a DoDishes ActionServer called \"do_dishes\".", "In any large ROS based system, there are cases when someone would like to send a request to a node to perform some task, and also receive a reply to the request. This can currently be achieved via ROS", ".", "In some cases, however, if the service takes a long time to execute, the user might want the ability to cancel the request during execution or get periodic feedback about how the request is progressing. The", "package provides tools to create servers that execute long-running goals that can be preempted. It also provides a client interface in order to send requests to the server.", "For a full discussion of how actionlib operates \"under the hood\", please see the", ".", "The", "and", "communicate via a", ", which is built on top of ROS messages.  The client and server then provide a simple API for users to request goals (on the client side) or to execute goals (on the server side) via function calls and callbacks.", "In order for the client and server to communicate, we need to define a few messages on which they communicate.  This is with an", ". This defines the Goal, Feedback, and Result messages with which clients and servers communicate:", "The action specification is defined using a", "file.  The", "file has the goal definition, followed by the result definition, followed by the feedback definition, with each section separated by 3 hyphens (", ").", "These files are placed in a package's", "directory, and look extremely similar to a service's", "file. An action specification for doing the dishes might look like the following:", "Based on this", "file, 6 messages need to be generated in order for the client and server to communicate. This generation can be automatically triggered during the make process:", "Add the following to your CMakeLists.txt file", ".", "Additionally, the", "of the package that includes", "files must include the following dependencies:", "Package that depends on actionlib API to implement an action server or use an action client needs another dependency on", ".", "For the", ", the following messages are generated by", ":", "These messages are then used internally by actionlib to communicate between the ActionClient and ActionServer.", "Full API Reference for the", "Full API reference for the", "Suppose the", "exists in the", "package.  The following snippet shows how to send a goal to a DoDishes ActionServer called \"do_dishes\" using Python.", "Full API Reference for the", "Full API Reference for the", "The", "implements a single goal policy on top of the", "class. The specification of the policy is as follows:", "Calling", "accepts a new goal when one is available. The status of", "this goal is set to active upon acceptance, and the status of any previously", "active goal is set to preempted. Preempts received for the new goal between", "checking if", "or invocation of a goal callback and the", "call will not trigger a preempt callback.  This means,", "should be called after accepting the goal even for", "callback-based implementations to make sure the new goal does not have a", "pending preempt request.", "Please refer to the", "page", "Please report any bugs on the", "by detailing your environment (OS, ROS Distro) and a minimal example how how to replicate the issue."]},
{"url": "https://wiki.ros.org/seed_smartactuator_sdk", "package": "seed_smartactuator_sdk", "package_summary": ["The seed_smartactuator_sdk package"], "package_details": []},
{"url": "https://wiki.ros.org/utilrb", "package": "utilrb", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/industrial_robot_status_controller", "package": "industrial_robot_status_controller", "package_summary": ["A ros_control controller that reports robot status using the ROS-Industrial RobotStatus message."], "package_details": ["Use GitHub to", ". [", "]", "This package provide a", "compatible controller that publishes robot/controller state (e-stopped, in motion, etc) as", "messages.", "See the documentation in the repository:", "."]},
{"url": "https://wiki.ros.org/arbotix_controllers", "package": "arbotix_controllers", "package_summary": ["Extends the arbotix_python package with a number of more sophisticated ROS wrappers for common devices."], "package_details": ["The arbotix_controllers package contains several controllers that add additional layers of ROS interface onto the basic structure of", "."]},
{"url": "https://wiki.ros.org/abb_irb1200_7_70_moveit_config", "package": "abb_irb1200_7_70_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/mir_navigation", "package": "mir_navigation", "package_summary": ["Launch and configuration files for move_base, localization etc. on the MiR robot."], "package_details": []},
{"url": "https://wiki.ros.org/ros_opcua_impl_python_opcua", "package": "ros_opcua_impl_python_opcua", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package provides communication interface between ROS and", "communication standard using", "library  written in Python. This package currently implements an OPC UA Server mapping all ROS Topics, Services and Actions under defined namespace in the OPC UA address space.", "Check the", "page."]},
{"url": "https://wiki.ros.org/area_division", "package": "area_division", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The following packages of the", "are required:", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/phantomx_reactor_arm_controller", "package": "phantomx_reactor_arm_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_ethercat_eml", "package": "ros_ethercat_eml", "package_summary": ["This is an implementation of the EtherCAT master protocol for use wiht ros_ethercar package based on the work done at Flanders' Mechatronics Technology Centre and Willow Garage."], "package_details": []},
{"url": "https://wiki.ros.org/qb_hand_hardware_interface", "package": "qb_hand_hardware_interface", "package_summary": ["This package contains the hardware interface for qbrobotics\u00ae qbhand device."], "package_details": ["This package is barely usable alone since it provides only the hardware interface for the", "device.", "This library inherits from the base device-independent", "(therefore provides the same ROS API) and extends its features specifically for the desired", ". In brief, it provides the specific transmission interface for the hand, which is the only thing that is really device dependent, and exploits the same hardware interfaces properly initialized (cf.", ") and the same Communication Handler to talk to the physical device (cf.", ")."]},
{"url": "https://wiki.ros.org/aruco_msgs", "package": "aruco_msgs", "package_summary": ["The aruco_msgs package"], "package_details": []},
{"url": "https://wiki.ros.org/rgbdslam", "package": "rgbdslam", "package_summary": [], "package_details": ["This page describes the RGB-D SLAM system for ROS Fuerte.", ",", "for", ". See", ".", "For the electric version and many details that still hold true, see", ".", "Download rgbdslam with the following command to your", ".", "If not yet installed, install", "first, then execute", "which will take a while. If you encounter problems, here is an example", "for a successful build for reference (Revision 3949).", "As mentioned in", ", if ROS dependencies are still not met for some reason, you might need to install the following dependencies", "There are several example launch-files that set the parameters of RGB-D SLAM for certain use cases, a complete list of all options and their current settings can be found in the GUI: \"Settings\"->\"View Current Settings\". For a definitive list of all settings and the default values have a look at their quite readable definition in src/parameter_server.cpp.", "If you want to use RGB-D SLAM with a Kinect or Xtion Pro, you should install", ". If you want to edit the saved point clouds you might want to install meshlab."]},
{"url": "https://wiki.ros.org/rosbag_storage", "package": "rosbag_storage", "package_summary": ["This is a set of tools for recording from and playing back ROS\n    message without relying on the ROS client library."], "package_details": []},
{"url": "https://wiki.ros.org/pr2_common_action_msgs", "package": "pr2_common_action_msgs", "package_summary": ["The pr2_common_action_msgs package"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"pr2_common_action_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/pr2_common_action_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/log4cpp", "package": "log4cpp", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/play_motion", "package": "play_motion", "package_summary": ["Plays a pre-recorded motion on a robot"], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb2600_support", "package": "abb_irb2600_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/khi_robot_bringup", "package": "khi_robot_bringup", "package_summary": ["Package contains bringup scripts/config/tools for KHI Robot"], "package_details": []},
{"url": "https://wiki.ros.org/segbot_sensors", "package": "segbot_sensors", "package_summary": [], "package_details": ["For UTexas BWI Segbot robots, an extension of the", "package. Contains special-purpose the sensor and sensor filters launch files.", "See the", "."]},
{"url": "https://wiki.ros.org/rovio_ctrl", "package": "rovio_ctrl", "package_summary": [], "package_details": ["The", "package contains nodes to control the movement of the Rovio. This includes control the movement of the base itself, as well as controlling the head (camera) position. Furthermore, joystick teleoperation is provided via the", "node.", "To install the", "stack, you can choose to either install from source, or from the Ubuntu package:", "The", "package contains a", "file which should be edited with the hostname, username and password to login to your Rovio. This file launches an instance of the", "and", "nodes. To launch these nodes, the following command can be used:", "The", "package also contains a", "file which should be edited with the hostname, username and password to login to your Rovio as well as absolute path to the", "folder within the", "package. This file launches an instance of the", ",", ",", "and", "nodes. To launch these nodes, the following command can be used:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/ros_opcua_communication", "package": "ros_opcua_communication", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This stack provides communication interface between ROS and", "communication standard. Currently there are two open-source OPC UA implementations supported", "(C++) and", "(Python).", "Clone your repository into", "folder of your ROS workspace using:", "Using", "clone of the repository OPC UA libraries will be automatically downloaded. After that compile your workspace."]},
{"url": "https://wiki.ros.org/khi_duaro_description", "package": "khi_duaro_description", "package_summary": ["The khi_duaro_description package"], "package_details": []},
{"url": "https://wiki.ros.org/motoman_robot_pkg_gen", "package": "motoman_robot_pkg_gen", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/segbot_description", "package": "segbot_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kinematics_exchanger", "package": "kinematics_exchanger", "package_summary": [], "package_details": ["(", ", default: 1)", "(", ", default:", ")", "The communication between CPSs is based on the", ".", "The following packages of the", "are required:", "to launch the", "node.", "In the", "subdirectory there is the parameter file", "that allows to configure the behavior of the", "node.", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/nao_interaction_msgs", "package": "nao_interaction_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asctec_hl_interface", "package": "asctec_hl_interface", "package_summary": [], "package_details": ["This package provides a ros interface to communicate with the High Level Processor (HLP) of the AscTec AutoPilot. Therefore, firmware for the HLP is needed which is provided in the", "package. It does not work with the firmware shipped with the HLP!", "Using a wired connection is recommended, e.g. to the Ascending Technologies", ". The cable supplied with the AtomBoard can be used. Connect to the serial port 0 of the Highlevel Processor (\"HL serial 0\") as shown in the AscTec", "in chapter 4.1. In this case, set", "to the correct port, and leave", "and", "empty.", "If you plan to use a wireless serial link, it might be useful to use a dedicated link for each rx and tx for higher bandwidth. In that case, set", "and", "accordingly and leave", "empty.", "The baudrate at which the", "communicates with the HLP can be set with the", "parameter. If it doesn't match a supported standard baudrate, the closest standard baudrate is chosen. The HLP tries to detect the baudrate automatically at startup or if there wasn't any communication with the hl_node for longer than ~10 seconds.", "sets up its serial port(s) with the desired baudrate and sends a packet ('a') which the HLP uses to detect the correct baudrate. In order for this to work, always switch on the HLP first, then start", ". In case you need to restart", "with a different baudrate, you have to wait ~10 s until the HLP accepts new baudrate configure packets. Restarting with the same baudrate works immediately. Tested baudrates are: 57600, 115200, 230400, 460800, 921600.", "Packet rates of certain packets can be configured with the", "parameters. No polling is done - instead a configuration packet is sent to the HLP which will send the packets in the desired rate accordingly. Note that no checking is done if the packet rates exceed the available bandwidth, so check the correct rate with", "In all operation modes, you can enable/disable control output to the LLP by setting the", "parameters accordingly. This is helpful, e.g. to debug a controller on a single axis first. Directions and orientations follow the", ". As with the direct interface to the LLP, it only accepts commands when the serial enable switch is on. In failure, flip off this switch and put the flightmode switch to \"acc\". There are three modes you can operate the helicopter which you can select with the", "parameter:", "Set", "to \"off\". This mode just forwards roll, pitch, yaw (angular velocity) and thrust commands to the LLP. This is similar to directly send commands to the LLP's serial interface. Set the values in", "in rad for roll and pitch, in rad/s for yaw and 0.0 ... 1.0 for thrust and set", "/type to \"acceleration\". For the scaling to work correctly, you need to set", "and", "to the values you can read out from the LLP with the AscTec control software (default 25, 120). Messages have to arrive at least at 10 Hz, otherwise nothing will be forwarded to the LLP.", "yaw rates are limited to +- 85% so that the motors cannot be switched on/off accidentally in case of bad commands (motors idle, full yaw).", "Set", "to \"GPS\" and set", "/type to \"velocity\" in your messages. Commands are also forwarded to the LLP, but the GPS bit is set additionally. The values in", "correnspond to velocities in boady coordinates in m/s and rad/s respectively. For the scaling to work correctly, you need to set", "according to the maximum \"stick-GPS\" velocites which you can read out from the LLP with the AscTec control software. Defaults are 5 m/s for x/y, and 2 m/s for z.", "Messages have to arrive at least at 10 Hz, otherwise nothing will be forwarded to the LLP.", "yaw rates are limited to +- 85% so that the motors cannot be switched on/off accidentally in case of bad commands (full descend rate, full yaw)", "This is the most interesting part and main motivation for this project. It is designed for position control based on position measurements from e.g. onboard visual SLAM with typically slow update rates. To deal with those delays, datafusion with IMU and position control is performed on the HLP at a rate of 1 kHz. Details on how the controller and datafusion work can be found in", ". To work with this mode, please go carefully through this", "."]},
{"url": "https://wiki.ros.org/kobuki_safety_controller", "package": "kobuki_safety_controller", "package_summary": [], "package_details": ["This controller is usually used together with the minimal configuration of Kobuki or with apps on top, e.g.", "and", "navigation.", "Use github to", "or", "."]},
{"url": "https://wiki.ros.org/kobuki", "package": "kobuki", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_motor_controller", "package": "maggie_motor_controller", "package_summary": [], "package_details": ["This device supports all the drivers implemented in the", "package."]},
{"url": "https://wiki.ros.org/pr2_plugs", "package": "pr2_plugs", "package_summary": [], "package_details": ["You need to install the 'pr2 plugs' stack of ROS (see", "). On Ubuntu, this means:", "Follow the", "tutorial."]},
{"url": "https://wiki.ros.org/screenrun", "package": "screenrun", "package_summary": [], "package_details": ["If", "is passed, byobu is used instead of screen.", "A screen session named", "is started and screen windows with the program", "name are created, where the commands are entered.", "Usually the", "parameter will come from a configuration or launch file.", "See this example as a reference:"]},
{"url": "https://wiki.ros.org/qb_device_control", "package": "qb_device_control", "package_summary": ["This package contains a device-independent control library for qbrobotics\u00ae devices."], "package_details": ["This package is barely usable alone since it provides only the common features to be exploited and expanded in the derived packages (cf.", "and", ")."]},
{"url": "https://wiki.ros.org/kuka_eki_hw_interface", "package": "kuka_eki_hw_interface", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page.", "This package has been tested with KR C4 controllers. See", "for more information on how to configure it and setup the robot controller."]},
{"url": "https://wiki.ros.org/rqt_bag_exporter", "package": "rqt_bag_exporter", "package_summary": ["Export data (images, numerics) from a bag file to create CSV and video files"], "package_details": ["Documentation is here:"]},
{"url": "https://wiki.ros.org/pr2_power_board", "package": "pr2_power_board", "package_summary": ["This provides a ROS node for the PR2 Power Board."], "package_details": ["controls with the PR2 power board.  The API below is for informational purposes only; it is not intended for use by anything other than", ", which is where you should look for power data.", "The", "runs on the PR2 and controls the PR2 power board. The node regulates the main fan speed of the PR2 based on battery and power board temperature."]},
{"url": "https://wiki.ros.org/rr_control_input_manager", "package": "rr_control_input_manager", "package_summary": ["Filter velocity commands by ensuring that message time stamps do not exceed given timeout thresholds."], "package_details": ["2) The second is to allow acceptance of both Twist and", "messages and checks that the time stamp is not expired, and if the message stamp is expired discard the message."]},
{"url": "https://wiki.ros.org/robot_setup_tf_tutorial", "package": "robot_setup_tf_tutorial", "package_summary": ["The robot_setup_tf_tutorial package"], "package_details": ["This package provides code for the", "tutorial for the navigation stack."]},
{"url": "https://wiki.ros.org/rr_rover_zero_driver", "package": "rr_rover_zero_driver", "package_summary": ["The rover_zero_driver package"], "package_details": ["The Rover Zero V1 uses the", "which communicates via USB."]},
{"url": "https://wiki.ros.org/kobuki_capabilities", "package": "kobuki_capabilities", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/checkerboard_pose_estimation", "package": "checkerboard_pose_estimation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_sia10d_support", "package": "motoman_sia10d_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sick_ldmrs_laser", "package": "sick_ldmrs_laser", "package_summary": ["A ROS driver for the SICK LD-MRS series of laser scanners."], "package_details": ["Use GitHub to", ". [", "]", "All documentation is on", "."]},
{"url": "https://wiki.ros.org/markov_decision_making", "package": "markov_decision_making", "package_summary": [], "package_details": ["MDM helps you map between the abstract representations of", ",", "and", "that are used in decision-theoretic frameworks, and the actual actuators and sensors of your robots. It also interprets your decision-making policies and lets you configure an appropriate run-time execution strategy. Note that", ". For that you can use ROS-independent toolboxes such as", ". But once you have a decision-theoretic policy, MDM helps you execute that policy on your robot.", "MDM has been used (and is being used) in several international research projects, including", ";", "; and", ".", "In the following sections, you can find a light technical description of MDM, and information on how to use the library for your own MDP-based applications. For a more in-depth look into MDM, you can also refer to", ".", "For an overview of the concepts underlying MDM, please see the page", ".", "You can find examples of how to implement each MDM layer in the", ".", "MDM is modular and meant to be flexible and easy to adapt to your own applications. You can find more information on various specialized use-cases of MDM in the page:", "Q:", "A: There are so many generalizations and variants of the MDP framework that it is virtually impossible to design a library that supports all of them out-of-the-box. Rather than trying to explicitly support all MDP variants, MDM gives you the building blocks that you can use (and adapt) to put together a decision-theoretic controller for your robot(s). The underlying motivation is much of the implementation work that goes into deploying a decision-theoretic control policy can be re-used across different robot applications, regardless of the particular MDP variant that you're using. However, if you adapt MDM to your own application, you're encouraged to contribute to the library with your own modifications, since that may help other users in the future. Feel free to contact us, in that case!", "Q:", "A: Without going into a discussion as to why regular discretizations aren't a particularly good idea, note that as long as your state space is discrete and finite, then your states can be indexed by a fixed-length string of logical values (i.e. in binary). In other words, as long as you have enough predicates, you can represent any (finite) discrete state space. The", "package is lightweight and designed to handle a very large number of predicates, if needed. If you really want a \"grid world\"-like representation of your state space, you can either write a generic", "predicate and instantiate it for each your cells, or use the pose_labeler package (included in topological_tools) together with a map of the environment in which each cell is uniquely colored.", "Q:", "A: Although the default MDM State and Action Layers implicitly describe discrete state and action spaces, you can potentially use the same node layout, and implement a State Layer that outputs real-valued scalars or vectors; a Control Layer that maps that into a real-valued action, and an Action Layer that just maps those into actuator controls. We don't have any plans at this time to extend MDM by ourselves to continuously-valued domains, but if you're interested in doing so, please feel free to contact us.", "Q:", "A: Yes, there is a (currently experimental) branch in the Git repository that already supports some of the most basic RL algorithms for MDPs (Q-learning, SARSA)."]},
{"url": "https://wiki.ros.org/kobuki_random_walker", "package": "kobuki_random_walker", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/navigation_tutorials", "package": "navigation_tutorials", "package_summary": ["Navigation related tutorials."], "package_details": []},
{"url": "https://wiki.ros.org/maggie_labjack", "package": "maggie_labjack", "package_summary": [], "package_details": ["This device supports all the drivers implemented in the", "package."]},
{"url": "https://wiki.ros.org/khi_rs007l_moveit_config", "package": "khi_rs007l_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the khi_rs007l with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/maggie_navigation_config", "package": "maggie_navigation_config", "package_summary": [], "package_details": ["This package holds a number of common configuration files for the", "and", "nodes meant to be run in an application that requires global navigation with a pre-specified static map. It also contains navigation specific sensor configurations. In particular, it holds parameter settings for the", ",", ", and", "components of the", "node that are shared between many different configurations of the", "stack run on the", "."]},
{"url": "https://wiki.ros.org/pdu", "package": "pdu", "package_summary": ["Interface for the New Eagle Multiplex Power Distribution Module (MPDM)\n    https://store.neweagle.net/product/multiplexed-power-distribution-module-mpdm/"], "package_details": []},
{"url": "https://wiki.ros.org/qb_move_description", "package": "qb_move_description", "package_summary": ["This package contains the ROS description for qbrobotics\u00ae qbmove device."], "package_details": ["This package contains the description resources for the", "device. It includes the", "/", "model of the cube with its simplified meshes and its configuration setup.", "This launch file calls the template", "with the default settings to visualize a", "in", "(and nothing more)."]},
{"url": "https://wiki.ros.org/pr2_plugs_actions", "package": "pr2_plugs_actions", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/qb_move_control", "package": "qb_move_control", "package_summary": ["This package contains the ROS control node for qbrobotics\u00ae qbmove device."], "package_details": ["This package contains the ROS control node and its structures to control the", "device. It exploits the features provided by the base device-independent control library (cf.", ") and the specific hardware interface (cf.", ").", "The two launch files start a ROS node for the", "respectively to control it through a GUI and through predefined configurable waypoints (stored in the", "). In both cases the controllers setup can be found in the", "; it is recommended not to change the default settings though.", "This launch file calls the template", "with the default settings to bringup a full control node for the", "based on GUI inputs. It also starts the Communication Handler and therefore it is recommended not to start other driver nodes while using this one (cf.", "to control several devices together).", "This launch file calls the template", "with the default settings to bringup a full control node for the", "based on waypoint inputs. It also starts the Communication Handler and therefore it is recommended not to start other driver nodes while using this one (cf.", "to control several devices together).", "This control library specifically designed for the", "extends the", "and exploits the", ", therefore it provides all the ROS resources and requires all the specifications of this two base packages."]},
{"url": "https://wiki.ros.org/mir_msgs", "package": "mir_msgs", "package_summary": ["Message definitions for the MiR robot"], "package_details": []},
{"url": "https://wiki.ros.org/argos3d_p100", "package": "argos3d_p100", "package_summary": [], "package_details": [".", "There is a new package (", ") that uses the new", "developed by Bluetechnix for interacting with their sensors.", "To get more information about the Time of Flight camera Argos3D P100 please visit Bluetechnix website:", "The", "' works with ROS versions groovy and hydro.  You can use catkin workspaces or the previous rosbuild to configure, compile and get ready ROS.", "ROS tutorial:", "Be sure your libboost library version is >= 1.49. Previous versions as 1.46 generate errors while compiling argos3d_p100-ros-pkg.", "In Ubuntu/linux copy the file from the driver folder to", "Clone from repository:", "to your src/ folder in your catkin workspace and compile it with:"]},
{"url": "https://wiki.ros.org/pr2_power_drivers", "package": "pr2_power_drivers", "package_summary": ["Power drivers for the PR2 robot."], "package_details": ["contains the drivers that control the PR2 power system.  You should look at", "for reading the power state of the robot.", "Report new issues on"]},
{"url": "https://wiki.ros.org/ainstein_radar_filters", "package": "ainstein_radar_filters", "package_summary": ["Filtering and data conversion utilities for radar data."], "package_details": []},
{"url": "https://wiki.ros.org/maggie_description", "package": "maggie_description", "package_summary": [], "package_details": ["This package will contain the description of the", "robot."]},
{"url": "https://wiki.ros.org/agvs_complete", "package": "agvs_complete", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ar_tools", "package": "ar_tools", "package_summary": [], "package_details": ["Please use this", "to report bugs or request new features."]},
{"url": "https://wiki.ros.org/asctec_mav_framework", "package": "asctec_mav_framework", "package_summary": [], "package_details": ["This stack contains drivers, tools, a nonlinear position controller and imu data fusion for", "MAVs equipped with the AutoPilot sensor board. In contrast to", "which communicate directly to the low level processor of the AutoPilot board (which has some", "), this framework is based on the user-programmable high level processor of the AutoPilot board. Features are:", "Update to be compatible with the 2012 HL SDK and LL Firmware. Currently available in the \"version2012\" branch (see installation instructions).", ", it will not work with the older versions.", "The state prediction part of a full EKF runs now on the HLP, which works together with", ". Not only the obvious states as attitude, position and velocity are estimated, but also IMU biases, (visual) scale of the position measurement (e.g. from", ") and pose/position-sensor (e.g. camera) to imu calibration. Also, a yaw measurement is not necessary anymore since this can be estimated by the EKF. More detailed information can be found here:"]},
{"url": "https://wiki.ros.org/psen_scan", "package": "psen_scan", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For a list of supported devices please refer to our", ".", "For getting started quickly please see the", ".", "We created a set of", "that walk you through integrating the Pilz safety laser scanner PSENscan into your existing application, or creating a completely new one. For example you can learn how to store your configurations permanently and how to start multiple scanners simultaneously.", "You need further information? Our international hotline staff will support you individually about our ROS packages at", "or visit us at", "."]},
{"url": "https://wiki.ros.org/rcll_refbox_peer", "package": "rcll_refbox_peer", "package_summary": [], "package_details": ["This package contains nodes providing a ROS-based interface to interact with the", "of the", "which is also used in the", ".", "Please refer to the", "package for the interface message types."]},
{"url": "https://wiki.ros.org/pr2_gazebo", "package": "pr2_gazebo", "package_summary": ["Launch scripts for simulating the PR2 in", ".\n    The simulation equivalent of pr2.launch is found here.\n    pr2_fingertip_pressure_contact_translator produces the same ROS topics as fingertip_pressure package for simulated PR2."], "package_details": ["Spawn a simulated PR2, assuming that an instance of Gazebo is already up.  This launch file is normally not used directly, but rather included in another launch file, as in", ".", "This file is meant to mirror the behavior", ", which is used to bringup a physical PR2, including default controllers.", "The launch files in", "are included by the higher-level launch files documented above.  The controller launch files themselves should be modified only be advanced users.", "The programs in", "are for developer testing only.", "Please see the", "guide for tips on how to debug issues with", "."]},
{"url": "https://wiki.ros.org/pepper_dcm_bringup", "package": "pepper_dcm_bringup", "package_summary": [], "package_details": ["To choose the controllers you want to load, modify pepper_control/launch/pepper_control_trajectory.launch. The list of implemented controllers, you can find in pepper_control/config/pepper_trajectory_control.yaml. You can start and stop the ros-controllers using the rqt plugin", "."]},
{"url": "https://wiki.ros.org/rospeex_webaudiomonitor", "package": "rospeex_webaudiomonitor", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pepper_gazebo_plugin", "package": "pepper_gazebo_plugin", "package_summary": [], "package_details": ["All documentation is written in the github page", "."]},
{"url": "https://wiki.ros.org/motoman_sia5d_support", "package": "motoman_sia5d_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/maggie_rfid_drivers", "package": "maggie_rfid_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/microstrain_3dmgx2_imu", "package": "microstrain_3dmgx2_imu", "package_summary": ["A driver for IMUs compatible the microstrain 3DM-GX2 and 3DM-GX3 protocol. Includes \n    a heavily modified standalone driver pulled from the player distribution, \n    and a ROS node."], "package_details": ["While a", "exists, it has not been reviewed and should be considered unstable.", "The 3DM-GX2 protocol can be found", "."]},
{"url": "https://wiki.ros.org/power_monitor", "package": "power_monitor", "package_summary": ["The power_monitor collects messages from the ocean_battery_server and\n     the pr2_power_board, and publishes a summary of their data in a\n     friendlier message format."], "package_details": ["takes data from", "and", "and republishes it in a more user-friendly message format.", "(", ")", "(", ")", "(", ", default: 0.1)", "The estimation method that", "uses is reconfigurable via", ". Two methods are currently available:"]},
{"url": "https://wiki.ros.org/rr_openrover_driver_msgs", "package": "rr_openrover_driver_msgs", "package_summary": ["The rr_openrover_driver_msgs package"], "package_details": ["This package contains the messages used to publish hardware data from the", "."]},
{"url": "https://wiki.ros.org/abb_irb120t_moveit_config", "package": "abb_irb120t_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/agvs_gazebo", "package": "agvs_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/khi_duaro_moveit_config", "package": "khi_duaro_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the khi_duaro with the MoveIt! Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/pr2_controller_configuration", "package": "pr2_controller_configuration", "package_summary": ["Configuration files for PR2 controllers."], "package_details": ["This package contains YAML files that are used to configure the default controllers and the calibration controllers on the pr2. The package also contains a", "file that configures, loads and starts the default controllers via", ". The default controllers are:", "These files are used in places such as", "to instantiate the default PR2 controllers.", "For", ", a clone of this package with separate configuration is in", "."]},
{"url": "https://wiki.ros.org/novatel_oem7_driver", "package": "novatel_oem7_driver", "package_summary": ["NovAtel Oem7 ROS Driver"], "package_details": ["NovAtel, part of Hexagon, is a global technology leader, pioneering end-to-end solutions for assured positioning for land, sea, and air. NovAtel designs, manufactures and sells high precision positioning technology developed for efficient and rapid integration. Its solutions are empowering intelligent positioning ecosystems in vital industries that depend on the ability to tackle the most complex challenges in the most demanding environments. Learn more at", ".", "NovAtel gives away a comprehensive and free ebook that gives an excellent overview of many key concepts related to precise positioning in their Introduction GNSS Handbook, available here:", "The documentation referenced here describes the installation, configuration and use of the novatel_oem7_driver for", "(henceforth \"the driver\").", "The driver is for Hexagon | NovAtel\u00ae OEM7\u00ae GNSS devices, or OEM7 devices running the SPAN GNSS+INS sensor fusion engine, such as the", ". It allows NovAtel OEM7 devices to communicate via the ROS framework in a simple, flexible, and comprehensive way.", "This document focuses on use of the prebuilt binary version of the NovAtel OEM7 ROS driver. For modifying and installing the ROS driver from source code, refer to the NovAtel GitHub ROS driver repository at", ".", "For full documentation on NovAtel OEM7 products and their interface, refer to:", "novatel_oem7_driver is the only ROS driver produced and supported by NovAtel Inc.", "Here are links to sub-pages to help with use of the", ".", "See", ".", "Known Issues are communicated via the", "section of the driver's", "repository, located here:", "Use the 'Watch' feature in", "if you would like to receive updates for the driver repository.", "The", "offers extensive documentation both online and in PDF form.", "Part of the great value in using NovAtel products and services is the availably of extremely qualified technical support, generally at no additional charge. To get support with the novatel_oem7_driver, please contact", ".", "New feature requests for the ROS driver may be registered and voted for in the", "section of the driver's", "repository, located here:"]},
{"url": "https://wiki.ros.org/nmea_comms", "package": "nmea_comms", "package_summary": ["The nmea_comms package provides helper nodes for transmitting and receiving\n    the NMEA sentences."], "package_details": ["This package provides nodes which enable bidirectional communication between socket (server) or serial devices and the", "message type. This may be useful for a number of scenarios, including if you:", "Finally, the combination of a", "connected directly to a", "can create a tee, where a device's serial data is directly available to ROS, but also served over a socket such that a remote machine may listen to it via netcat. This is particularly valuable if your device has a proprietary Windows-only GUI, which you'd like to be able to use while the device is part of a running ROS system. An example of this usage is", ", which you can launch like so:", "Once running, you should see the output of your serial NMEA device on the", "topic, as well as when running", "."]},
{"url": "https://wiki.ros.org/purepursuit_planner", "package": "purepursuit_planner", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrt_cmake_modules", "package": "mrt_cmake_modules", "package_summary": ["CMake Functions and Modules for automating CMake"], "package_details": ["Use GitHub to", ". [", "]", "Imagine you whould never have to write a", "file again. Never forget to install everything, no need to update it  whenever you add a file, not time lost for figuring out how to call and  use find_package for your dependencies, etc.", "For more information, please refer to the documentation"]},
{"url": "https://wiki.ros.org/artoolkit", "package": "artoolkit", "package_summary": [], "package_details": ["This is", "packaged for a local ROS installation. This package is primarily to make it easier to install", ". More information about", "can be found at their home page.", "In Ubuntu 11.04 and 11.10, you may encounter errors related to", ". A possible workaround is to patch the header files manually with:"]},
{"url": "https://wiki.ros.org/kinesis_manager", "package": "kinesis_manager", "package_summary": ["AWS Kinesis stream management library intended for use with the Kinesis Video Producer SDK"], "package_details": ["The kinesis_manager package is a library for interacting with Amazon Kinesis Video Streams. It is used by the", "package.", "The source code is released under an", "."]},
{"url": "https://wiki.ros.org/arni_countermeasure", "package": "arni_countermeasure", "package_summary": [], "package_details": ["The arni_countermeasure package provides the possibillity to define specific reactions when a ros environement is not behaving as defined with", ".", "Constraints are definitions of how", "need to behave for a certain amount of time to trigger", ".", "They can be set as parameters withing the namespace /arni/countermeasure/constraints.", "A statement has to start with only one entry. Multiple statements can be combined with", "and", ".", "Its possible to negate a statement with", ".", "Where expected_value can be", ",", ",", ",", "Additionally a", "can be set. Only reactions with an autonomy_level <= config/reaction_autonomy_level get executed."]},
{"url": "https://wiki.ros.org/kuka_kr150_support", "package": "kuka_kr150_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/segway_rmp", "package": "segway_rmp", "package_summary": [], "package_details": ["There are several variations of Segway RMP's available, but only a few have been tested, if you would like to test one of the platforms or if you need a platform/feature that is not currently supported,", ".", "*", "You could use", "to install this stack (and potentially others at the same time) that way.  Here is an example", "file:", "Once you have the stack in your ROS setup, you can build the", "stack, by running:", "There is an older version of this ROS stack that was based on the drivers from", ".  If you would like to use those packages instead you can checkout their tag in git:", "The ROS nodes that interface with the RMP200 ATV and RMP400 used to be based on the", "and", "drivers from", ".", "I would appreciate anyone reporting bugs or requesting features by emailing me at", "."]},
{"url": "https://wiki.ros.org/arni_msgs", "package": "arni_msgs", "package_summary": [], "package_details": ["This page describes the message and service types used by arni. This information might be out of date, for recent data look here:", "Contains an array of", "for a node, host , or connection.", "Represents a single entry of the master API"]},
{"url": "https://wiki.ros.org/ros_monitoring_msgs", "package": "ros_monitoring_msgs", "package_summary": ["Messages for publishing monitoring data about ROS systems"], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb1200_5_90_moveit_config", "package": "abb_irb1200_5_90_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/rosruby", "package": "rosruby", "package_summary": [], "package_details": ["Please refer to the", "package and read the", "page.", "For a more detailed reference, please consult the", "."]},
{"url": "https://wiki.ros.org/point_cloud_publisher_tutorial", "package": "point_cloud_publisher_tutorial", "package_summary": ["The point_cloud_publisher_tutorial package"], "package_details": ["This package provides code for the", "tutorial for the navigation stack."]},
{"url": "https://wiki.ros.org/livox_ros_driver", "package": "livox_ros_driver", "package_summary": [], "package_details": ["format:", "Email:", "ROS packages for Livox 3D LiDARs. This driver provides the measurement data as", "or Livox defined cloudpoint data."]},
{"url": "https://wiki.ros.org/arni_processing", "package": "arni_processing", "package_summary": [], "package_details": [": If a measured value returns an array (for example bandwidth_max for multiple network adapters) you can give an array of such limits. If you receive more values than you defined limits, spare values will be rated as", ". If you don't give an array of limits, the given limit will be used for each value.", "The monitoring node retrieves data on the topics", ",", "and", ". It then rates them according to specifications stored in the parameter namespace", ". The resulting data are published on the topic", ".", "For parameters shared across the arni packages see", ".", "The processing node rates the incoming statistics based on given specifications. They are read from the namespace", ". There you might give your desired specifications for a given seuid according to this format:", "You can pack these specifications as list items in one single list, which will then overwrite the whole list when you load several lists or add one more namespace block with the list like", ". The latter method allows you to selectively unset specification blocks.", "Learn more about the", ".", "Note that the measurement fields can be basically every field in the respective", ". See theses for comments on units.", "Additionally the field", "determines when the specified item is regarded as \"dead\" (see above).", "that this field expects a single number unlike the other fields!", "Usually the limits for a measurement are given as list with minimum and maximum value. If a third parameter is set as \"relative\", the limits will be calculated as", "etc.", "Connections use the built-in", "."]},
{"url": "https://wiki.ros.org/arni", "package": "arni", "package_summary": [], "package_details": ["Make sure you have the minimum required ROS Version for statistics. arni shell output and debug messages will tell you if there is any problem on the current host. On remote hosts you have to check their log as well.", "This may be due to many different problems. Make sure the host really sends data and that the values in the GUI are changing. If this is the case it might be that the remote host is sending data too seldomly. Currently we do not interpolate between two data points, which means, if the host sends data every ten seconds and the graph show only 10 seconds the graph will move out of range immediately.", "The solution is updating the time range, e.g. to 30 seconds.", "Advanced ROS Network Introspection (ARNI) extends the", "features introduced with Indigo and completes the collected data with measurements about the hosts and nodes participating in the network. These are gathered from an extra node that has to run on each host machine. All statistics or metadata can be compared against a set of reference values using the", ". The rated statistics allow to run optional", "when a deviation from the reference is detected, in order to remedy the fault or at least bring the system in a safe state.", "All data can be displayed and monitored through new", ".", "a) Publishing", "data for topics and connections.", "Publishing /statistics_host and /statistics_node data.", "Comparing actual values to a YAML specification (d) and publishing /statistics_rated.", "Automatically acting on rated data, given a YAML countermeasure file (f). g) ARNI rqt_gui to visualize current state of ROS network. h) rqt_gui Node Graph showing /statistics data.", "If you have any further questions / issues / ideas do not hesitate to either use", "or to", "the current maintainer directly.", "Get the latest version from our", "repository:", "The message types can be founde here:", "(Note: may be deprecated, see in source code for most recent information. The package arni_msgs contains all needed information).", "Several Tutorials have been written to ease the use of ARNI. They can be found here:", "If you ran into any other problems (and maybe also found a solution?) send us a mail or post it on", "!"]},
{"url": "https://wiki.ros.org/abb_irb7600_support", "package": "abb_irb7600_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/rqt_paramedit", "package": "rqt_paramedit", "package_summary": ["rqt_paramedit - a rqt plugin for editing parameters using qt_paramedit."], "package_details": ["Note: This package replaces groovy's", "in hydro."]},
{"url": "https://wiki.ros.org/rr_openrover_stack", "package": "rr_openrover_stack", "package_summary": ["Packages related to the operation of Rover Robotics rover hardware.  This includes a client\n    for interfacing with the hardware (rr_openrover_driver) and a tool for filtering time stamped\n    velocity commands (rr_control_input_manager)."], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb1600_6_12_moveit_config", "package": "abb_irb1600_6_12_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/abb_irb6650s_support", "package": "abb_irb6650s_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/abb_irb120_moveit_config", "package": "abb_irb120_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/abb_irb6700_support", "package": "abb_irb6700_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/abb_irb1200_support", "package": "abb_irb1200_support", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/rr_openrover_driver", "package": "rr_openrover_driver", "package_summary": ["Provides an interface between ros and Rover Robotics rover hardware. Inputs to rr_openrover_driver\n    include emergency stop and velocity commands.  It outputs diagnostic data such as encoder\n    readings and battery charge."], "package_details": ["This code is for those working with the Rover Robotics", ". The", "communicates via UART, this package abstracts away the UART communications and allows users to quickly get their robots moving around and doing cool things! We recommend using an FTDI cable which will convert the UART to USB for communicating with a computer."]},
{"url": "https://wiki.ros.org/abb_irb120_gazebo", "package": "abb_irb120_gazebo", "package_summary": [], "package_details": ["This package is part of the", "program.", "See the", "page."]},
{"url": "https://wiki.ros.org/kobuki_node", "package": "kobuki_node", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/simple_navigation_goals_tutorial", "package": "simple_navigation_goals_tutorial", "package_summary": ["The simple_navigation_goals_tutorial package"], "package_details": ["The code in this package does not match the current version of the tutorial.", "This package provides the code for the", "tutorial for the navigation stack."]},
{"url": "https://wiki.ros.org/abb_irb4600_support", "package": "abb_irb4600_support", "package_summary": [], "package_details": [": the Webots integration shown here is provided by Cyberbotics and does not use the models provided by the", "package. Please contact Cyberbotics for support and usage related questions of this simulation.", "This package is part of the", "program.", "See the", "page.", "A", "simulation model is available for the ABB IRB4600 arm with a", "."]},
{"url": "https://wiki.ros.org/asctec_hl_comm", "package": "asctec_hl_comm", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lanelet2_core", "package": "lanelet2_core", "package_summary": ["Lanelet2 core module"], "package_details": []},
{"url": "https://wiki.ros.org/remote_rosbag_record", "package": "remote_rosbag_record", "package_summary": ["The remote_rosbag_record package"], "package_details": []},
{"url": "https://wiki.ros.org/schunk_lwa4p_extended", "package": "schunk_lwa4p_extended", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot_upstart", "package": "robot_upstart", "package_summary": ["The robot_upstart package provides scripts which may be used to install\n    and uninstall Ubuntu Linux upstart jobs which launch groups of roslaunch files."], "package_details": ["Please see usage and docs here:"]},
{"url": "https://wiki.ros.org/robotino_description", "package": "robotino_description", "package_summary": [], "package_details": ["The", "package contains xacro files and meshes required to create a urdf model of Robotino. This urdf file is used by the", "package to broadcast transforms and also by", "for visualization.", "If the xacro files are modified, then the", "would have to updated as well. This can be done by running the following command from the", "directory."]},
{"url": "https://wiki.ros.org/manipulator_h_gui", "package": "manipulator_h_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/slam6d_exporter", "package": "slam6d_exporter", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For installation instructions, see", "."]},
{"url": "https://wiki.ros.org/ros_explorer", "package": "ros_explorer", "package_summary": [], "package_details": ["is a web-based utility for browsing the ROS graph.", "This will create a server that serves the website on", ".", "It should also open the webpage in your default web browser automatically (using the xdg-open command).", "If this does not work, you can just visit", "manually."]},
{"url": "https://wiki.ros.org/rocon_console", "package": "rocon_console", "package_summary": ["Command line python console utilities (mostly for colourisation)."], "package_details": []},
{"url": "https://wiki.ros.org/rh_p12_rn", "package": "rh_p12_rn", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_description", "package": "manipulator_h_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/report_card", "package": "report_card", "package_summary": [], "package_details": ["The", "is a CRAM package that extends", "system and", "environment with functionality of generating a PDF file that contains easy to read (e.g. pie charts, bar charts, tables) robot experiment statistics.", "Alternative version of this guide is available", ".", "This package is based on", "and its interpreter - the main log analysis and computations are done therein.", "Once the data is prepared part of it is passed to", "via", "interface where its processed and needed graphs are prepared.", "is also used to store statistics and dump them into CSV and RData formats for easy post-processing.", "Then, links to prepared figures and log statistics are passed via JPL to", "where they are prepared and injected into selected LaTeX templates with use of", ".", "Finally, the same library is used to generate a PDF based on prepared tex files. For details please refer to below figure.", "To make the package the most universal the report card generation is based on two key concepts", "and", ". This approach allows the user to choose the design of the report card and decide which sections should be placed within. Moreover, this design facilitates creating personalised section and including them in the report card without complex code alterations and rebuilding the whole package - see below.", "This templates specify overall design of the report card - please see", "for an example. The most important part of it are", "statements which include specified in", "sections. The default layout allows up to 10 sections.", "Section templates specify the structure of each section in the document - please see", "for an example. There are 4 different types of variables that can be used in each section:", "To add your custom section to the report card please create a file named", "in the", "directory. Use the arguments naming as described above - the order of the arguments is based on the order used in the", "call done within", ".", "To generate your section from within", "add a new predicate to", "file:", "Where", "is path to the temporary directory of current report card;", "is the section name (it MUST contain the exact name you gave to your section file without", "extension),", "and", "are as described above and of type", "and finally,", "and", "are as described above and of type", ". If you have no data of specific type to be passed to the section creator you should generate empty array for the first two types e.g.", "and empty array of arrays for latter two types e.g.", ".", "To alter current generator please append your section to", "predicate as follows:", "If you prefer to create custom report card generator first add type predicate to the already existing list:", "and then create custom loader for created type:", "To manually generate the report card (using", "shell) please use the following sequence:", "Before generating a report card remember to load the data e.g.", "!", "To perform statistical computations R is accessed via", "interface in Prolog. As a rough guide please see the example shown below.", "For details please refer to this", ".", "Any section contributions are welcomed, please make a pull request with you custom", "predicates,", "declarations,", "and all additional predicates extending", ".", "Please document all your code and wrap it between", "and", "."]},
{"url": "https://wiki.ros.org/rosmake", "package": "rosmake", "package_summary": ["rosmake is a ros dependency aware build tool which can be used to\n     build all dependencies in the correct order."], "package_details": ["is a tool to assist with building ROS", ".  It facilitates building packages that have dependencies.", "will determine", "'s dependencies (and the dependencies' dependencies, etc.), and will ensure that all dependencies are built prior to building", ".", "runs recursively on the dependencies of the given package(s), eventually running", "on a each one.  After all dependencies are built,", "will build the given package(s).  If no package is given, it will try to build the current directory, which must contain a", ".", "will skip packages with", "in the root of the package.", "will skip packages with a file", "in the root of the package if the option --skip-blacklist is enabled.", "ROS comprises a large number of packages.  However, with the exception of some core packages that everything else depends on, e.g.,", "and", ", many of the packages are largely independent.  As such, we have provided a", "to allow you to only build what is actually necessary to run the packages that you want to run.", "A package may depend on any number of other packages, requiring that those packages be built first.  These dependencies are specified in the package's", "file.  However, it would be inconvenient to make you go and look at the dependencies for your package, and then in turn look at the dependencies for those packages and so on.  Instead, we provide", "to do the ROS-wide build of everything you need for a given package.", "For example, to build the", "package, you can simply run:", "If rosmake fails, there is a good chance you are missing", "for one or more of the packages you are trying to install.", "NOTE: you can run", "from anywhere, as it uses", "to locate packages.", "If you really just want to build a package, and you know that its dependencies are up-to-date, you just type", "in that package's top-level directory.", "You", "run", "multiple times simultaneously on one machine, unless you are sure that the builds don't share any dependencies.  You may end up building the same package simultaneously, which can cause various problems.", "Options available in ROS Electric and earlier:", "There are two parallelization options within", ":", "You can modify the behavior of", "by placing files with special names in your directory tree. These file names and their associated behaviors are described below.", "If the options", "only packages which declare the detected OS in their manifest (as demonstrated below) will be built."]},
{"url": "https://wiki.ros.org/manipulator_h_manager", "package": "manipulator_h_manager", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/reemc_hardware_gazebo", "package": "reemc_hardware_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/raspi_temperature", "package": "raspi_temperature", "package_summary": [], "package_details": [": Bert Berrevoets", ": Bert Berrevoets", ": BSD", ":", ":", ": The raspi_temperature package sends out a temperature of the raspberry pi core.This package only works on a raspberryPI"]},
{"url": "https://wiki.ros.org/rocon_app_manager", "package": "rocon_app_manager", "package_summary": [], "package_details": ["(", ")", "(", ")", "These services are freely shared to any ros subsystem that wants to consume them via the", "advertise/pull mechanisms. The purpose is to provide introspection to the robot (i.e. the system that runs the app manager) to make a decision as to whether it wishes to assume control of the robot. Assuming control is managed by making a request to invite the robot.", "The list of arguments to use for standalone mode robot launcher.", "The list of arguments to use for concert mode robot launcher."]},
{"url": "https://wiki.ros.org/mm_core_msgs", "package": "mm_core_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotis_device", "package": "robotis_device", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/android_extras", "package": "android_extras", "package_summary": [], "package_details": ["For more general documentation on all things rosjava-android, refer to the", "and", "wiki pages."]},
{"url": "https://wiki.ros.org/schunk_lwa4d", "package": "schunk_lwa4d", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/soem_master", "package": "soem_master", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotis_controller", "package": "robotis_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosbuild", "package": "rosbuild", "package_summary": ["rosbuild contains scripts for managing the CMake-based build system for ROS."], "package_details": []},
{"url": "https://wiki.ros.org/roboteq_msgs", "package": "roboteq_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"roboteq_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/roboteq_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/mrpt_generic_sensor", "package": "mrpt_generic_sensor", "package_summary": ["ROS node for interfacing any sensor supported by mrpt-hwdrivers"], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_robot", "package": "mrp2_robot", "package_summary": ["MRP2 robot description and launch files"], "package_details": []},
{"url": "https://wiki.ros.org/jaco_description", "package": "jaco_description", "package_summary": [], "package_details": ["contains urdf and xacro files for the JACO arm.  It also includes a launch file for reading the robot model and setting up a", "and", "for visualization in tools such as rviz.", "To install the", "package, you can install from source with the following commands:", "The", "package includes a launch file that can be used to load the robot model and setup joint state and robot state publishing used to populate a tf tree and visualize the robot.  Once launched, the JACO model can be visualized in tools such as rviz.  It can be launched with the following command:", "The launch file also includes a parameter (", ") to launch a GUI which can control each joint to test the model's behavior, which can be launched as follows:"]},
{"url": "https://wiki.ros.org/roslib", "package": "roslib", "package_summary": ["Base dependencies and support libraries for ROS.\n    roslib contains many of the common data structures and tools that are shared across ROS client library implementations."], "package_details": ["is the base dependency of all ROS", "and tools. It contains common tools like the generators for", "and", "as well as common message definitions like", "and", ". It also contains the common path-bootstrapping code for ROS Python nodes and tools.", "contains command-line tools for message generation necessary for ROS", "authors. These tools are", ".", "roslib contains the definition of the", "and", "objects used in", "and other ROS C++ libraries. It also contains functions for querying the ROS package system. Please see the", "and the", "for more details.", "If you are a Python developer, you might be confused that there are both the", "and", "packages that support Python development in ROS. In fact, some of the functionality they provide is very similar.", "There is only one line of", "you need to know, which exists for bootstrapping reasons:", "Otherwise, the simple answer is", ". Unless you're more familiar with ROS Python development,", "should provide you with all the APIs you need to run a node, call services, access the Parameter Server, etc... roslib is primarily an internal library used by ROS core developers to write tools.", "Currently no new features are planned for", ". But as new, common functionality is added to the ROS platform, it will likely be supported by libraries here."]},
{"url": "https://wiki.ros.org/rosbash", "package": "rosbash", "package_summary": ["Assorted shell commands for using ros with bash."], "package_details": ["includes the following command line utilities:", "allows you to change directories using a package name, stack name, or special location.", "without argument will take you to", ".", "is the", "equivalent of", ".  It allows you to keep multiple locations in a directory-stack while still using ros package names.  You can then  use the number of any directory in your directory stack to jump back there.", "lists the directories in your directory stack.  This is for use with", ".", "allows you to view the contents of a package, stack, or location.", "allows you to easily edit files in a ROS package by typing the package name and the name of the file you want to edit:", "allows you to conveniently copy a file from a package.  Similar to", "you can specify any file in the package regardless of hierarchy.", "allows you to run an executable in an arbitrary package from anywhere without having to give its full path or", "/", "there first.", "enables tab-completion for its own tools and for a number of other ros utilities:", ",", ",", ",", ",", ",", ",", ",", ",", ".", "The", "package contains some useful bash functions and adds tab-completion to a large number of the basic ros utilities.", "The", "package includes limited support for", "and", "by way of sourcing the", "or", "files respectively. We currently do not provide documentation on these shells, though much of the functionality is similar to the bash shell extensions.", "you can add this statement to the", "directory to execute it automatically on login, such as", ".", "Sourcing a catkin workspace requires using", ":", "You can have this done automatically as soon as you", "to the workspace directory, by adding a further config file (e.g.", "):", "Additionally, the", "environment variable can be used to add additional special locations for use with", ".", "is a colon-separated list of", "pairs.", "For example, adding the following to your", "file:", "and end up in", ".", "The default editor for rosed is vim. To use a different editor, set the", "environment variable.  E.g., in your ~/.bashrc:", "You also can change the editor for one", "call on the fly:", "Will end up copying the file from", "It's also possible to pass a", "using the following syntax (replace the", "with an", "):", "For more information about remapping, see:", "Starting in", ", rosrun has a", "option which can be used to run a node in gdb or valgrind.", "For more example prefixes, see:", "There are a couple of generic completion rules that may be appropriate for other utilities.  Looking through the", "source may provide insights into replicating similar functionality for other nodes, however, the code is not yet nicely generalized or re-usable.  In a future release of ROS, we plan to incorporate a more generically re-usable tab-completion framework into rosbash and the other common shells used by ROS."]},
{"url": "https://wiki.ros.org/rl_env", "package": "rl_env", "package_summary": [], "package_details": ["Please take a look at the", "on how to install, compile, and use this package.", "Check out the code at:", "This package contains a variety of environments that can be used for reinforcement learning experiments. These can be used with new RL agents written to use the", "framework, or with existing agents from the", "package. The package contains the following environments:", "The environment can interact with an RL agent in two ways. It can use the ROS messages defined in", ", or another method can call the agent and environment methods directly, as done in the", "package.", "The rl_msgs package defines a set of ROS messages for the agent and  environment to communicate. These are similar to the messages used in  RL-Glue (", "), but simplified and defined in the ROS message format. The environment publishes three types of messages for the agent:", "Experiments can also be run by calling the agent and environment methods directly (as done in the", "package). Methods that all environments must implement are defined in the Environment interface in the", "package (", ").  Seeds can be retrieved from the environment with the getSeedings() method. An action is applied to the environment with a call to apply(action). The current state can be retrieved by calling sensation() and terminal() will indicate if the agent is in a terminal state or not."]},
{"url": "https://wiki.ros.org/smach_msgs", "package": "smach_msgs", "package_summary": ["this package contains a set of messages that are used by the introspection\n    interfaces for smach."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"smach_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/smach_msgs/manifest.yaml", "The smach messages are only used for communication between the introspection server and the", ", and are considered part of the", "."]},
{"url": "https://wiki.ros.org/rl_agent", "package": "rl_agent", "package_summary": [], "package_details": ["Please take a look at the", "on how to install, compile, and use this package.", "Check out the code at:", "This package includes a number of reinforcement learning agents that can be used for learning on robots, or learning with the environments in the accompanying", "package.", "In addition to these methods, the package contains a general model-based architecture that can be used with any combinations of planners and model learning algorithms. For example, the R-Max implementation is simply the general agent with an R-Max model and Value Iteration for planning and the TEXPLORE agent is the general agent with a random forest model (", ") and UCT (", ") for planning.", "Included in this package is a general model based agent that can use any model learning or planning method that match the interface defined by the", "file in the", "package.", "Any of these model learning methods can be combined with any of the planners. It is also easy to write new model learning and planning methods that match the interface defined in", "and use those as well. In addition, there are multiple ways of performing exploration:", "The RL agent can interact with the environment in two ways: it can use the ROS messages defined in the", "package, or another method can call the agent and environment methods directly, as done in the", "package.", "The rl_msgs package defines a set of ROS messages for the agent and  environment to communicate. These are similar to the messages used in  RL-Glue (", "), but simplified and defined in the ROS message format. The environment publishes three types of messages for the agent:", "Experiments can also be run by calling the agent methods directly (as done in the", "package).  The methods that all Agents must implement are defined in the Agent interface in the", "package (", "). Seeds can be given to the method by calling the seedExp method. The agent can be queried for an action after getting a new state and reward by calling next_action(reward, state).", "To run the basic Q-Learning (", ") agent, type the following:", "To run the basic Sarsa (", ") agent, type the following:", "To run the basic Dyna (", ") agent, type the following:", "To run the basic R-Max (", ") agent, type the following:", "To run the basic TEXPLORE or TEXPLORE-VANIR (", ") agent, type the following:", "TEXPLORE plans greedily with respect to the average of a number of decision tree models of the domain. By default, TEXPLORE uses nmodels = 5, C 4.5 discrete decision trees, and plans using the RTMBA real-time architecture (", ") with an action rate of 10 Hz.", "To run TEXPLORE with Variance and Novelty Rewards (TEXPLORE-VANIR) (", "), set the coefficients for the variance and novelty explorations:"]},
{"url": "https://wiki.ros.org/robot_self_filter", "package": "robot_self_filter", "package_summary": ["Filters the robot's body out of point clouds."], "package_details": ["NOTE: for indigo and above users, please take a look at newer repository at", "Note: this node will output an XYZ", "with no RGB information. If you need to filter an XYZRGB", ", look at", "from the", "stack.", "The", "package is a filter to remove or mark the points corresponding to robot links in sensor data. The filter is essentially a node wrapper around the", "."]},
{"url": "https://wiki.ros.org/smarthome_network_zeroconf", "package": "smarthome_network_zeroconf", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jaco_sdk", "package": "jaco_sdk", "package_summary": [], "package_details": ["The", "package contains Kinova's API for communicating with the JACO arm for both 32bit and 64bit systems.  The package will install the JACO libraries for use with the other packages in the", "metapackage.", "To install the", "package, you can install from source with the following commands:"]},
{"url": "https://wiki.ros.org/scratch4robots", "package": "scratch4robots", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotnik_sensors", "package": "robotnik_sensors", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rflex", "package": "rflex", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/abb_irb6640_support", "package": "abb_irb6640_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sensor_fusion_comm", "package": "sensor_fusion_comm", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_apps", "package": "rocon_apps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mm_eigen_msgs", "package": "mm_eigen_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_mild_kinematic_chain", "package": "asr_mild_kinematic_chain", "package_summary": ["This package provides information about the mild's kinematic chain and contains launch-files to publish the chain to a robot_state_publisher"], "package_details": ["The mild's kinematic chain is described in", "within this package. (See the", "for a detailed explanation of the urdf format)", "The kinematic chain consists of two major parts: The robot's environment (map) as well as the robot's base and the camera-system including PTU, Guppy-Cameras (and Kinect as an optional component). The fixed reference Frame is in the PTU and is called", ".", "The transformation publisher is usually not run directly from this package. Instead, use the launch files provided in", ".", "See", "for tutorials on how to set up the full kinematic chain."]},
{"url": "https://wiki.ros.org/mh5_anomaly_detector", "package": "mh5_anomaly_detector", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rmp_teleop", "package": "rmp_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_ivt_bridge", "package": "asr_ivt_bridge", "package_summary": ["This package is used to convert between ROS messages and IVT images"], "package_details": ["This package contains a library which is used to convert image data structures between ROS and", ".", "The structure of this library is based on the", "-package, for more information you can check out the documentation for that.", "Include", "and/or", "to your code, depending on what you want to convert (images or camera calibrations).", "To convert a", "to a", "e of the IVT-library call one of the following functions (notice that the", "-functions create a copy of the input messages while the other ones try to share the data if possible):", "The return-value is a", "-object, which contains a", "member called image.", "To convert such an", "back to ROS call one of the following member functions:", "To convert a ROS", "to an IVT", "instantiate either an", "or an", "object (depends on your camera system: mono or stereo). Then call one of the provided member functions with the ROS-CameraInfo-message you want to convert (for a stereo system you have to provide messages of both cameras of course):"]},
{"url": "https://wiki.ros.org/mrp2_display", "package": "mrp2_display", "package_summary": ["Package for managing touch LCD panel on MRP2"], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_base_module", "package": "manipulator_h_base_module", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot_calibration", "package": "robot_calibration", "package_summary": ["Calibrate a Robot"], "package_details": []},
{"url": "https://wiki.ros.org/rocon_interaction_msgs", "package": "rocon_interaction_msgs", "package_summary": ["Messages used by rocon interactions."], "package_details": []},
{"url": "https://wiki.ros.org/mm_radio", "package": "mm_radio", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nmea_gps_driver", "package": "nmea_gps_driver", "package_summary": [], "package_details": [".", "Use GitHub to", ". [", "]", "This package provides a ROS interface for GPS devices that output compatible NMEA sentences. See the", "for details on the raw format. Of the thousands of NMEA-compatible GPS devices, we are compiling a list of", ".", "This package is compatible with the", "project as well as any other nodes that support", "and/or", ".", "Due to the dependency on", ", this package is only compatible with", "or newer.", "To get up and running quickly, you can use the following command to start outputting your GPS data onto ROS topics. This assumes your GPS is outputting GGA NMEA sentences, is connected to", "and is communicating at 38400 baud."]},
{"url": "https://wiki.ros.org/rl_msgs", "package": "rl_msgs", "package_summary": [], "package_details": ["This package defines a standard way for agents and environments to communicate through ROS messages. In ROS computation is done by nodes that perform different tasks that communicate through a set of ROS messages. ROS provides the framework to publish, subscribe to and receive these messages, in addition to tools for logging, displaying, plotting, and playing back ROS messages. This package defines a set of ROS messages for a reinforcement learning agent and environment to communicate. These messages are similar to the messages used by RL-Glue (", "), but are simplified and defined in the ROS format.", "Please take a look at the", "on how to install, compile, and use this package", "Check out the code at:", "Agents from the", "package can communicate with environments from the", "package through this interface. In addition, you can write your own agents and environments that will work with the ones in those packages by passing the same messages defined here.", "The  framework is being designed to be as flexible as possible. While our  algorithms and environments will mostly follow a certain style, we understand that every robot and  every experiment differs. Our hope is to not force our philosophy onto  other people, as long as you adhere to", "you can design and implement your algorithms and environments in your own style."]},
{"url": "https://wiki.ros.org/langs-dev", "package": "langs-dev", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rviz_imu_plugin", "package": "rviz_imu_plugin", "package_summary": ["RVIZ plugin for IMU visualization"], "package_details": ["Use GitHub to", ". [", "]", "The", "package is used to display", "messages in", ". Once you download and compile the package, it should be visible as a plugin.", "The package has been", "for inclusion in ROS."]},
{"url": "https://wiki.ros.org/shm_transport", "package": "shm_transport", "package_summary": [], "package_details": ["A shm_transport::Topic object is an encapsulation of ros::", ".", "Note that shm_transport::Topic::advertise() has one more parameter comparing to ros::", "::advertise(). This parameter (3 * MSGLEN in the example) indicates the total size of shared memory segment. The total size of shared memory segment should be larger than two messages plus the space used by memory allocation algorithm."]},
{"url": "https://wiki.ros.org/retalis", "package": "retalis", "package_summary": [], "package_details": ["Messages received by retalis from the subscribed topics are automatically converted to events. For example, the following message of type", "Events are time-stamped according to header times of ros messages. If a message does not have a header, it is time stamped with", ".  The format of time-stampes are", "where", "encodes nanoseconds since seconds (i.e. stamp.nsec in ros messages). For example, the above", "message contains a list of", "messages (only one here). While each", "message is time-stamped, the", "itself does not have a header. Therefore, the corresponding event is stamped with the current time.", "The following rule calls  the", "function for every", "event received by retalis.", "Each", "message from", "contains a list of recognized objects, each represented by a", "message. The following rule generates a separate event for each object.", "where", "represents a recognized object and", "encodes the time of recognition. This time corresponds to the time of taking the picture at which the object was recognized. This time is taken from the header file of the corresponding", "message. The events is also time stamped with", ".", "Retalis integrates the '", ".", "supports temporal and logical reasoning on flow of events. Please see", "for publications and for examples of rules implementing various event-processing functionalities.", "This memory instance keeps the history of events of the form", ", specified by the first argument. The second argument specifies a list of conditions, being empty here. A memory instance only records events that satisfy the conditions. The third argument specifies the format for recording events. The fourth argument is the Id of the memory instance. The last argument is the size. Only the last 2500 events of the given form are maintained by this memory instance.", "The", "event from Section 4.1.3 matches this memory instance. This events is recorded by this memory instance as", ".", "We saw in Section 4.1.3 that the", "and", "functions are implemented as Prolog clauses. The", "file can include an arbitrary Prolog program to encode a domain knowledge. We also saw in Section 4.1.4  that how memory instances are used to maintain histories of events", "The Prolog program in", "together with the the dynamic knowledge maintained by memory instances represent a Prolog-based knowledge base. This knowlede base can be queries by event-processing rules, for instance, as in Section 4.1.3. It can be also queried directly by a ros service (in our", "list).", "An example of using", "and", "terms is in implementation of the", "function, in the eventRules.txt. The input values to this function is the", "of a memory instance, keeping the history of some", "events, and a time point. The", "events represent observations of the transformation between two coordinate frames over time. From these observations, this function interpolates the transformation between the frames at time", ". This is implemented as follows. The last observation before", "and the first observation after", "are found using the", "and", "terms. Then the position is linearly interpolated by making a function call to the", "library that has been integrated with retalis.", "The", "function in eventRules.txt uses the", "function to position an object in the world reference frame. Given", ", the position of an object relative to the camera at time", ", this function computes", ", the position in the world, as follows. First, it changes the time format from ros time to datime. Then, it interpolates the transformation between", ",", ",", ",", "and", "at the time", ". Third, it applies these transformations on the", "by making a function call to the", "library. It is assumed that the", "frame is aligned with the world reference frame.", "We saw in Section 4.1.6 that how calling", "function interpolates the position between the", "and", "coordination frames at time", ". This function uses", "and", "terms to access the first and the last observations after and before", ", respectively. To interpolate the position at", ", the position should have been observed, at least once, after", ". The observations,", "messages here, are received asynchronously. Therefore, the", "function should be evaluated only after the", "memory instance has been updated with an event occurring after", ". This is realized in retalis using a synchronized event, as follows.", "The", "function, performs the", ", when the", "are satisfied and then generate the", ". Consider the following clause from eventRules.txt:", "This rule computes the position of recognized markers in the world and is read as follows.   For each", "event, specified in line 6, the position is computed by calling the", "function, as in line 3. After computing the position, an event of the following form is generated, specified in line 2:", "Such a", "event encodes the marker's name, its position in the world and the time of recogntion. The", "are the followings, specified in line 4:", "These conditions specify that the", "function should be evaluated, only after all", ",", ",", ",", "and", "memory instances have been updated, at least once, with events occurring after time", ". The time", "is the time of recognition of the marker.", "Retalis performs the synchronization of events in an event-driven and efficient way. The generation of a synchronized", "is posponed, until the", "are satisfied. Postponing an event does not postpone the generation of other events and postponed events are generated as soon as necessary conditions are met.", "The subscription subscribes the topic", "to the", "events in which", "is", ". Such events are generated by the synchronized rule, presented in Section 4.1.7. They contain the position of the marker", "in the world coordination frame.  The id of the subscription is", "which can be used to cancel the subscrition at any time.", "The following figure shows the CPU time used by the retalis and retalis-ros-converter nodes when running the NAO example. The retalis node calculates the position of objects in real-time. It processes about 1900 events, memorizes 130 new events and prunes 130 outdated events per second.  It also queries memory instances, 70 times per second. These tasks are performed using about 18 percent of the CPU time. In this experience, the retalis node has been directly subscribed to the", "and", "ros topics. The retalis-ros-converter only subscribes retalis to the", "topic and converts and publishes events about objects' positions to ros topics. To have this setup, comments out the subscriptions to", "and", "topics in the pub-sub.xml file and instead, set the", "boolean variable in the retalis_interface.cpp file to", ". You should also recompile the package.", "As we saw in Section 4.1.2, retalis provides an easy way to subscribe to ros topics and automatically convert ros messages to events. This is implemented by the retalis-ros-converter node. The implementation is in Python and is realized by inspecting classes and objects at runtime and therefore is expensive. The following figure shows the CPU time used by the retalis and retalis-ros-converter nodes for the NAO example, when the retalis-ros-converter is used to subscribe to", "and", "topics. This results show that while the automatic conversion among messages and events are desirable in a prototyping phase, the final application should implement it in C++ for performance reasons. We will investigate the possibility to re-implement the retalis-ros-converter node in C++.", "The following figure shows the CPU time for a number of runs where up to 160 memory instances are added to the NAO example. These memory instances record", "events. Among the events processed by retalis, there are no such events. The results show that the increase in CPU time is negligible. This shows that a memory instance consumes CPU time only if the input stream of events contains events whose type matches the type of events the memory instance records.", "In the following figure, the green and blue lines show the CPU time for cases where 20 memory instances of type", "are added to the NAO example. These memory instances match all", "events, about 1900 of such is processed every second. The size of memory instances for the green line is 2500. These memory instances reach their size limit in two seconds. After this time, the CPU time usage is constant over time and includes the costs of unification, assertion and retraction for updating 20 memory instances with 1900 events per second. The size of memory instances for the blue line is 150,000. It takes about 80 seconds for this memory instances to reach their size limit. Consequently, the CPU time before the time 80 only includes the costs of unification and assertion, but not the costs of retraction. After the time 100, the CPU usages of both runs are equal. This shows that the cost of a memory instance does not depend on its size. The purple line shows the CPU time for the case where similarely there are 20 memory instances of type", ". However, these memory instances record events until their reach their size limit. We added a condition for these memory instances such that after reaching their size limit, they perform no operation when receiving new events. After the time 100, the CPU time is constant about 23 percent, being 5 percent more than the CPU time of the NAO example, represented by the red line. This 5 percent increase represents the unification cost. This also shows that the costs of about 38000 assertions and 38000 retractions per second is about 30 percent of CPU time. In other words, 2500 memory updates (i.e. assertions or retractions) are processed using one percent of CPU time.", "The following figure shows the CPU time for a number of runs where up to 40 memory instances of type", "and size 2500 are added to the NAO example.  The red line at the bottom shows the CPU time for the NAO example. We make the following observations. Adding first 10 memory instances to the NAO example increases the CPU time about 20 percent. After that, adding each set of 10 memory instances increases the CPU time about 13 percents. This shows that the cost grows less than linearly. The implementation of memory instances is in a way that the cost of an assertion or a retraction can be assumed constant. This means that the unification cost for the first set of memory instances is the highest. In other words, the unification cost per memory instance decreases when the number of memory instances are increased.", "The following figure shows the CPU time for a number of runs where up to 640 memory instances of type", "and size 2500 are added to the NAO example. The events matching these memory instances are received with the frequency of 50 Hz. We make the following observaitons. First, it takes 50 seconds for these memory instances to reach their size limit. After 50 seconds, these memory instances reach their maximum CPU usages, as the costs of retraction is added. Second, each memory instance filters 1900 events per second recording about two percents of them. The cost of 640 memory instances is about 35 percent of CPU time. Third, the unification cost per memory instance is decreased when the number of memory instances are increased.", "The following figure compares the costs of different types of memory instances. The purple line shows the CPU time for the case where there are 10 memory instances of type", ". The green line shows the CPU time for the case where there are 320 memory instances of type", ". We observe that the costs of both cases are equal. The memory instances in the former case record 19,000 events per second (i.e. 10*1900). The memory instances in the latter case filter 1900 events per seconds for", "events, recording 16000 events per second (i.e. 320*50). The results show the efficiency of the filtering mechanism.", "The brown line shows the CPU time for the case where there are 10 memory instances of type", "and 320 memory instances of type", ".", "Comparing it with the green and purple lines shows that the CPU time usage of these memory instances is less than sum of the CPU usages by 10", "memory instances and 320", "memory instances. This shows that the  unification cost per memory instance is decreased when the number of memory instances are increased, even when the memory instances are not of the same type.", "The green line in the following figure shows the CPU time of the NAO example adapted as follows. There is an additional", "memory instance of size 128. This memory instance is queried by 1000", "terms for each recognition of an object. In average, 7000", "terms are evaluated per second. The blue line visualize the CPU time of a similar program in which 7000", "terms are evaluated per seconds. The figure shows that the costs of the evaluations of", "and", "terms are similar. The purple line shows the CPU time of the case where 14,000", "terms are evaluated per second. We observe that the cost grows linearly, as expected.", "The blue line in the following figure visualizes the CPU time of the case where 7000", "terms are evaluated per second. The green line visualizes the CPU time of the case where there are 320", "memory instances. The purple line visualizes the CPU time of the case where 7000", "terms are evaluated per second and there are 320", "memory instances. We observe that the cost of accessing a memory instance does not depend on existance of other memory instances.", "The green line in the following figure visualizes the CPU time of evaluating 7000", "terms per second on a memory instance of size 128. The blue linevisualizes the CPU time of evaluating 7000", "terms per second on a memory instance of size 16384. The size of the memory instance in the latter case is the power of two of the size of the memory instance in the former case. The increase in the CPU time for the latter case, with respect to the NAO example, is less than two times of the increase in the CPU time for the former case.", "The red line in the following figure visualized the CPU time of the NAO example where in each second, 1000", "queries on a memory instance of size 2500 are evaluated. In addition, for each", "query, a new event is generated. The green line visualizes the CPU time of a similar case where the next queries are synchronized. This experiment is conducted in a way that no query needs to be delayed. Coparing these two cases shows that when queries are not delayed, the synchronization cost is negligible.", "Information flow processing systems such as Etalis are designed for applications that require a real-time processing of a large volume of data flow. Please see", "for the evaluation of the performance of on-flow functionalities. The evaluation results show, in terms of performance, Etalis is competitive with respect to the state-of-the-art on-flow processing systems."]},
{"url": "https://wiki.ros.org/raspigibbon_description", "package": "raspigibbon_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_bringup", "package": "manipulator_h_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rviz_animated_view_controller", "package": "rviz_animated_view_controller", "package_summary": ["A rviz view controller featuring smooth transitions."], "package_details": ["This package provides an RViz view controller plugin that allows users to control the RViz camera by publishing", "messages (from the", "package) to the", "topic.", "This package has been released into Hydro and Indigo. Installation through", "is easiest in most cases:", "See the", ",", "and", "scripts in the", "package for examples of how to use the functionality provided by this package."]},
{"url": "https://wiki.ros.org/asr_calibration_tool_dome", "package": "asr_calibration_tool_dome", "package_summary": ["This package provides a tool for calibraiting the kinematic chain of the PdB-Dome. It provides a data-tracking for recording 6D positions of Flock of Birds data glove and a checkerboard mounted on it. With this construction, the kinematic chain is closed. The recorded data is written to a file and can be used for the asr_kinematic_chain_optimizer."], "package_details": ["The idea of this calibration process is to close the kinematic chain, track several hundred datasets, describe a default TF-configuration and minimize the distances. In addition, the PTU pan- and tilt-angle are also tracked. Dataset are the tracked training data. Each value is a configuration of a non-fix joint. A whole dataset (one row) contains all variables of a kinematic chain (See", "for further information). A sample Dataset is shown in the following picture:", "1. Define a kinematic chain as best as you could, or use the old kinematic chain. The format is shown in", "package. Define also a goal function (e. g. Position of Frame1 and Frame2 should be equal. (See", "for further information). Make sure that all non-fixed Frames are parameterized (like PTU).", "2. Construct something, so the kinematic chain is closed. In this case a tracker of the", "system is attached on a checkerboard detector. Define a transformation between the two tracked frames like you did in 1.", "4. Run the", "with you frames and datasets as inputfiles."]},
{"url": "https://wiki.ros.org/ar_kinect", "package": "ar_kinect", "package_summary": [], "package_details": ["has a single node that can be run, which takes RGB point clouds from the Kinect and outputs a transform between the camera and a recognized marker. This is based on the", "node from the", "package.", "This package is an ROS wrapper for", ", which improves marker localization using point cloud data from a Kinect."]},
{"url": "https://wiki.ros.org/smacha", "package": "smacha", "package_summary": [], "package_details": ["(short for \"State Machine Assembler\", pronounced \"smasha\") aims at distilling the task-level simplicity of", "into compact YAML-based scripts in the foreground, while retaining all of its power and flexibility in Jinja2-based templates and a custom code generation engine in the background.", "Use GitHub to", ". [", "]", "The", "provides an overview of the functionalities and core concepts of SMACHA."]},
{"url": "https://wiki.ros.org/launchman", "package": "launchman", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/slam_exporter", "package": "slam_exporter", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosruby_tutorials", "package": "rosruby_tutorials", "package_summary": [], "package_details": ["This package contains some samples for tutorials. Please refer to", "for more detials."]},
{"url": "https://wiki.ros.org/drc_com_common", "package": "drc_com_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/simple_drive", "package": "simple_drive", "package_summary": [], "package_details": ["If your microcontroller supports subscribing to ROS", "messages (Arduinos can use", ") then it would be simpler to do that and skip this node. However, this node is written in python so you could more easily add complex functionality in python and then in your microcontroller do the minimum amount of work necessary.", "Caution! This software does not stop moving the robot if no messages are received for certain period of time. A pull request for this is very welcome.", "We like PlatformIO: \"Single source code. Multiple platforms.\" PlatformIO supports approximately 200", "and all major", ". Learn more on", ".", "- Differential drive software with support for a velocity PID target, a small GUI to control the robot, and more.", "- Differential drive software that is real-time safe, integrates with", ", and more.", "- This teleop node converts joy messages to twist messages.", "- This teleop node takes joy messages and publishes topics or calls actions according a configuration file.", "- Multiplex several velocity command topics with prioritization or disabling according to a configuration file.", "A simple robot drive system.", ":", "This package", ":", "Package created by Ryerson University students for the", ", summer 2017.", "3. Install the", "onto a microcontroller connected to motors and wheels by PWM. The microcontroller must also be connected to the computer running the simple_drive ROS node by a serial connection (ex. USB).", "This diagram is also available in", ".", "This node converts", "messages from the", "node into a variety of commands to drive the robot at low, medium, and high speed, look around with a servo, and cancel move_base goals at any moment. This node simply sends commands to other nodes. Typically the servo is used to move a camera so that the teleoperator can look around the robot.", "The", "node receives movement commands on two", "topics, one for teleoperation and one for autonomous control, typically", ". Movement commands are multiplexed to a final topic for robot consumption. If any teleoperation command is received autonomous commands are blocked for a set time defined by the", "parameter.", "This node communicates with the", "using a custom serial protocol described below. An example serial data packet could be 0,0.5,0.5 which would mean drive motors forward at half speed and rotate at half speed.", "The", "microcontroller code does the minimum amount of work possible to receive motor commands from a USB serial connection and output voltages to digital PWM output to be received by motor controllers.", "We deploy the", "to an Arduino microcontroller using PlatformIO.", "More PlatformIO install info:", "More PlatformIO info:", "When a left and right joystick inputs are received by the", "node, representing left and right wheel velocities (ie. skid steering or differential drive), a", "with linear and rotational velocities is calculated as:", "When a", "containing linear and rotational velocities is received by the", ", wheel velocities are calculated as:", "Feature requests, bug reports, and contributions are welcome at", "."]},
{"url": "https://wiki.ros.org/rocon_python_comms", "package": "rocon_python_comms", "package_summary": ["Service pair libraries for pub/sub non-blocking services."], "package_details": ["Full details and usage examples are in the sphinx documentation (", "), the following is just a brief reference of what is available."]},
{"url": "https://wiki.ros.org/robot_state_publisher", "package": "robot_state_publisher", "package_summary": ["This package allows you to publish the state of a robot to", ". Once the state gets published, it is\n    available to all components in the system that also use", ".\n    The package takes the joint angles of the robot as input\n    and publishes the 3D poses of the robot links, using a kinematic\n    tree model of the robot. The package can both be used as a library\n    and as a ROS node.  This package has been well tested and the code\n    is stable. No major changes are planned in the near future."], "package_details": ["All fixed transforms are", "by 0.5s.", "(", ")", "(", ")", "(", ")", "(", ")", "robot_state_publisher uses the URDF specified by the parameter", "and the joint positions from the topic", "to calculate the forward kinematics of the robot and publish the results via", ".", "Please see the tutorial on", ".  It will explain how you can publish the state of your robot to", ", using the robot state publisher."]},
{"url": "https://wiki.ros.org/jackal_viz", "package": "jackal_viz", "package_summary": ["Visualization launchers and helpers for Jackal."], "package_details": ["This package provides launchers and", "configurations to assist with visualizing real or simulated", "from a desktop environment. For help getting your desktop environment set up to use with Jackal, see the", ".", "For more information on simulating Jackal, see", ".", "For more examples, see", "."]},
{"url": "https://wiki.ros.org/smach", "package": "smach", "package_summary": ["SMACH is a task-level architecture for rapidly creating complex robot\n    behavior. At its core, SMACH is a ROS-independent Python library to build\n    hierarchical state machines. SMACH is a new library that takes advantage of\n    very old concepts in order to quickly create robust robot behavior with\n    maintainable and modular code."], "package_details": ["You can build a finite state machine using SMACH, but SMACH can do much more. SMACH is a library for task-level execution and coordination, and provides several types of \"state containers\". One such container, is a finite state machine, but this container can also be a state in another container. See the", "for a list of containers and states built into SMACH.", "The", "provides an overview of the concepts used in SMACH.", "The", "contains an extensive set of tutorials to get you up to speed building and running your own state machines."]},
{"url": "https://wiki.ros.org/omip", "package": "omip", "package_summary": [], "package_details": ["(Main author) Roberto Mart\u00edn-Martin (", ",", ")", "Sebastian H\u00f6fer (", ",", ")", "Oliver Brock (", ")", "1.", ". Three estimation levels: feature tracking, feature-based rigid body tracking, kinematic model estimation. This option can execute only using RGB-D images and therefore requires less computational power.", "To try this option, download one of the rosbags with the \"_imgs\" suffix and launch OMIP using the option \"--omip=1\" (or \"--omip=2\" if you want that the terminals", "remain open after finishing the execution, for debugging purposes).", "More frequent problem: The feature tracking is not running and looks like frozen -> Check in feature_tracker/cfg/feature_tracker_cfg.yaml the depth_img_topic name. Depending if you are using", "openni or openni2 (or rosbags generated from one or the other package) the name of the topic for the depth maps is different.", "Based on the recursive estimation schema - prediction/correction -  our framework can cope with the high amount of data provided by the robot's sensors", ".", "The key (and the main idea of our framework) is to factorize the perceptual problem into smaller *perceptual units*, solve them with single recursive estimation loops and connect all the loops tightly.", "The connection of the loops defines a bidirectional information flow between loops: a bottom-up flow to pass estimations as measurements to more abstract levels, and a top-down flow to pass predicted measurements as predicted next states to less abstract levels.", "By connecting the loops our framework can interpret the combined sensor-action stream as evidence of concepts of different level of abstraction.", "Each recursive estimation level is realized as a ROS node that implements the interface", ".", "A recursive estimation level is defined by:", "* Measurement", "* State", "* Priors:", "Internally, each level contains at least one recursive estimation filter. These filters implement the interface", ".", "The levels call the corresponding correct-predict methods of the filters and pass the measurements/states up and down."]},
{"url": "https://wiki.ros.org/rh_p12_rn_base_module_msgs", "package": "rh_p12_rn_base_module_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_python_utils", "package": "rocon_python_utils", "package_summary": ["Python system and ros utilities."], "package_details": []},
{"url": "https://wiki.ros.org/smach_ros", "package": "smach_ros", "package_summary": ["The smach_ros package contains extensions for the SMACH library to\n    integrate it tightly with ROS.  For example, SMACH-ROS can call\n    ROS services, listen to ROS topics, and integrate\n    with", "both as a client, and a provider of action servers.  SMACH is a\n    new library that takes advantage of very old concepts in order to\n    quickly create robust robot behavior with maintainable and modular\n    code."], "package_details": ["For example, if you want to call an", "action from SMACH, you can of course write a", ", which would look something like this:", "But you can call that same action with much less coding, using the SimpleActionState:", "SMACH ROS offers the same type of support for ROS services and ROS topics. For more details take a look at the", "."]},
{"url": "https://wiki.ros.org/rbcar_robot_control", "package": "rbcar_robot_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotis_controller_msgs", "package": "robotis_controller_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosR_demos", "package": "rosR_demos", "package_summary": [], "package_details": ["16763/6"]},
{"url": "https://wiki.ros.org/ros", "package": "ros", "package_summary": ["ROS packaging system"], "package_details": []},
{"url": "https://wiki.ros.org/android_remocons", "package": "android_remocons", "package_summary": [], "package_details": ["This stack includes code for the android remocon and libraries for development of remocon usable android applications. The remocon is used on the", ". Refer to the", "page for more information."]},
{"url": "https://wiki.ros.org/kobuki_softapps", "package": "kobuki_softapps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_mrta", "package": "rqt_mrta", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "[1]", "Gerkey, Brian P., and Maja J. Matari\u0107.", "The International Journal of Robotics Research 23.9 (2004): 939-954."]},
{"url": "https://wiki.ros.org/asr_cyberglove_visualization", "package": "asr_cyberglove_visualization", "package_summary": ["This package is used to test the functionalities of the CyberGloves and FlockOfBirds. \n    It uses an URDF model of a human hand to provide a visualization of the glove movements in RViz."], "package_details": ["The asr_cyberglove_visualization package is used to test and visualize the functionalities of the", "and", "packages. It uses an URDF model of a human hand to provide a visualization of the movement data from the gloves and the magnet tracking system (Flock of Birds) in RViz.", "To use im combination with", "and", "the following hardware components are needed:", "RViz has to be configured to show/add the RobotModel. The RViz configuration files located in", "can be used when launching to provide an ideal view of the model and its movements in RViz. They are included in the launch files.", "The sensor data of the Cybergloves is received as", "messages published by the asr_cyberglove_lib server. The topics to listen to are:", "The pose data of the Flock of Birds trackers is received as", "messages published by the asr_flock_of_birds server. The topic to listen to is:", "The current Cyberglove state data is published to the model as", "messages. They are published to the following topic:", "The Flock of Birds data is published using a", "."]},
{"url": "https://wiki.ros.org/pcl", "package": "pcl", "package_summary": [], "package_details": ["The Point Cloud Library (PCL) is a stand-alone C++ library for 3D point cloud processing. You can learn more about PCL by visiting its website,", ". The documentation on ROS.org will help you get started using PCL in your ROS applications.", "For information about how to use PCL's ROS-specific data types and how to publish and subscribe to point cloud data, please consult the", ".", "You can find numerous code examples on PCL's", ".", "For examples of how to include PCL code in a ROS node, please refer to the", "page.", "For a reference guide to PCL's ROS-specific APIs, see the", "for the", "package."]},
{"url": "https://wiki.ros.org/rosR", "package": "rosR", "package_summary": [], "package_details": ["28895/10", "See also", ".", "Within this subsection we will describe all steps that are required to install ros-groovy under an Ubuntu 12.04 32-bit (with long time support) and then our extension for the R-programming language (especially for users with totally no ROS experience). The first steps were taken from the manual (", ") and we guess, you already have installed Ubuntu on your PC.", "The handling of  arrays is a bit tricky, because in the background these are handled as C structures std::vector. Thus, the size of our new", "is currently 0:"]},
{"url": "https://wiki.ros.org/ros_mppt", "package": "ros_mppt", "package_summary": [], "package_details": ["MPPT data registration into a xls file for experimental purposes.", "MPPT ROS package.", "VE.Direct Protocol - Version 3.25.", "BlueSolar HEX protocol MPPT."]},
{"url": "https://wiki.ros.org/ros_statistics_msgs", "package": "ros_statistics_msgs", "package_summary": [], "package_details": ["These messages are used with the", "package's tools."]},
{"url": "https://wiki.ros.org/raspigibbon_bringup", "package": "raspigibbon_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_capabilities", "package": "rqt_capabilities", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/langs", "package": "langs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_soft", "package": "kobuki_soft", "package_summary": [], "package_details": ["Please refer", "Wiki"]},
{"url": "https://wiki.ros.org/rqt_alliance", "package": "rqt_alliance", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/elevator_move_base_pr2", "package": "elevator_move_base_pr2", "package_summary": [], "package_details": ["and", "Documentation is available", ".", "Use trac to report", "or", "."]},
{"url": "https://wiki.ros.org/ros_web_video", "package": "ros_web_video", "package_summary": [], "package_details": ["Several parameters can be configure via the video stream URL - Example:", ".", "Source code is available at", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/rbcar_gazebo", "package": "rbcar_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_kinematics_dynamics", "package": "manipulator_h_kinematics_dynamics", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotnik_msgs", "package": "robotnik_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_hardware", "package": "mrp2_hardware", "package_summary": ["Hardware files to communicate with MRP2 base."], "package_details": []},
{"url": "https://wiki.ros.org/sick_visionary_t", "package": "sick_visionary_t", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/schunk_lwa4p", "package": "schunk_lwa4p", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nanomsg", "package": "nanomsg", "package_summary": ["The nanomsg package"], "package_details": ["is a very lightweight (smaller brother of zeromq) communications library accomodating various design patterns. It can be useful for specialised instances where ros doesn't really fit. e.g. Bridging connections to lightweight embedded boards or in grafting your own custom messaging architecture for a specific use case."]},
{"url": "https://wiki.ros.org/detect_cans_in_fridge_201202", "package": "detect_cans_in_fridge_201202", "package_summary": [], "package_details": ["and", "Documentation is available", ".", "Use trac to report", "or", "."]},
{"url": "https://wiki.ros.org/ackermann_qt", "package": "ackermann_qt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_mpl80_moveit_config", "package": "motoman_mpl80_moveit_config", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/reemc_controller_configuration_gazebo", "package": "reemc_controller_configuration_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/agvs_common", "package": "agvs_common", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", ", shared for real robot and simulation."]},
{"url": "https://wiki.ros.org/airbus_plugin_rviz", "package": "airbus_plugin_rviz", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/shared_serial", "package": "shared_serial", "package_summary": [], "package_details": ["Use trac to", "or", "[", "]"]},
{"url": "https://wiki.ros.org/scriptable_monitor", "package": "scriptable_monitor", "package_summary": [], "package_details": ["Suppose we have a node that publishes current CPU usage to the", "topic. Each message contains an array named", "with usage information for each core. We also have a topic with configuration information:", ".", "You can activate the script using rqt plugin -"]},
{"url": "https://wiki.ros.org/raspigibbon_ros", "package": "raspigibbon_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rbcar_sim", "package": "rbcar_sim", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation."]},
{"url": "https://wiki.ros.org/ridgeback_viz", "package": "ridgeback_viz", "package_summary": ["Visualization launchers and helpers for Ridgeback."], "package_details": ["This package provides launchers and", "configurations to assist with visualizing real or simulated", "from a desktop environment. For help getting your desktop environment set up to use with Ridgeback, see the", "."]},
{"url": "https://wiki.ros.org/rl_experiment", "package": "rl_experiment", "package_summary": [], "package_details": ["Please take a look at the", "on how to install, compile, and use this package.", "Check out the code at:", "This package provides a way of running reinforcement learning experiments with the agents from the", "package and environments from the", "package without using the", "interface. Instead, the code instantiates agent and environment objects and calls their methods directly. It can be set to run for a particular number of episodes and trials, and prints out the sum of rewards for each episode to cerr.", "There are a number of options available to set parameters of both the agent and environment used.  More details on the agent options are available in the", "documentation, and more details on the env options are available in the", "documentation.", "In addition to these options, there a few variables that can be changed in the code, in the", ". Near the top of the file are two variables: MAXSTEPS and NUMTRIALS. MAXSTEPS determines the maximum number of steps for an episode. A new episode will be started after this many steps even if the agent has not reached a terminal state.", "As an example, here is how you would run Q-Learning (", ") on the stochastic Taxi task (", "):", "Or to run real-time TEXPLORE (", ",", ") at 10 Hz on the deterministic Fuel World task (", ") with 8 discrete trees:", "While you should find that the qlearner, sarsa, dyna, and rmax agents work fine on the easier tasks (tworooms, taxi, etc), they will not converge within the default 1000 episodes on more complex tasks like Fuel World. As an example, here is how to run Q-Learning (", ") on the Fuel World task (", ") using the --nepisodes flag to run it for 1,000,000 episodes, which should be enough time for it to converge.", "Another problem you may run into is when running these methods on the continuous domains (mcar, cartpole, car2to7, car7to2, and carrrandom). For these domains, the tabular RL methods (Q-Learning, SARSA, Dyna, R-Max) will need the state to be discretized. The following command will run Q-Learning (", ") on the Mountain Car task (", ") while discretizing each of the state features into 10 discrete values using the --nstates option."]},
{"url": "https://wiki.ros.org/rbcar_control", "package": "rbcar_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mr_tools", "package": "mr_tools", "package_summary": [], "package_details": ["This package contains 2 nodes that communicate with the input devices and publishes", "to an arbitrary number of output topics, which allows control over a multiple number of robots."]},
{"url": "https://wiki.ros.org/ros_package_web_server", "package": "ros_package_web_server", "package_summary": [], "package_details": ["A webserver that serves ROS package resources. This is useful with", "for serving resources that would normally be found with rospack. For example when displaying a URDF using", "the robot model files must be served from somewhere. This package allows for these models to be served directly from the install location instead of having to copy resources to a separate web root. Resources are served with CORS enabled to allow for easy interop with resources served elsewhere. Navigating to the root path will display a list of all installed packages. Resources can then be loaded using by prefixing the path of the resource relative to the share location of the package. For installed packages this is in the share folder in the install location and for non-installed packages this is the package root."]},
{"url": "https://wiki.ros.org/rosprofiler", "package": "rosprofiler", "package_summary": [], "package_details": ["(", ")", "(", ")", "The rosprofiler package is commonly used with", "."]},
{"url": "https://wiki.ros.org/airbus_ssm_tutorial", "package": "airbus_ssm_tutorial", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/cob_sick_s300", "package": "cob_sick_s300", "package_summary": ["This package published a laser scan message out of a Sick S300 laser scanner."], "package_details": ["The", "package provides two configurable nodes for operating with the scanners.", "This package is not intended to be used directly, but with the corresponding launch and yaml files from e.g.", "in the", "stack.", "For starting use:", "All hardware configuration is done in the", "package. A sample parameter file in \"cob_hardware_config/cob3-3/config/laser_front.yaml\" could look like this"]},
{"url": "https://wiki.ros.org/rocon_app_manager_msgs", "package": "rocon_app_manager_msgs", "package_summary": ["Messages used by the platform app manager."], "package_details": []},
{"url": "https://wiki.ros.org/simple_arm", "package": "simple_arm", "package_summary": [], "package_details": ["Caution! This software does not stop moving the robot if no messages are received for certain period of time. A pull request for this is very welcome.", "We like PlatformIO: \"Single source code. Multiple platforms.\" PlatformIO supports approximately 200", "and all major", ". Learn more on", ".", "A simple arm system.", ":", "This package", ":", "This diagram is also available in", ".", "Package created by Ryerson University students for the", ", summer 2017.", "3. Install the", "onto a microcontroller connected to the arm joint motors by PWM. The microcontroller must also be connected to the computer running the simple_arm ROS node by a serial connection (ex. USB).", "This node converts", "messages from the", "node into a variety of commands that are sent over serial to a microcontroller to drive the robot arm.", "This node communicates with the", "using a simple serial protocol. Each serial motion command is a list of floats, one for each joint.", "The", "microcontroller code does the minimum amount of work possible to receive motor commands from a USB serial connection and output voltages to digital PWM output to be received by motor controllers.", "We deploy the", "to an Arduino microcontroller using PlatformIO.", "More PlatformIO install info:", "More PlatformIO info:", "Feature requests, bug reports, and contributions are welcome at", "."]},
{"url": "https://wiki.ros.org/kingfisher_teleop", "package": "kingfisher_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neo_msgs", "package": "neo_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libviso2", "package": "libviso2", "package_summary": [], "package_details": ["See the", "package for nodes that use this library.", "Related publications can be found", ". The main paper that describes this library is:"]},
{"url": "https://wiki.ros.org/rb1_base_sim", "package": "rb1_base_sim", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation."]},
{"url": "https://wiki.ros.org/siemens_cp1616", "package": "siemens_cp1616", "package_summary": [], "package_details": ["This package is part of", "program. It currently contains nodes for communication with PROFINET compatible devices utilizing Siemens PCI card CP1616. Both IO Controller and IO Device modes running RT protocol are supported, enabling data transmissions of 1440 input + 1440 output bytes per frame with cycle times in range of 1-10ms.", "This  package is built on the top of IO Base library which is part of DK16xx-  PNIO development kit provided directly by Siemens. To use", "with Ubuntu 14.04 LTS distribution, the latest driver", "is necessary. Please check Siemens support site to get the latest software.", "We created set of tutorials that will walk you through using", "package step by step. You can get started on", "tutorial. For a complete list, check out the", "page."]},
{"url": "https://wiki.ros.org/rocon_bubble_icons", "package": "rocon_bubble_icons", "package_summary": ["Bubble icon library for rocon."], "package_details": []},
{"url": "https://wiki.ros.org/rr_swiftnav_piksi", "package": "rr_swiftnav_piksi", "package_summary": [], "package_details": ["Install binaries via aptitude package manager", "Install source from github (only use if you want to make custom changes to the source code)", "This package requires", "'s", ". Install before installing this package."]},
{"url": "https://wiki.ros.org/multi_jackal_tutorials", "package": "multi_jackal_tutorials", "package_summary": [], "package_details": ["provides examples on how to simulate multiple", "in Gazebo.", "Gazebo will be generating the ROS clock, so it can simulate faster or slower than real time (this is set in the world description). If", "is set to", ", the Gazebo client will also appear. This can also be done after launching by running", "in a new terminal.", "The namespace", "must be unique (like jackal0, jackal1, etc), so that individual robots can be identified. The configuration type", "specifies the components on the jackal. This string must match a file located in", ". The configuration ID", "is used if required by the configuration. Movement to goal locations is provided through", ". The model description (", "), navigation (", "), and controllers (", "), are all called through the Jackal base (", ").", "Frames have also been prefixed by the namespace (right click -> view image to zoom in):", "A number of arguments can be specified when creating a Jackal. These are listed in (", ")."]},
{"url": "https://wiki.ros.org/rbcar_sim_bringup", "package": "rbcar_sim_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/smach_viewer", "package": "smach_viewer", "package_summary": ["The smach viewer is a GUI that shows the state of hierarchical\n    SMACH state machines. It can visualize the possible transitions\n    between states, as well as the currently active state and the\n    values of user data that is passed around between states. The\n    smach viewer uses the SMACH debugging interface based on\n    the", "to gather information from running state machines."], "package_details": ["Your state machine needs to run an introspection server to allow the smach viewer to connect to it. See", "for more details."]},
{"url": "https://wiki.ros.org/asr_kinematic_chain_dome", "package": "asr_kinematic_chain_dome", "package_summary": ["This package provides information about the PbD dome's kinematic chain and contains launch-files to publish the chain to a robot_state_publisher. Available launchfiles are: dome with real PTU, dome with simulated PTU, dome with real PTU and Flock of Birds and additional transformation_publisher from guppy-cameras to the kinect cameras mounted above. It also contains the urdf model."], "package_details": ["The kinematic chain consists of two major parts: The camera-system (PTU, Guppy-Cameras and Kinect) and the Flock of Birds magnet tracking system (Receiver and Tracker). Colors form the picture above. The fixed reference Frame is in the PTU and is called", ". There is an identity transformation to", "which is mostly used.", "The TF is published at topic /tf. The visualization is available in the RobotModel.", "start rviz and"]},
{"url": "https://wiki.ros.org/map_store", "package": "map_store", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/reemc_gazebo", "package": "reemc_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/soem_ebox", "package": "soem_ebox", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_rosjava_core", "package": "rocon_rosjava_core", "package_summary": [], "package_details": ["For more information on the interactions framework, refer to", "and example android development, refer to the", "main page."]},
{"url": "https://wiki.ros.org/agvs_sim", "package": "agvs_sim", "package_summary": [], "package_details": ["This package contains the different controllers and launch files for the", "simulation.", "1."]},
{"url": "https://wiki.ros.org/agvs_sim_bringup", "package": "agvs_sim_bringup", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_sensors", "package": "mrpt_sensors", "package_summary": ["ROS nodes for various robotics sensors via mrpt-hwdrivers"], "package_details": ["Use GitHub to", ". [", "]", "ROS nodes for various robotics sensors via", "."]},
{"url": "https://wiki.ros.org/ros_topology_msgs", "package": "ros_topology_msgs", "package_summary": [], "package_details": ["These messages are used with the tools in the", "package."]},
{"url": "https://wiki.ros.org/rtt_typelib", "package": "rtt_typelib", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/self_test", "package": "self_test", "package_summary": ["self_test"], "package_details": ["You can get a list of the available subtests with the rosservice command:", "You can then run the self test using rosservice:", "You can get different output with the", "node:", "The", "class will advertise a service \"~self_test\". When called, it will perform a check on the node's connection status, and any other checks a developer wants to perform on a node or device.", "An example use of the self_test package's API can be found in", ".", "self_test contains the", "class that can be used to sequence a set of tests to be run in order to test a device. It advertises a self_test service. When the service is called, the", "calls the tests that have been defined in order, and combines the results into a", "array (see the service definition", "). A detailed example can be found in", "."]},
{"url": "https://wiki.ros.org/abb_irb4400_support", "package": "abb_irb4400_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot_markers", "package": "robot_markers", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "is a library for creating", "for a robot, given a", ".", "is the main interface for building a", "from a URDF.", "The library's generated documentation explains how to use", ".", "First, create a", "for a given URDF:", "A notable feature of", "is the ability to set the joint angles of the robot.", "To do so, pass in a map that gives the joint angles for a set of joint names.", "does not check joint angle limits.", "Once you have configured the visualization, call", ", passing in a marker array to append the robot markers to."]},
{"url": "https://wiki.ros.org/kvh", "package": "kvh", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/multi_jackal_control", "package": "multi_jackal_control", "package_summary": [], "package_details": ["contains the launch files and parameters providing joint and velocity controllers for multiple simulated", ". It has been extended from the single robot", "to separate the robots into unique namespaces, allowing multiple robots to be simulated at the same time.", "There are tutorials on how to use this package in", "."]},
{"url": "https://wiki.ros.org/reemc_simulation", "package": "reemc_simulation", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/r2_moveit_config", "package": "r2_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mm_messages", "package": "mm_messages", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/soem_beckhoff_drivers", "package": "soem_beckhoff_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_device_msgs", "package": "rocon_device_msgs", "package_summary": ["Messages used by rocon devices"], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"rocon_device_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/rocon_device_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/ros_in_hand_scanner", "package": "ros_in_hand_scanner", "package_summary": [], "package_details": ["This", "shows a scanning process using Intel", "Camera.", "This package needs PCL 1.8.0 to be installed. See", "for further information.", "Due to performance issues, a realtime registration is very slow with down to < 0.1 fps.", "A workaround is to record a rosbag file during the scanprocess itself. You can use the preview window to get a view of your actual scan orientation.", "Play the rosbag file afterwards with a low rate ~0.1 and start registration now.", "Follow the hints in the PCL documentation for your scan process."]},
{"url": "https://wiki.ros.org/schunk_robots", "package": "schunk_robots", "package_summary": [], "package_details": ["See", ".", "Please consult", "to see if your problem is already known.", "Use", "to report bugs or request features."]},
{"url": "https://wiki.ros.org/rocon_msgs", "package": "rocon_msgs", "package_summary": ["Communication types (msgs/srvs/actions) for robotics in concert (aka multimaster)."], "package_details": ["Use github to report", ".", "."]},
{"url": "https://wiki.ros.org/ackermann_hks", "package": "ackermann_hks", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_mild_base_laserscanner", "package": "asr_mild_base_laserscanner", "package_summary": ["This package provides streams of laser scan messages in cartesian coordinates from a planar sick laser scanner."], "package_details": ["if you want to start the node with the mild.launch file.", "The main class is sick.cpp. It contains the SICK configuration and starts the code which communicates with the SICK. Also, it publishes the scan data to ROS. All other code is based on the", ". The toolbox also contains code for other SICK laserscanners.", "For a successful laserscan you only need to connect the SICK PLS 101-312 laserscanner to your PC. You can use USB or a Serial interface. For a baudrate of 500k you need USB or a RS422 Serial port and cable. To establish a connection, you must adapt the name of the connected port (look at parameter \"serial\"). Then you only need to start a launchfile with the laserscanner node e.g.", ".", "_/scan_ (", "Look at", "on how to adapt the parameters."]},
{"url": "https://wiki.ros.org/asr_kinematic_chain_optimizer", "package": "asr_kinematic_chain_optimizer", "package_summary": ["This package calculates the best approximation for a kinematic chain's parameters using rosenbrock optimization. For calculation, a layout of the kinematic chain must be provided, as well as a set of transformations between two frames of the chain that has been acquired during calibration."], "package_details": [".", "<Data>", "</Data>", "To specify an input-file use the", "-tag. This surrounds the whole file.", "To specify the structure of your kinematic chain use the", "-tag. In this area the tf-frames are defined. There are some different types of frames:", "A simple parent-child relation is defined as", ", with Frame1 is the parent node of Frame 2.", "To specify the goal function (for closing you kinematic chain) use the", "-tag. The goal can be ether the position, orientation or both.", "The position use the", "-Tag. With this goal, the algorithm tries to set the position of Frame1 equal to the one of Frame2. Same for", "with the frames orientations.", "The data-file contains just the n-tuple datasets. One n-tuple is in one line. The single values are separated with a semicolon and a space. The program maps the data in column one to the first parameter (e. g. \"[1]\") and so on.", "The optimizer outputs the calculated values for the kinematic chain parameters directly to the console."]},
{"url": "https://wiki.ros.org/b21_description", "package": "b21_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot_model", "package": "robot_model", "package_summary": [], "package_details": ["provides the following ROS", ":"]},
{"url": "https://wiki.ros.org/scriptable_monitoring", "package": "scriptable_monitoring", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "Scriptable monitoring provides a tool that runs monitoring scripts (Python or predicate-like), allowing a definition of monitoring rules for values obtained via topic messages, and also alerts about violated rules to the", "topic, which can be monitored using rqt plugins like", "or", "."]},
{"url": "https://wiki.ros.org/phoxi_camera", "package": "phoxi_camera", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_mh_support", "package": "motoman_mh_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/shape_msgs", "package": "shape_msgs", "package_summary": ["This package contains messages for defining shapes, such as simple solid\n    object primitives (cube, sphere, etc), planes, and meshes."], "package_details": []},
{"url": "https://wiki.ros.org/neo_watchdogs", "package": "neo_watchdogs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/create_driver", "package": "create_driver", "package_summary": ["ROS driver for iRobot's Create and Roomba platforms, based on libcreate"], "package_details": []},
{"url": "https://wiki.ros.org/remote_monitor", "package": "remote_monitor", "package_summary": [], "package_details": ["(", ", default: 0.2)", "(", ", default: 1.0)", "c", "(", ")", "Remote monitoring package for navigation with", ". We actually succeeded in remotely monitoring", "'s pose running in Tsukuba from Fukuoka (", ")", "How to connect remote PCs with OpenVPN can be seen in", ".", "Tutorial to integrate OpenVPN and ROS is", "."]},
{"url": "https://wiki.ros.org/serial_utils", "package": "serial_utils", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosweb", "package": "rosweb", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rf2o_laser_odometry", "package": "rf2o_laser_odometry", "package_summary": [], "package_details": ["The user is advised to check the related papers (", ") for a more detailed description of the method."]},
{"url": "https://wiki.ros.org/rosjson", "package": "rosjson", "package_summary": [], "package_details": ["The JSON (JavaScript Object Notation) format is useful when building Web-based interfaces that need access to ROS data. rosjson is meant to be coupled with a Python Web server so that the JSON objects can be served over a Web connection.", "is one example Web server implementation, but it is currently in high design flux.", "No further features are planned for the ROS JSON library as JSON itself is just a data representation. Python 2.6 has a json module that would simplify the existing code and make it more robust, but as the current package is < 50 lines of Python, there's not much to improve upon."]},
{"url": "https://wiki.ros.org/neo_platformctrl_diff", "package": "neo_platformctrl_diff", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kingfisher_description", "package": "kingfisher_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/scheduler_msgs", "package": "scheduler_msgs", "package_summary": ["Messages used by the rocon scheduler."], "package_details": []},
{"url": "https://wiki.ros.org/softkinetic_camera", "package": "softkinetic_camera", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rv4fl_moveit_config", "package": "rv4fl_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lower_step_detector", "package": "lower_step_detector", "package_summary": [], "package_details": ["To install the", "package, you can install from source with the following commands:"]},
{"url": "https://wiki.ros.org/roslang", "package": "roslang", "package_summary": ["roslang is a common package that all", "depend on.\n    This is mainly used to find client libraries (via 'rospack depends-on1 roslang')."], "package_details": ["The", "package is only of interest to those implementing a ROS", ". Client libraries marks themselves as such by depending on the", "package, which allows", "and other tools to perform appropriate actions, such as", "- and", "-based code generation. The", "package itself contains no actual code."]},
{"url": "https://wiki.ros.org/multi_jackal_nav", "package": "multi_jackal_nav", "package_summary": [], "package_details": ["contains the launch files and parameters providing localization and waypoint following for multiple simulated", ". It has been extended from the single robot", "to separate the robots into unique namespaces, allowing multiple robots to be simulated at the same time.", "There are tutorials on how to use this package in", "."]},
{"url": "https://wiki.ros.org/prosilica_gige_sdk", "package": "prosilica_gige_sdk", "package_summary": ["AVT GigE SDK version 1.26 for ROS"], "package_details": ["NOTE: The recommended way of using Prosilica cameras in ROS is through the driver in", ". You need only use this package directly if you are writing your own software for interacting with Prosilica cameras without going through ROS."]},
{"url": "https://wiki.ros.org/joint_tracker", "package": "joint_tracker", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/airbus_pyqt_extend", "package": "airbus_pyqt_extend", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/sound_play", "package": "sound_play", "package_summary": ["sound_play provides a ROS node that translates commands on a ROS topic (", ") into sounds. The node supports built-in sounds, playing OGG/WAV files, and doing speech synthesis via festival. C++ and Python bindings allow this node to be used without understanding the details of the message format, allowing faster development and resilience to message format changes."], "package_details": ["If you need the information in this section for something other than satisfying curiosity, you are probably doing something wrong.", "The", "node considers each sound (built-in, wave file or synthesized text) as an entity that can be playing, playing repeatedly or stopped. Nodes change the state of a sound by publishing to the", "topic. Multiple sounds can be played at once.", "C++ and Python bindings are provided. It should be unnecessary to directly generate messages when playing sounds from C++ or Python. Documentation of the language bindings are in", ".", "The following utilities can be used to play sound when", "is running. For help on getting", "running refer to the", ".", "The", "script can play any", "or", "file. The file must be available on the computer on which", "is running, and an absolute path should be given.", "Some standard sounds are built-into the driver, and can be played only by specifying their integer identifier using", ".", "For example (", "should be running first):", "To get an up-to-date list of the built-in sounds, consult the definition of the", "message. The relevant information is below the \"", "\" comment.", "The sound node can also be used to synthesize speech using the", ". The", "script gives command-line access to this functionality. This script can take its input from the command line, or if the command-line is empty it can take input from standard input.", "Examples (", "should be running first):", "The most immediate way to silence the robot is to use", "to mute or lower the volume. In some cases, a node that had requested a continuous sound could crash with the sound still playing. In order to stop that sound the", "script can be used.", "The", "script sends a stop command on all sounds every 100ms until it is terminated. This behavior will immediately stop any continuous sounds that were playing, and will cut short any new sounds that are played. It will not completely silence the robot, however, as the first tens of milliseconds of newly requested sounds will be played before they are silenced.", "To test that", "is operating correctly, you can use the", "script. It will play the various built-in sounds, and exercise the", "playing and text-to-speech capabilities. To run it:", "The following launch file, which starts", ", can be found in", ":", "Sound commands are issued to", "via a", "message. Commands define two things: a sound, and what to do with that sound.", "The sound is defined by the", "(int) and", "(string) fields of the message, and can be one of four types:", "Each message on the", "topic will cause a sound to transition between the playing continuously, playing once (or twice) and stopped states. For example, a backing up sound could be initiated by sending a command for a backing up sound to play continuously. When the robot stops backing up, a stop command will stop playback. Likewise, verbal debugging messages could be used by telling a sound to play once. In this case there is no need to stop playing the sound."]},
{"url": "https://wiki.ros.org/mm_mux_demux", "package": "mm_mux_demux", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rbcar_joystick", "package": "rbcar_joystick", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_gazebo", "package": "manipulator_h_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/futaba_serial_servo", "package": "futaba_serial_servo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_control", "package": "mrp2_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosunit", "package": "rosunit", "package_summary": ["Unit-testing package for ROS. This is a lower-level library for rostest and handles unit tests, whereas rostest handles integration tests."], "package_details": ["is an internal tool for running unit tests within ROS.  While it can be run by a regular user, most users will generally use", "indirectly via", "test macros.  The main feature that", "provides is terminating a unit test based on a timeout and generating an appropriate test failure.  The rosbuild system uses this feature to ensure that unit tests properly terminate.", "currently supports:", "The library that comes with", "can be used as described at", "These helper scripts are intended for use only by the", "and test reporting infrastructure.", "Historically, rosunit is based on a refactoring of", ". It provides the unit-test infrastructure and rostest provides the integration test infrastructure. rostest is also allowed to interact with a running ROS graph.", "The initial separation was not perfect. There is more room to migrate more code from rostest into rosunit. Similarly, there is code within rosunit that would be better supported by a graph-less version of", ", i.e. a process monitor unattached to a ROS master. Until that happens, rosunit contains code that is a copy of internal libraries within roslaunch."]},
{"url": "https://wiki.ros.org/pano_ros", "package": "pano_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pano_core", "package": "pano_core", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kingfisher_msgs", "package": "kingfisher_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"kingfisher_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/kingfisher_msgs/manifest.yaml", "Used on the", "from", "."]},
{"url": "https://wiki.ros.org/gazebo_gripper", "package": "gazebo_gripper", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_std_msgs", "package": "rocon_std_msgs", "package_summary": ["Standard messages used by other rocon specific package types."], "package_details": []},
{"url": "https://wiki.ros.org/multi_jackal_base", "package": "multi_jackal_base", "package_summary": [], "package_details": ["provides a launch file for spawning all components of a simulated", ". It has been extended from the single robot", "to separate the robots into unique namespaces, allowing multiple robots to be simulated at the same time.", "There are tutorials on how to use this package in", ".", "A number of arguments can be provided when launching", ".", "If you only want to use local odometry for positioning, set", "to", "and", "to", ".", "If you want to use the Jackals GPS, set", "to", ", and", "to", ".", "If you want to use your own fusion, set them both to", "."]},
{"url": "https://wiki.ros.org/rl_common", "package": "rl_common", "package_summary": [], "package_details": ["StateActionInfo is the struct that the model must return when quering the model for its predictions for a given state action. It has a confidence (a float), a boolean telling if it is a 'known' transition or not, a float predicting the reward, a float predicting the termination probability, and a map of states (vectors of floats) to floats that gives the probabilities of next states. Full documentation for the StateActionInfo struct is available", ".", "This package defines interfaces for agents, environments, models, and plannersin the file", ". All agents, environments, models, and planners should inherit from their appropriate base class.", "Please take a look at the", "on how to install, compile, and use this package.", "Check out the code at:", "First, an experience <s,a,r,s'> tuple is defined, which is used to update the model. The state s the agent came from is a vector of floats, the action it took is an int, the reward it received is a float, and the next state s' it transitioned to is a vector of floats. In addition, there's a bool indicating if the transition was terminal or not. Full documentation for the experience struct is available", ".", "Agent is defined with a number of methods. Mainly it has first_action(state) which is called for the first action in an episode and returns an action. After that next_action(reward, state) should be called, which returns an action. Finally upon reaching a terminal state, last_action(reward) can be called. In addition to these methods, seedExp(vector of experiences) can be used to seed the agent with a set of experiences. Full documentation for the Agent class is available", ".", "The environment has a sensation() method which returns the current state vector and a terminal() method tells if the agent is in a terminal state or not. The agent can act upon the environment by calling apply(action) which returns a reward. A set of experience seeds to initialize agents is available using the getSeedings() method. There are also a number of methods to get information about the environment such as getNumActions, getMinMaxFeatures, getMinMaxReward, and isEpisodic. Full documentation for the Environment class is available", ".", "Full documentation for the MDPModelclass is available", ".", "Full documentation for the Planner class is available", "."]},
{"url": "https://wiki.ros.org/jaco_interaction", "package": "jaco_interaction", "package_summary": [], "package_details": ["The", "package provides interactive marker-based control of the end effector pose and issuing of manipulation commands for the JACO and JACO2.", "To install the", "package, you can install from source with the following commands:", "The interactive markers can be launched using two launch files:", "and", ".  The", "file launches all of the necessary ROS nodes to publish the interactive markers and send commands back to the arm, and as such it should be launched first on a computer connected directly to the JACO arm.  The", "file launches rviz with a preset configuration to show the arm model and the interactive markers.  This can be launched on any computer capable of displaying a GUI.  The syntax for launching these nodes is as follows:"]},
{"url": "https://wiki.ros.org/rh_p12_rn_description", "package": "rh_p12_rn_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rviz_fixed_view_controller", "package": "rviz_fixed_view_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rb_tracker", "package": "rb_tracker", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rmp_base", "package": "rmp_base", "package_summary": [], "package_details": ["The rmp_base package provides a ros interface to control a Segway Robotics Mobility Platform (", "). It supports USB and UDP interfaces.", "This package has only been tested on the RMP 440LE (", ")."]},
{"url": "https://wiki.ros.org/feature_tracker", "package": "feature_tracker", "package_summary": [], "package_details": ["The feature_tracker package is a versatile tool to detect and track point features in a RGB-D video stream. The framework can be easily modified to use different detection & tracking algorithms. The current implementation uses Kanade-Lucas-Tomasi algorithm (opencv implementation) to first detect corner features on the first frame and then track them in consecutive frames. it maintains a constant number of features by detecting new ones."]},
{"url": "https://wiki.ros.org/prbt_grippers", "package": "prbt_grippers", "package_summary": ["The package provides gripper support for the pilz_robots package."], "package_details": []},
{"url": "https://wiki.ros.org/mjpeg_server", "package": "mjpeg_server", "package_summary": [], "package_details": ["In a", ", run the mjpeg_server:", "Optionally, you can set a different port on the command line when launching", ":", "Here, /IMAGE_TOPIC is a ROS topic generated by the", "module, e.g.", "in case you are using a PR2.", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/rocon_service_pair_msgs", "package": "rocon_service_pair_msgs", "package_summary": ["Paired pubsubs generators for non-blocking services."], "package_details": []},
{"url": "https://wiki.ros.org/message_multiplexing", "package": "message_multiplexing", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ros_pytest", "package": "ros_pytest", "package_summary": ["The ros_pytest package"], "package_details": ["Readme"]},
{"url": "https://wiki.ros.org/rostune", "package": "rostune", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kobuki_softnode", "package": "kobuki_softnode", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/airbus_docgen", "package": "airbus_docgen", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/r2_msgs", "package": "r2_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mr_rqt", "package": "mr_rqt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robot_controllers_msgs", "package": "robot_controllers_msgs", "package_summary": ["Messages for use with robot_controllers framework."], "package_details": []},
{"url": "https://wiki.ros.org/robot_face", "package": "robot_face", "package_summary": [], "package_details": ["To model a robot face for the ros-package", "you have to follow this guidelines to get a working model in the application. This guideline will not tell you how to model a complete face, but helps you to get things work.", "To get a working model in the", "application, please follow this guidelines."]},
{"url": "https://wiki.ros.org/mico_description", "package": "mico_description", "package_summary": [], "package_details": ["contains urdf and xacro files for the MICO arm.  It also includes a launch file for reading the robot model and setting up a", "and", "for visualization in tools such as rviz.", "To install the", "package, you can install from source with the following commands:", "The", "package includes a launch file that can be used to load the robot model and setup joint state and robot state publishing used to populate a tf tree and visualize the robot.  Once launched, the MICO model can be visualized in tools such as rviz.  It can be launched with the following command:", "The launch file also includes a parameter (", ") to launch a GUI which can control each joint to test the model's behavior, which can be launched as follows:"]},
{"url": "https://wiki.ros.org/mrp2_bringup", "package": "mrp2_bringup", "package_summary": ["Launch files and configurations for starting MRP2 robot in a real environment."], "package_details": []},
{"url": "https://wiki.ros.org/settlerlib", "package": "settlerlib", "package_summary": ["Defines helper functions and routines that greatly help when trying to create a settler\n    for a specific sensor channel. This package is experimental and unstable.\n    Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/rosbag_image_compressor", "package": "rosbag_image_compressor", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rocon_tutorial_msgs", "package": "rocon_tutorial_msgs", "package_summary": ["Messages used by rocon tutorials."], "package_details": []},
{"url": "https://wiki.ros.org/kingfisher_viz", "package": "kingfisher_viz", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kinect_aux", "package": "kinect_aux", "package_summary": [], "package_details": ["is now a standalone package. In Electric it was a package in", ", which is deprecated.", "Use GitHub to", ". [", "]", "This driver provides access to additional features present in the Kinect sensor: accelerometer, tilt, and LED. One may use it in parallel with the", "driver.", "Assuming a catkin workspace has been created as described in", ", follow the steps below."]},
{"url": "https://wiki.ros.org/b21_teleop", "package": "b21_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_sith", "package": "pr2_sith", "package_summary": [], "package_details": ["This, along with", "gave me an idea. Essentially, what if you did the same exact demo, with slightly different arm positions, and a plastic lightsaber in the robots hand."]},
{"url": "https://wiki.ros.org/rqt_py_trees", "package": "rqt_py_trees", "package_summary": ["rqt_py_trees provides a GUI plugin for visualizing py_trees behaviour trees based on rqt_tf_tree."], "package_details": ["See also", ",", ","]},
{"url": "https://wiki.ros.org/remote_manipulation_markers", "package": "remote_manipulation_markers", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"remote_manipulation_markers\" in rosdoc: /var/www/docs.ros.org/en/api/remote_manipulation_markers/manifest.yaml", "The", "package contains interactive marker servers for a set of remote manipulation interaction approaches.  The approaches include Free Positioning, Constrained Positioning, and Point-and-Click.  These interactive marker servers are intended for use with rviz or with Robot Web Tools interfaces.", "This package includes three approaches:  Free Positioning (FP), Constrained Positioning (CP), and Point-and-Click (P&C).  The three approaches are shown below, with interaction points for setting initial poses shown in yellow, and interaction points for adjusting poses shown in blue.", "Free positioning uses a ring-and-arrow marker which can be clicked and dragged to individually adjust translation along and rotation about each Cartesian axis.  Constrained positioning uses a sphere marker to first set a grasp point, followed by setting an approach angle by clicking on the surface of the sphere.  The approach angle is constrained to pass through the grasp point.  Point-and-click makes use of autonomous grasp calculation, and involves the user selecting a previously calculated grasp for execution from a list of potential grasps.  Further details on these can be found in", ", published in HRI 2017.  The approaches are designed for both 2D and 3D visualization modes.  For full details and a comparison of the efficiency and effectiveness of each approach in both 2D and 3D visualization modes, see our IJRR 2019 article", ". Videos of the approaches in action can be found", "and", ".", "To install the", "package, you can install from source with the following commands:", "Note that", "and", "include a boolean parameter", ".  Setting", "to true will launch a", "node that corresponds to the free or constrained positioning node.", "If you use this package in your work, please cite our", ":", "David Kent, Carl Saldanha, and Sonia Chernova.  Leveraging Depth Data in Remote Robot Teleoperation Interfaces for General Object Manipulation.", ", 2019."]},
{"url": "https://wiki.ros.org/rh_p12_rn_manager", "package": "rh_p12_rn_manager", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rqt_graphprofiler", "package": "rqt_graphprofiler", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neo_base_mpo_500", "package": "neo_base_mpo_500", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libsegwayrmp", "package": "libsegwayrmp", "package_summary": [], "package_details": ["This is an external library that provides access to the segway rmp's.  It is maintained by William Woodall", "."]},
{"url": "https://wiki.ros.org/object_recognition_clusters", "package": "object_recognition_clusters", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kdl_wrapper", "package": "kdl_wrapper", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package requires the", "package to be installed.", "An example C++ code for doing inverse kinematics with the PR2 is given under", ":", "3. Compile the", "package."]},
{"url": "https://wiki.ros.org/robotis_framework_common", "package": "robotis_framework_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/modelica_bridge", "package": "modelica_bridge", "package_summary": [], "package_details": ["establishes a bridge between", ", a component-oriented equation-centric modeling language, and ROS. The connection is done via TCP/IP sockets; in ROS, the", "provides a node to run the server socket.", ",", "'s companion package in", ", contains a", "component which runs a client socket connection to ROS. Using TCP/IP sockets allow the messages transmitted between", "and ROS with preservation of order and content. The combination of", "and", "lets", "models and ROS control architectures communicate with each other without any additional internal configurations.", "is a ROS package, and so can only be run in Linux;", "similarly can only be run on", "systems, due to the current method of implementing sockets. Below is a list of", "tools and operating systems", "has been tested on:", "(", ")", "(", ")", "(", ", default: 9091)", "(", ", default: 20)", "To get a better understanding of the way the bridge works, view the image below, depicting the flow of information between", "and ROS.", "Here are a few", "that explain how to use the", "package in detail:"]},
{"url": "https://wiki.ros.org/smartek_camera", "package": "smartek_camera", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosruby_common", "package": "rosruby_common", "package_summary": [], "package_details": ["See", "."]},
{"url": "https://wiki.ros.org/airbus_ssm_core", "package": "airbus_ssm_core", "package_summary": [], "package_details": ["The SSM_core package is a SMACH overhaul including an interpretor of SCXML files.(", ").", "It creates a finite state machine (based on SMACH) using the data from the SCXML file.", "It can be usefull if you want to create a state machine using a GUI that generate a SCXML file like :", "Using the 'id' \"skill\" and set the 'expr' value to", "the name of the skill you want to use", ".", "In order to maintain the consistency of the", ", you have to link every outcome of this State inside the SCXML. If you forget to link one, them the", "consistency check will fail.", "If you want to put the skill.xml file in a different folder/pkg, use this syntax", "If you want to put scxml files in a different folder, use this syntax", "or you can give the pull path to the file."]},
{"url": "https://wiki.ros.org/libfovis", "package": "libfovis", "package_summary": [], "package_details": ["Albert S. Huang, Abraham Bachrach, Peter Henry, Michael Krainin, Daniel Maturana, Dieter Fox, and Nicholas Roy. Int. Symposium on Robotics Research (ISRR), Flagstaff, Arizona, USA, Aug. 2011", "."]},
{"url": "https://wiki.ros.org/airbus_plugin_rqt", "package": "airbus_plugin_rqt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pano_py", "package": "pano_py", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrpt_sensorlib", "package": "mrpt_sensorlib", "package_summary": ["C++ library for the base generic MRPT sensor node"], "package_details": []},
{"url": "https://wiki.ros.org/robot_pose_publisher", "package": "robot_pose_publisher", "package_summary": [], "package_details": ["The", "package contains a ROS node that will publish the transform between the", "frame and the", "frame as a pose message. This information is useful if you are interested in the robots position but do not want to stream the entire TF tree to get this information. An example use case is for web widgets.", "To run the node, ensure that a valid transform exists between the", "frame and the", "frame (e.g., from a navigation node), and run the following:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/rosboost_cfg", "package": "rosboost_cfg", "package_summary": ["Contains scripts used by the rosboost-cfg tool for determining cflags/lflags/etc. of boost on your system"], "package_details": []},
{"url": "https://wiki.ros.org/rocon_uri", "package": "rocon_uri", "package_summary": ["Module for working with rocon uri strings."], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h_base_module_msgs", "package": "manipulator_h_base_module_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/manipulator_h", "package": "manipulator_h", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_ikfast_right_arm_plugin", "package": "baxter_ikfast_right_arm_plugin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neo_platformctrl_mecanum", "package": "neo_platformctrl_mecanum", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/phm_tools", "package": "phm_tools", "package_summary": [], "package_details": ["You can access our article \"Prognostic & Health Management (PHM) Tool for Robot Operating System (ROS)\" published as dissemination activity of this project from", ".", "Flowchart of \"Robot Configuration Setup\" tab", "Flowchart of \"Monitoring and Analysis\" tab", "Electrical and Mechanical Equipments in PHM Tool", "Robot Design Tab in PHM Tool", "Configuration Setup tab in PHM Tool", "ALT Models and unit selection in System Configuration tab", "The calculated hazard rate and reliability value of the system without adding any sensor.", "Hazard rate and reliability values calculated by adding sensors to the modules in the system.", "Hazard Rate Analysis tab in PHM Tool", "Reliability Analysis tab in PHM Tool", "Task Completion Analysis tab in PHM Tool", "Sub-modules and components list of Power module with failure rates", "Sub-modules and components list of Sensing module with failure rates", "Sub-modules and components list of Communication module with failure rates", "Sub-modules and components list of Mobility module with failure rates", "Sub-modules and components list of Computation module with failure rates", "Configuration of OTA", "Added Sensors from Rosbag", "Architecture Between Phm Tools Nodes", "Hazard Rate Analysis Tab", "Reliability Analysis Tab", "POTC Real Time Analysis Tab", "POTC Prognostic Analysis Tab", "Publishing Tasks from Smach to PHM Tools", "Gazebo", "Use GitHub to", ". [", "]", "How to analyse the system is explained in Section 3.4 of", ".", "Configuration of the equipments in the OTA is included in section 3.2 of the", ". At the same time, the configuration operations performed in the PHM Tool use case scenario for OTA are explained in the video below.", "Monitoring and Analysis is explained in detail in Section 4 of the", ". At the same time, the processes under Monitoring and Analysis tab for the OTA use case scenario of PHM Tool are explained in the video below.", "[2] H. Wayne Beaty and James L. Kirtley, Jr., Electric Motor Handbook,", "-Hill Book Company 1998.", "[5] Modarres, M., Kaminskiy, M. P., & Krivtsov, V. (2016). Reliability engineering and risk analysis: a practical guide. CRC press."]},
{"url": "https://wiki.ros.org/kdl_acc_solver", "package": "kdl_acc_solver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/segwayrmp", "package": "segwayrmp", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ridgeback_desktop", "package": "ridgeback_desktop", "package_summary": ["Packages for working with Ridgeback from a ROS desktop."], "package_details": ["To get started using Ridgeback from a desktop ROS environment, see", "."]},
{"url": "https://wiki.ros.org/melfa_description", "package": "melfa_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosclean", "package": "rosclean", "package_summary": ["rosclean: cleanup filesystem resources (e.g. log files)."], "package_details": ["will remove directories associated with storing ROS-related log files. You will be asked to confirm each deletion and it is important that you verify the command that", "executes is correct. Otherwise you"]},
{"url": "https://wiki.ros.org/robot_localization", "package": "robot_localization", "package_summary": ["Provides nonlinear state estimation through sensor fusion of an abritrary number of sensors."], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/slam_constructor", "package": "slam_constructor", "package_summary": [], "package_details": ["The SLAM constructor framework provides common functionality and classes that may be used to create custom SLAM algorithms (currently only 2D laser scan-based methods are supported). It also includes implementation of several SLAM algorithms", ",", "and", ", which can be used as a base of a new SLAM algorithm.", "Current implementation requires odometry data and laser scans to be provided by the ROS topics (see", "). It also supposes that a laser scanner is fixed in (0, 0) of a robot and mounted horizontally.", "Each algorithm is supplied with", "-files for the", "and", "datasets that give the idea of how to launch algorithms. The", "launch-files can be used in general case if data provided by a dataset do not require any preprocessing. For example, tinySLAM can be launched in the following way:", "In order to run an algorithm on data received in real time you can remove a dataset player node from a launch file, but make sure that sensor data are provided through", ".", "GMapping has the following additional parameters (note that", "shouldn't be provided or", "be", "), see", "documentation for details:", "The package provides the tool", "to launch algorithms in the offline mode to process", "datasets."]},
{"url": "https://wiki.ros.org/abb_resources", "package": "abb_resources", "package_summary": [], "package_details": ["This package is part of the", "program."]},
{"url": "https://wiki.ros.org/sensor_msgs", "package": "sensor_msgs", "package_summary": ["This package defines messages for commonly used sensors, including\n    cameras and scanning laser rangefinders."], "package_details": ["A number of these messages have ROS", "dedicated to manipulating them."]},
{"url": "https://wiki.ros.org/airbus_plugin_node_manager", "package": "airbus_plugin_node_manager", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/raspigibbon_msgs", "package": "raspigibbon_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/robotis_math", "package": "robotis_math", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_ikfast_left_arm_plugin", "package": "baxter_ikfast_left_arm_plugin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kurt_navigation_config", "package": "kurt_navigation_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/r2_moveit_generated", "package": "r2_moveit_generated", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/create_node", "package": "create_node", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/motoman_mpl_support", "package": "motoman_mpl_support", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kurt_navigation_slam", "package": "kurt_navigation_slam", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_mild_base_launch_files", "package": "asr_mild_base_launch_files", "package_summary": ["This package contains the launch files and different documents needed to start the system"], "package_details": ["Includes the mild.launch file which starts the", "node and the", "node.", "Also here you can adapt the parameters for the laserscanner and the speed up of the velocity (look at the", "and", "documentation)."]},
{"url": "https://wiki.ros.org/asr_mild_base_driving", "package": "asr_mild_base_driving", "package_summary": ["This package calculates and publishes the odometry information, transforms the velocity command into differential drive commands and writes it on the mild_base_driving bus"], "package_details": ["if you want to start the node with the mild.launch files.", "Get \"Ticks\" from the incremental encoder. Calculate the odometry from the ticks and publish them on the ROS-Topic /odom (", ").", "This picture shows you how a differential drive robot drives, with different wheel velocities (al and ar). If al > ar the robot drives a curve to the right. If al = ar the robot drives straight.", "- Dukenmotors Typ GR63x55 (", ")", "- Maxon motorcontroller (", ")", "cmd_vel (", ")", "odom (", ")", "Look at", "on how to adapt the parameters."]},
{"url": "https://wiki.ros.org/rqt_wrapper", "package": "rqt_wrapper", "package_summary": [], "package_details": ["Documentation and examples in the", "."]},
{"url": "https://wiki.ros.org/airbus_cobot_gui", "package": "airbus_cobot_gui", "package_summary": [], "package_details": ["Additionally the package", "includes a library to customise easily qt applications.", "The user can also call this launch file to run a different configuration, using the input parameters", "and", "The configuration of the cobot_gui can be defined via a", ":", "For further information about the parameters see:", "The user is allow to create and add new dashboards and plugins, by adding new entry lines to the dashboards_register.xml file and the plugins_register.xml. See the package", "as example.", "Where the", "l includes an entry for a new dashboard:", "The package", "define the python code of the qt level that will be popup inside your cobot_gui.", "Being the package", "where the plugin functions is defined."]},
{"url": "https://wiki.ros.org/interaction_cursor_3d", "package": "interaction_cursor_3d", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/motoman_config", "package": "motoman_config", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package is part of the", "program. It currently contains config files and meshes for the", "meta-package.", "See the", "page for an overview of the available tutorials."]},
{"url": "https://wiki.ros.org/motoman_experimental", "package": "motoman_experimental", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program. It contains experimental packages that will be moved to the", "repository once they've received sufficient testing and review.", "See the", "page for more information."]},
{"url": "https://wiki.ros.org/kingfisher_desktop", "package": "kingfisher_desktop", "package_summary": [], "package_details": ["Metapackage of desktop tools supporting", "."]},
{"url": "https://wiki.ros.org/photo", "package": "photo", "package_summary": ["The photo package provides access to digital cameras. Much of the underlying functionality is provide by the gPhoto libary. The system package libgphoto2-2-dev or equivalent is required.>"], "package_details": ["The photo package provides access to digital cameras. Much of the underlying functionality is provide by the", "libary. The system package libgphoto2-2-dev or equivalent is required.", "Calls the set_config service of photo_node and attempts to set the exptime parameter to", "."]},
{"url": "https://wiki.ros.org/prbt_pg70_support", "package": "prbt_pg70_support", "package_summary": ["PRBT support for Schunk pg70 gripper."], "package_details": []},
{"url": "https://wiki.ros.org/create_dashboard", "package": "create_dashboard", "package_summary": [], "package_details": ["The Create dashboard is part of the", ". Head over there to find out how to use it and what it can do."]},
{"url": "https://wiki.ros.org/kurt_2dnav", "package": "kurt_2dnav", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/move_base_to_manip", "package": "move_base_to_manip", "package_summary": [], "package_details": ["For mobile manipulators, this package calculates a robot base location where the end-effector (EE) can reach a desired pose (a.k.a. inverse reachability). The method is computationally fast (since it depends on a", "Cartesian motion plan), simple (~300 lines), and easy to use (requiring just a service to provide the desired pose).", "Below, the first image shows a mobile manipulator which is too far to grasp the object of interest. The desired EE pose is shown in green. The second image shows the freshly-calculated base position (red cube) which will allow the robot to reach that pose. <<Please ignore the bad camera calibration>>", "This package uses", "for base commands and", "for manipulator motion planning.", "^This launches a ROS service that will make a desired pose available to the move_base_to_manip node. It also displays this desired pose in Rviz. When the client sends", "on the service request, this node will shut down after providing the pose.", "^This node requests the desired pose from the other node. It then moves the end-effector to the desired height and orientation. From there, it plans a Cartesian move to the desired pose. The % completion of the Cartesian move informs the base on how far it must move. If the Cartesian move is able to complete 100%, the arm moves and the program exits. Otherwise, there is a call to", "to get closer to the object:", "The planner reads optional parameters on the", ". They can be adjusted from the command line, programmatically, or left as their default values. They are:", "*", ": A fraction between 0 and 1. A value of 1 means the EE will barely be able to reach the desired pose when fully extended. A value of 0 means the base motion will bring the EE to the desired pose without additional arm motion. Default: 0.15.", "*", ": Use a Cartesian motion for the final arm approach, or a regular", "motion? The Cartesian motion may be useful if your task requires the gripper to maintain a constant orientation (like grasping often does). Default: false, i.e. do a regular motion.", "*", ": Clear the octomap collision scene before the final arm approach? This is often necessary for grasping -- otherwise sensor noise/resolution may lead the robot to expect a collision. Default: true, i.e. the collision scene will be cleared.", "*", ": Clear the move_base costmaps before base motion? Default: true.", "*", ": Ask the user before making any motion? This is useful if you're just starting to use the package and aren't sure what to expect. Default: true.", "*", ": This is the \"request\" part of the service call. Can be used as a signal that the server can shutdown. Default: true (which I use to signal the pose provider node to shut down).", "*", ": A smaller number results in a more accurate prediction of the distance to the pose of interest. Default: 0.005m", "*", ": Default \"right_ur5\"", "*", ": Default \"RRTConnectkConfigDefault\"", "*", ": % of maximum robot speed for all arm motions. Default: 0.1", "*", ": Default \"base_link\"", "*", ": Position tolerance for arm motions. It may be useful to bump this up if you are having trouble finding plans. Default: 0.01 m", "*", ": Orientation tolerance for arm motions. Default: 0.0001 rad", "*", ": If true, the planner will try to flip the EE +/-180 deg about Z (i.e.", ") when it cannot reach a desired pose. Then it will attempt to plan again. Useful for 2-finger grippers. Default: true", "Here are some hints to get more suitable trajectories from", ":", "* Make sure the resolutions of your costmap and", "planners are fine enough to get the accuracy you require.", "Here are", "from the creator of", ".", "This package only calculates one base position which can reach the desired pose. If the base is not able to move there, it fails. However,", "has some built-in obstacle avoidance capabilities and if it fails, it will generally be close to the goal.", "* (untested) Use the", "package to calculate a good location for the manipulator's base. From the manipulator's position, calculate a mobile base location. This is the \"inverse reachability database\" approach."]},
{"url": "https://wiki.ros.org/neo_base_mp_500", "package": "neo_base_mp_500", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/linux_hardware", "package": "linux_hardware", "package_summary": [], "package_details": ["This functionality has been moved out in indigo in favour of using the standard drivers in the", "group."]},
{"url": "https://wiki.ros.org/apriltags_ros", "package": "apriltags_ros", "package_summary": [], "package_details": ["A ROS wrapper for the", ".", "The nodelet functions equivalently to the", "node."]},
{"url": "https://wiki.ros.org/asr_mild_navigation", "package": "asr_mild_navigation", "package_summary": ["The mild_navigation package. Launchfiles to start the navigation relevant nodes. Parameter for navigation and maps."], "package_details": ["The asr_mild_navigation uses the standard", "with some specific components. There are three overlay packages:", "Asr_move_base and asr_navcore are only needed if you use the asr_ftc_local_planner which is the standard local planner for the asr_mild_navigation. Look at the", "documentation on how to use and include the asr_move_base and asr_nav_core packages. The asr_ftc_local_planner implements a new local planner and is used instead of the", "or", ". The asr_navfn package includes an upgraded version of the standard navfn (check out the asr_navfn documentation). There are also two launch files to start the gazebo simulation with different rooms.", "There are also a launch file (launch/amcl_diff.launch\") to start", ", this is automaticly started if you launch \"launch/navigation.launch\"."]},
{"url": "https://wiki.ros.org/oculus_sdk", "package": "oculus_sdk", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/fake_odom", "package": "fake_odom", "package_summary": [], "package_details": ["To start the", "in a faked odometry mode the '_fake' launch files in wheeled_robin_bringup."]},
{"url": "https://wiki.ros.org/asr_flock_of_birds", "package": "asr_flock_of_birds", "package_summary": ["The asr_flock_of_birds package is the driver for Ascension Technology Corp magnet-tracking system \"Flock of Birds\". It provides the remote server which publishes two 6d posemarker and the nessesary TF from the magnettracking system. It also contains launchfiles and calibration tools for the use of it."], "package_details": ["magnet tracking system \"Flock of Birds\" is needed.", "The asr_flock_of_birds package is the driver for", "magnet tracking system \"Flock of Birds\" (FoB). It provides the remote server which publishes two 6d posemarker and the necessary TF from the magnet tracking system. It also contains launch-files and calibration tools for the use of it.", "Flock of Birds is a 6D tracking system which can very precisely track position and orientation of three sensors in a magnetic field in front of the receiver. Each tracker is connected to an data-glove and so only two trackers are used currently (for left and right hand). If started, the node publishes periodically the pose of the trackers as TF-publisher as well as", "-Messages on the", "-Topic.", "This package can be used as a standalone-driver for the Flock of Birds tracker system, but it is recommended to use it as a part of the", ".", "This package depends on", "-Package for the publication of the fob_objects.", "There are mainly two ways to start the Flock of Birds server: To start it directly form the PC which the hardware is connected with, use", "To start from another PC, the package provides a remote script. But Firstly, a ssh connection have to be set up. Secondly, use", "The launched Node publishes", "-Messages on the", "-Topic. There are no configuration or controlling elements."]},
{"url": "https://wiki.ros.org/rosruby_actionlib", "package": "rosruby_actionlib", "package_summary": [], "package_details": ["See", "."]},
{"url": "https://wiki.ros.org/atlas_v3_moveit_config", "package": "atlas_v3_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rosshell", "package": "rosshell", "package_summary": [], "package_details": ["is by default subscribed to /rosshellX/stdin and publishes at topic /rosshellX/stdout and /rosshellX/stderr, all of type", ".", "is just a simple commandline-calculator", "7830/2", "This package provides the two nodes, that enable to run and interact with different non-ros-programs.", "can be used to start a program or any kind of shell-command. If some kind of interaction with the programs is required, use", "to receive and send messages from stdin, stdout, and stderr.", "both are the same but you also have the possibility to change the command and topics, also within the launch-file, have a look at", "..."]},
{"url": "https://wiki.ros.org/create_description", "package": "create_description", "package_summary": ["Robot URDF descriptions for create_robot"], "package_details": ["This just stores the urdf's of the create base for the turtlebot. The actual application of the urdf's happen in", "where it is stitched together with the other turtlebot components."]},
{"url": "https://wiki.ros.org/rqt_dyn_tune", "package": "rqt_dyn_tune", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_description", "package": "mrp2_description", "package_summary": ["URDF and xacro description files for MRP2."], "package_details": []},
{"url": "https://wiki.ros.org/interaction_cursor_rviz", "package": "interaction_cursor_rviz", "package_summary": [], "package_details": ["You may also need", ", which unfortunately must go in a rosbuild workspace.", "You can add the option start_hydra:=false, or change the radius of the hydra workspace with radius:=<a number>.", "Please send bug reports, feature requests, etc. to the", "."]},
{"url": "https://wiki.ros.org/rosthrottle", "package": "rosthrottle", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neo_relayboard", "package": "neo_relayboard", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_analyzer", "package": "mrp2_analyzer", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jointstick", "package": "jointstick", "package_summary": ["Move any joint with any controller!"], "package_details": []},
{"url": "https://wiki.ros.org/ptu_control", "package": "ptu_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/android_apps", "package": "android_apps", "package_summary": [], "package_details": ["Applications for use with", ". Many of these are found on the", ". Refer to the", "page for more information."]},
{"url": "https://wiki.ros.org/iwaki", "package": "iwaki", "package_summary": [], "package_details": ["For more information and examples visit", "Source code is available at", ".", "Please send bug report to the", ". Feel free to use this issue tracker to contact us with questions and comments."]},
{"url": "https://wiki.ros.org/interaction_cursor_msgs", "package": "interaction_cursor_msgs", "package_summary": [], "package_details": ["These are structured in a similar way to", "Update/Feedback messages.", "In particular, a server application (such as interaction_cursor_demo) sends", "messages that are received by a client application (such as Rviz running the interaction_cursor_rviz display plugin). The client plugin is then responsible for sending feedback messages to the server.", "Please send bug reports, feature requests, etc. to the", "."]},
{"url": "https://wiki.ros.org/kurt_2dnav_slam", "package": "kurt_2dnav_slam", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/melfa_robot", "package": "melfa_robot", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav2_navigation", "package": "nav2_navigation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/modbus", "package": "modbus", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_robots", "package": "moveit_robots", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_cyberglove_lib", "package": "asr_cyberglove_lib", "package_summary": ["This package is used to start a server that provides the current joint state values received from the CyberGloves via ROS topics"], "package_details": ["Instead of using the preconfigured .launch-file, the server can also be started via", ", e.g. with:", "If the hardware is connected to a ROS Indigo Lab-PC and it is needed to start the asr_cyberglove_lib server from a remote ROS Kinetic Lab-PC, some workarounds / dirty hacks are needed. For the following, it is assumed that both ROS systems use the same file system and that the corresponding catkin workspaces are", "and", ".", "Open the terminal and source Kinetic (if not already sourced via ~/", "):", "Additional ssh environment setups are needed (", "):", "A ssh connection can now be established, but the ~/", "needs to be modified to be able to start the server on ROS Indigo:", "To listen to the publishing ROS-Topic in a new terminal, ROS Kinetic has to be sourced again (or modify the ~/", "again before opening the new terminal):", "Alternatively, the glove movements can also be visualized with the", "package (Kinetic needs to be sourced again):", "The sensor data of the Cybergloves are published as", "messages to the following topics:", "As mentioned in subsection 2.3, the asr_cyberglove_lib server can be started directly via", "without using the preconfigured .launch-file. For this case, it is needed to specify the", "arguments. The following arguments can be passed:"]},
{"url": "https://wiki.ros.org/rosruby_messages", "package": "rosruby_messages", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/rb1_base_gazebo", "package": "rb1_base_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kurt_navigation_global", "package": "kurt_navigation_global", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/interaction_cursor_demo", "package": "interaction_cursor_demo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/atlas_moveit_config", "package": "atlas_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/muse_bldc_motor_drive", "package": "muse_bldc_motor_drive", "package_summary": [], "package_details": ["<feedback_topic_name> (muse_bldc_motor_drive/feedback.msg)", "<control_commands_topic_name> (muse_bldc_motor_drive/control_cmd.msg)", "<state_machine_commands_topic_name> (muse_bldc_motor_drive/state_machine_cmd.msg)", "Now", "node publishes a list with Muse Drives that are visible on the network and is ready to listen to your commands."]},
{"url": "https://wiki.ros.org/airbus_coop", "package": "airbus_coop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neato_driver", "package": "neato_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_goal_builder", "package": "moveit_goal_builder", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "is a library for building", ".", "This is useful for when you want to use the", "actionlib interface directly, instead of using the", "class.", "This allows you to poll when the action is done, which the normal", "interface does not allow you to do."]},
{"url": "https://wiki.ros.org/baxter_moveit_config", "package": "baxter_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/clam_moveit_config", "package": "clam_moveit_config", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/eband_local_planner", "package": "eband_local_planner", "package_summary": ["eband_local_planner implements a plugin to the\n    base_local_planner. It implements the Elastic Band method on the\n    SE2 manifold."], "package_details": ["(", ", default: 0.1)", "(", ", default: 0.5)", "(", ", default: 0.7)", "(", ", default: 0.75)", "The original implementation for this ROS", "local planner only supported omni-directional (holonomic) robots.", "The current version was modified to work with differential drive machines. Set", "to", "to enable lateral/holonomic motion, but that mode has not been tested for a long time and should be considered experimental.", "This plugin runs inside the move_base process. Its parameter namespace is prefixed by that of", "and the", "name under which it was launched, typically", ", e.g.:"]},
{"url": "https://wiki.ros.org/mrp2_navigation", "package": "mrp2_navigation", "package_summary": ["Launch files, parameters and maps for different navigation applications."], "package_details": []},
{"url": "https://wiki.ros.org/infinisoleil", "package": "infinisoleil", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/alliance_msgs", "package": "alliance_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/r2_control", "package": "r2_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/apriltags", "package": "apriltags", "package_summary": [], "package_details": ["A catkin version of the"]},
{"url": "https://wiki.ros.org/gazebo_taskboard", "package": "gazebo_taskboard", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mtig_driver", "package": "mtig_driver", "package_summary": [], "package_details": ["Download the MT Software Suite and install it on a Windows machine (you may skip this step and use default sensor configuration), then download the MT SDK for Linux and install it on a Linux machine (this should be the machine that ROS is installed on). Here is the software website:", ".", "Follow the instructions in the MT SDK for Linux to install the software  and make sure the examples run correctly with the sensor. You may need to install the kernel available at", "."]},
{"url": "https://wiki.ros.org/nav2_driver", "package": "nav2_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lslidar_n301", "package": "lslidar_n301", "package_summary": [], "package_details": ["that this launch file launches both the driver and the decoder, which is the only launch file needed to be used.", "Bug Report Prefer to open an issue. You can also send an E-mail to", "."]},
{"url": "https://wiki.ros.org/r2_gazebo", "package": "r2_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav2_platform", "package": "nav2_platform", "package_summary": [], "package_details": ["The", "stack contains several component packages:", "To configure the", "robot for usage, you should edit the launch files located in the", "package. This is best done by cloning the package into your catkin workspace overlay, and making your changes locally:", "The Nav2 base can be controlled immediately by setting the appropriate IP/Hostname and port in the", "launch file. This launch file will start the", "node with the appropriate parameters, meaning that it will listen for Twist commands on the", "topic, and output the appropriate transforms and odometry messages on", "and", "respectively.", "To use the Nav2 with ROS navigation and mapping packages, you need to configure the sensor and appropriate parameters. Demo configurations for OpenNI (e.g. MS Kinect, Asus Xtion) and Hokuyo (i.e. URG-XX) compatible sensors are provided (but commented out) in the", "launch file."]},
{"url": "https://wiki.ros.org/neato_robot", "package": "neato_robot", "package_summary": [], "package_details": ["We are currently using the", "."]},
{"url": "https://wiki.ros.org/lslidar_c16", "package": "lslidar_c16", "package_summary": [], "package_details": ["This", "package is a linux ROS driver for lslidar c16 from Shenzhen Leishen Intelligence System Co, Ltd."]},
{"url": "https://wiki.ros.org/gazebo_interface", "package": "gazebo_interface", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/neato_node", "package": "neato_node", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/problib", "package": "problib", "package_summary": [], "package_details": ["Problib is a probabilistic library containing tools that can be used for representing or converting probabilistic information. It is part of the", "stack."]},
{"url": "https://wiki.ros.org/ompl_ros_interface", "package": "ompl_ros_interface", "package_summary": [], "package_details": ["To install this package, you will have to install the", "stack:", "Examples for how to setup and configure motion planners for your robot can be found in the accompanying", ".", "A quick example for use with the PR2 robot in simulation (Gazebo) can be found in the", "in Gazebo. Follow the instructions on that page to see ompl_ros_interface in action.", "The tabletop manipulation stacks in diamondback now use the ompl_ros_interface for planning using OMPL. To run these stacks on the PR2 robot, try the tabletop manipulation demo", "."]},
{"url": "https://wiki.ros.org/nav_core_adapter", "package": "nav_core_adapter", "package_summary": ["This package contains adapters for using `nav_core` plugins as `nav_core2` plugins and vice versa (more or less).\n      See README.md for more information."], "package_details": []},
{"url": "https://wiki.ros.org/raspigibbon_control", "package": "raspigibbon_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_object_manipulation", "package": "pr2_object_manipulation", "package_summary": [], "package_details": ["In general, PR2 specific implementations contained here will implement general interfaces defined in the", "stack. Contains PR2 specific launch files for using the manipulation functionality.", "To launch the manipulation pipeline complete with sensor input and execute pickup and place tasks using the PR2 robot, tutorials and launch files are provided in", "."]},
{"url": "https://wiki.ros.org/raspimouse_ros", "package": "raspimouse_ros", "package_summary": [], "package_details": ["\u65e5\u672c\u8a9e\u7248wiki\u306f", "\u3067\u3059\u3002"]},
{"url": "https://wiki.ros.org/nj_oa_costmap", "package": "nj_oa_costmap", "package_summary": [], "package_details": ["The", "package implements a navigating jockey for the Large Maps Framework (", ") that drives the robot while avoiding obstacles.", "It is based on a local map (", ").", "The local map has a fixed position relative to the robot but its orientation is constant in the world reference frame.", "It is a reactive, memory-less jockey.", "Moreover, the package provides the class", "that computes an appropriate", "from a", "in order to go as forward as possible while avoiding obstacles."]},
{"url": "https://wiki.ros.org/naoqi_libqi", "package": "naoqi_libqi", "package_summary": ["Aldebaran's libqi: a core library for NAOqiOS development"], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_desktop", "package": "mrp2_desktop", "package_summary": ["Visualization tools and configurations for MRP2 robot."], "package_details": []},
{"url": "https://wiki.ros.org/openslam_gmapping", "package": "openslam_gmapping", "package_summary": ["The catkinized verseion of openslam_gmapping package (https://github.com/OpenSLAM-org/openslam_gmapping/tree/79ef0b0e6d9a12d6390ae64c4c00d37d776abefb)"], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_desktop", "package": "mrp2_desktop", "package_summary": ["Visualization tools and configurations for MRP2 robot"], "package_details": []},
{"url": "https://wiki.ros.org/or_nodes", "package": "or_nodes", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pr2_gui", "package": "pr2_gui", "package_summary": ["Contains GUI tools for working with PR2s."], "package_details": []},
{"url": "https://wiki.ros.org/pendulum_msgs", "package": "pendulum_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/naoqi_msgs", "package": "naoqi_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/openrtm_aist_python", "package": "openrtm_aist_python", "package_summary": ["Python binding of OpenRTM-AIST"], "package_details": []},
{"url": "https://wiki.ros.org/pal_hardware_gazebo", "package": "pal_hardware_gazebo", "package_summary": ["The pal_hardware_gazebo package"], "package_details": []},
{"url": "https://wiki.ros.org/planning_interface", "package": "planning_interface", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/opencv_apps", "package": "opencv_apps", "package_summary": ["opencv_apps provides various nodes that run internally OpenCV's functionalities and publish the result as ROS topics. With opencv_apps, you can skip writing OpenCV application codes for a lot of its functionalities by simply running a launch file that corresponds to OpenCV's functionality you want"], "package_details": []},
{"url": "https://wiki.ros.org/new_riskrrt", "package": "new_riskrrt", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/osrf_testing_tools_cpp", "package": "osrf_testing_tools_cpp", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/plot_util", "package": "plot_util", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/myo_ros", "package": "myo_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/polled_camera", "package": "polled_camera", "package_summary": ["polled_camera contains a service and C++ helper classes for implementing a polled camera driver node and requesting images from it. The package is currently for internal use as the API is still under development."], "package_details": []},
{"url": "https://wiki.ros.org/place_matcher_csm", "package": "place_matcher_csm", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/object_manipulation", "package": "object_manipulation", "package_summary": [], "package_details": ["This stack provides the core-functionality for pick and place tasks, implemented in a robot-independent way. For details and documentation, see the", "package page.", "Complete applications of the functionality contained here on PR2 robot can be found, along with demos and launch files as well as documentation and tutorials, on the", "page.", "To launch the manipulation pipeline and execute pickup and place tasks using the PR2 robot, tutorials and launch files are provided on the", "page."]},
{"url": "https://wiki.ros.org/openni_launch", "package": "openni_launch", "package_summary": ["Launch files to open an OpenNI device and load all nodelets to \n     convert raw depth/RGB/IR streams to depth images, disparity images, \n     and (registered) point clouds."], "package_details": []},
{"url": "https://wiki.ros.org/raspigibbon_master_slave", "package": "raspigibbon_master_slave", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/openhrp3", "package": "openhrp3", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/panda_moveit_config", "package": "panda_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the panda with the MoveIt Motion Planning Framework"], "package_details": ["Documentation is available at", "."]},
{"url": "https://wiki.ros.org/raspigibbon_utils", "package": "raspigibbon_utils", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nj_costmap", "package": "nj_costmap", "package_summary": [], "package_details": ["The", "package implements a navigation jockey for the Large Maps Framework (", ") based on a local costmap such as those provided by the", "package (costmap position is relative to the sensor but orientation is absolute)."]},
{"url": "https://wiki.ros.org/mrp2_simulator", "package": "mrp2_simulator", "package_summary": ["Simulation-related packages for MRP2"], "package_details": []},
{"url": "https://wiki.ros.org/o3m151_driver", "package": "o3m151_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ompl", "package": "ompl", "package_summary": ["OMPL is a free sampling-based motion planning library."], "package_details": [". Please see", "on how to use it directly. Please see", "for more on motion planning.", "Please report issues / send contribution to", "."]},
{"url": "https://wiki.ros.org/raspigibbon_gazebo", "package": "raspigibbon_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/open_karto", "package": "open_karto", "package_summary": ["Catkinized ROS packaging of the OpenKarto library"], "package_details": []},
{"url": "https://wiki.ros.org/mrp2_hardware_gazebo", "package": "mrp2_hardware_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/r2_controllers_ros", "package": "r2_controllers_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/numatac_can_driver", "package": "numatac_can_driver", "package_summary": [], "package_details": ["The numatac_can_driver package provides a ROS interface to", "tactile sensors over a CAN interface. See", "for details.", "To bring up the", "tactile sensors, plug in the USB connector.  Configure the CAN interface by running the following command in a command line prompt:"]},
{"url": "https://wiki.ros.org/mrp2_gazebo", "package": "mrp2_gazebo", "package_summary": ["Launch files and simulation files to run MRP2 in Gazebo."], "package_details": []},
{"url": "https://wiki.ros.org/raspigibbon_apps", "package": "raspigibbon_apps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/openrtm_aist", "package": "openrtm_aist", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nanotron_swarm", "package": "nanotron_swarm", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/rangeonly_msgs", "package": "rangeonly_msgs", "package_summary": [], "package_details": ["This message is used to store range-only measurements between a pair of devices (i.e. distance measurements between two sensors). The message includes other kind of information like the type of range-only sensor technology (ultrsonic, radio-based, etc), the unique identifiers of the ranging sensors, etc. As an example, this message has been used with the", "driver for a radio-based range-only sensor in this", ".", "Use GitHub to", ". [", "]", "This package is part of", "stack. The package contains generic ROS messages for range-only sensors."]},
{"url": "https://wiki.ros.org/raspigibbon_sim", "package": "raspigibbon_sim", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav_core2", "package": "nav_core2", "package_summary": ["Interfaces for Costmap, LocalPlanner and GlobalPlanner. Replaces nav_core."], "package_details": []},
{"url": "https://wiki.ros.org/nao_msgs", "package": "nao_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/planning_models", "package": "planning_models", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/orocos_kdl", "package": "orocos_kdl", "package_summary": ["This package contains a recent version of the Kinematics and Dynamics\n    Library (KDL), distributed by the Orocos Project."], "package_details": []},
{"url": "https://wiki.ros.org/orrosplanning", "package": "orrosplanning", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/nav_msgs", "package": "nav_msgs", "package_summary": ["nav_msgs defines the common messages used to interact with the", "stack."], "package_details": []},
{"url": "https://wiki.ros.org/nav_grid_iterators", "package": "nav_grid_iterators", "package_summary": ["Iterator implementations for moving around the cells of a nav_grid in a number of common patterns."], "package_details": []},
{"url": "https://wiki.ros.org/nj_oa_laser", "package": "nj_oa_laser", "package_summary": [], "package_details": ["The", "package implements a navigating jockey for the Large Maps Framework (", ") that drives the robot while avoiding obstacles.", "It is based on a laser scan (", ").", "It is a reactive, memory-less jockey.", "Moreover, the package provides the class", "that computes an appropriate", "from a", "in order to go as forward as possible while avoiding obstacles."]},
{"url": "https://wiki.ros.org/openni2_launch", "package": "openni2_launch", "package_summary": ["Launch files to start the openni2_camera drivers using rgbd_launch."], "package_details": ["This package contains launch files for using OpenNI-compliant devices in ROS. It supports the Asus Xtion, Xtion Pro, and multiple version of the Primesense 1.08 and 1.09 cameras. It does NOT support any versions of the Kinect.", "or", "is the recommended package for using a Kinect with ROS.", "There is very little actual code/etc in openni2_launch, it is mostly a thin wrapper around", "and", ".", "More is documented"]},
{"url": "https://wiki.ros.org/nlj_dummy", "package": "nlj_dummy", "package_summary": [], "package_details": ["The role of this jockey is to demonstrate some functionalities of the Large Maps Framework (", ").", "The node", "starts two jockeys (", "servers): a localizing jockey and a navigating jockey.", "The localizing jockey (", ") generates 4 randoms integer values (", ") and stores them into the map.", "The navigating jockey (", ") prints on the console the edge it was asked to traversed and its associated descriptor, and waits a random time."]},
{"url": "https://wiki.ros.org/opencv3", "package": "opencv3", "package_summary": [], "package_details": ["will only pull in", "as an extra dependency while", "will also pull in", ",", "and", "so it depends on whether you go for something small or something you need.", "Since Indigo, there is a package for OpenCV3. It contains the", "and", "repos from", ". Some modules might not get included because the dependencies are hard to package for all platforms (e.g. the optical character recognition module that needs tesseract).", "Since Kinetic, OpenCV3 is the default. Discussion happened on", ".", "Switching code to OpenCV3 can be done following the official guide at", ".", "The rosdep key is", ".", "Also, if you write OpenCV3 code, chances are high that it will also compile with OpenCV 2.4.9+. E.g., in color conversion, when replacing", "by", ", your code will also compile in OpenCV2 as this API has been backported (and not documented ...).", "Instead of depending on", ", you should depend on", "or", ". Depending on one of those two keys transitively makes you depend on", "on Jade and below, or", "on Kinetic and above.", "Then, just download the opencv3-release repo at", "and:"]},
{"url": "https://wiki.ros.org/nj_escape_crossing", "package": "nj_escape_crossing", "package_summary": [], "package_details": ["The", "package implements a navigating jockey for the Large Maps Framework (", ") which role is to drive the robot away from the crossing center, where the robot is awaited to be when the jockey is started."]},
{"url": "https://wiki.ros.org/naoqi_libqicore", "package": "naoqi_libqicore", "package_summary": ["Aldebaran's libqicore: a layer on top of libqi"], "package_details": []},
{"url": "https://wiki.ros.org/prosilica_driver", "package": "prosilica_driver", "package_summary": [], "package_details": ["ROS driver and SDK for AVT/Prosilica GigE cameras. See", "for usage and tutorials.", "Prior to Fuerte, these packages resided in", ".", "This stack works with Allied Vision Tech / Prosilica", "."]},
{"url": "https://wiki.ros.org/nj_laser", "package": "nj_laser", "package_summary": [], "package_details": ["The", "package implements a navigation jockey for the Large Maps Framework (", ") based on a", "."]},
{"url": "https://wiki.ros.org/openni2_camera", "package": "openni2_camera", "package_summary": ["Drivers for the Asus Xtion and Primesense Devices. For using a kinect\n  with ROS, try the"], "package_details": ["This package contains launch files for using OpenNI-compliant devices in ROS. It supports the Asus Xtion, Xtion Pro, and multiple version of the Primesense 1.08 and 1.09 cameras. It does NOT support any versions of the Kinect.", "or", "is the recommended driver for using a Kinect with ROS.", "It is recommended to use this driver through the launch files provided in"]},
{"url": "https://wiki.ros.org/openni_tracker", "package": "openni_tracker", "package_summary": [], "package_details": ["is now a unary stack. Previously it was a package in", ".", "- Independent node that does not require other nodes to run (however, make sure your", "is powered. For example, on", ",", "needs to be run successfully).", "Once running, stand in front of the Kinect and surrender (i.e. hit the", ". You should see some variation on the following messages.", "The user's pose will be published as a set of transforms (", ") with the following frame names."]},
{"url": "https://wiki.ros.org/python_orocos_kdl", "package": "python_orocos_kdl", "package_summary": ["This package contains the python bindings PyKDL for the Kinematics and Dynamics\n    Library (KDL), distributed by the Orocos Project."], "package_details": []},
{"url": "https://wiki.ros.org/pyros", "package": "pyros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libvlfeat", "package": "libvlfeat", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pal_gazebo_plugins", "package": "pal_gazebo_plugins", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/opencv2", "package": "opencv2", "package_summary": [], "package_details": ["For documentation on OpenCV, please see the", ". For additional libraries to help you use OpenCV with ROS, please see the", "package and", "stack.", "If your issue is related to the OpenCV packaged in ROS (it is too old, you would like to see a backport in there ...), please file a bug using the link at", "."]},
{"url": "https://wiki.ros.org/ompl_visual_tools", "package": "ompl_visual_tools", "package_summary": [], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/lama_test", "package": "lama_test", "package_summary": [], "package_details": ["The", "package provides a few launch files to test the functionalities of the Large Maps Framework (", ").", "To test the high-level node", ":"]},
{"url": "https://wiki.ros.org/lj_laser_heading", "package": "lj_laser_heading", "package_summary": [], "package_details": ["The", "package implements a localizing jockey that computes place dissimilarities based on a", "and absolute heading.", "The behavior and properties are similar to those of the", "jockey.", "The heading is given either as", "or", ".", "The role of this jockey is to get the dissimilarity of the", "descriptor of all vertices with the current place profile (represented by a", ").", "The action is done when the dissimilarities are computed.", "Implemented actions:"]},
{"url": "https://wiki.ros.org/openni_camera", "package": "openni_camera", "package_summary": ["A ROS driver for OpenNI depth (+ RGB) cameras. These include: \n       Microsoft Kinect,\n       PrimeSense PSDK,\n       ASUS Xtion Pro and Pro Live\n\n    The driver publishes raw depth, RGB, and IR image streams."], "package_details": ["Note: This is the", "for your usage of openni_camera / openni_launch for Kinect in ROS. You have to firstly install the Driver for Kinect on Ubuntu and make sure your kinect can work properly on ubuntu.", "To get started, please Refer", "and you may meet some incompatible contents, do not worry, the thought and path is correct.", "The very important doc you should read carefully is that on", "and that on", "."]},
{"url": "https://wiki.ros.org/kinect_2d_scanner", "package": "kinect_2d_scanner", "package_summary": [], "package_details": ["are considered and the minimum distance is kept in each direction. The horizontal FOV of the frustum is automatically computed from the intrinsic parameters of the range camera, but the vertical FOV must be provided by the user, and", "which may be useful depending on the zone of interest where to look for obstacles. See", "for an illustration of the frustum geometry and 3D obstacle points.", "The node", "makes easy to connect to a Kinect sensor and publish equivalent 2D \"fake laser\" scans.", "Internally, the node uses", "which in turn uses", "to directly open the sensor. Since only 2D scan data is published here, you should employ this node only if you won't need the 3D points.", "All spatial transformations are riguorously taken into account in this class, using the depth camera intrinsic calibration parameters.", "should be provided in the format expected by MRPT (explain me!), but default values will be used otherwise.", "Read", "for more details.", "This node implements the", "interface."]},
{"url": "https://wiki.ros.org/lama_jockeys", "package": "lama_jockeys", "package_summary": [], "package_details": ["In the case that the functionalities of a jockey cannot be described by the predefined actions", ",", ", and", ", the jockey can be based on the", "class instead.", "Basic map and jockey functionalities are already implemented.", "The", "package provides base class for Learning, Localizing, Navigating, and custom jockeys for the Large Maps Framework (", ").", "A jockey provides a specific capability to the robot.", "These modules are called jockeys since, in a certain sense, they are riding the robot.", "It means that these modules have direct access to the robot hardware and are able to control the robot's actuators, to read its sensors and to process raw data gathered from its sensors.", "The jockeys are", "servers.", "The", "packages provides standard action messages for Learning, Localizing, and Navigating jockeys.", "The", "provides the mechanisms to interfere with the map in the form of the member variable", ". For example, to get the vertex with id 243 from the map, one can write:", "The three subclasses", ",", ", and", "handle reception of the goal, which is then stored in the", "member variable. Upon goal reception, one specific function is called. Most of these functions are implemented are pure virtual method, so that the jockey implementer must only define these methods to have a working jockey. A default implementation is provided for the common actions", "(", ") and", "(", "), they only manage to pause the stop watch which is otherwise running when an action is running.", "The user must implement", "and", ".", "The user must implement", ",", ", \"", "\",", "\",", ".", "The user must implement", "and", "."]},
{"url": "https://wiki.ros.org/innok_heros_control", "package": "innok_heros_control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/pykdl_utils", "package": "pykdl_utils", "package_summary": [], "package_details": ["For running all of the unit tests, you can either pass a URDF xml file to use or leave it blank and have the URDF pulled from the parameter", "on the parameter server."]},
{"url": "https://wiki.ros.org/map_ray_caster", "package": "map_ray_caster", "package_summary": [], "package_details": ["provides a cached ray casting on a map, such as those provided by", "of the Large Maps Framework (", ").", "provides a cached ray casting on a map, such as those provided by", ". The origin of all rays is fixed relative to the map, it is the map center. It takes as input a costmap (", ") and returns a laser scan (", "). The ray casting will be from", "to", ". Moreover, other value of the input scan are used so that the scan message must be initialized with non-default values.", "To use the", "class to compute a fake", "from an occupancy grid in C++:"]},
{"url": "https://wiki.ros.org/jaguar_msgs", "package": "jaguar_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jaguar_navigation", "package": "jaguar_navigation", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jaguar_description", "package": "jaguar_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/innok_heros_gazebo", "package": "innok_heros_gazebo", "package_summary": [], "package_details": ["The robot model was successfully tested with Gazebo6 thus", ". To install Gazebo6 see", "."]},
{"url": "https://wiki.ros.org/aras_visual_servo_controller", "package": "aras_visual_servo_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ackermann_controller", "package": "ackermann_controller", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lpms_imu", "package": "lpms_imu", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/innok_heros_lights", "package": "innok_heros_lights", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/look_at_pose", "package": "look_at_pose", "package_summary": [], "package_details": ["This camera has a rough initial alignment with the object of interest (the pink cylinder) and it is nearly upside-down. The pose returned from a call to look_at_pose is well-aligned and the camera is upright.", "or, clone and build from", ".", "In RViz, turn on", "and", "(topic: visualization_marker) to see the original camera frame, new camera frame, and point of interest.", "*", ":  The current pose of the camera. This should  be point (0,0,0) and quaternion (0,0,0,1) in the camera's own frame.", "*", ": Where should the camera look? The orientation actually isn't used.", "*", ": A vector that defines \"UP.\" If Z of the camera frame is up, then it would be (0,0,1).", "The service response is another", "in the initial camera frame:", "*", "It's currently assumed that X is the \"lens vector\" of the camera and Z of the camera frame should point up. If your situation requires something else, please create an issue on the", "."]},
{"url": "https://wiki.ros.org/lj_costmap", "package": "lj_costmap", "package_summary": [], "package_details": ["The", "package is a localizing jockey for the Large Maps Framework (", ") that computes place dissimilarities based on a local cost map, such as those obtained from the", "package.", "The role of this jockey is to get the dissimilarity of the", "descriptors of all vertices with the current place profile.", "The action is done when the dissimilarities are computed.", "Implemented actions:"]},
{"url": "https://wiki.ros.org/anj_featurenav", "package": "anj_featurenav", "package_summary": [], "package_details": ["implements a feature-based learning and navigating jockey based on free OpenCV feature descriptor and matcher. The package defines the feature extractor and the descriptor matcher functions required by the", "package to obtain a working couple learning/navigating jockeys.", "The SimpleBlog algorithm takes no parameter, cf.", ".", "The FlannBased algorithm takes no parameter, cf.", "."]},
{"url": "https://wiki.ros.org/dfs_explorer", "package": "dfs_explorer", "package_summary": [], "package_details": ["The", "package implements the node", "which is an explorer with depth-first-search-like algorithm for finite worlds for the Large Maps Framework (", "). It proceeds as follows:", "A test launch file can be found in the", "package:"]},
{"url": "https://wiki.ros.org/lkh", "package": "lkh", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/log_server", "package": "log_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/goto_crossing", "package": "goto_crossing", "package_summary": [], "package_details": ["The goto_crossing provides a Go-To-Goal behavior to reach the center of a crossing (", "message) for the Large Maps Framework (", ").", "The goto_crossing provides a Go-To-Goal behavior to reach the center of a crossing (", "message).", "Launch the node with", ".", "To use the", "as class instance, one uses", "to compute the twist necessary to reach the crossing center:"]},
{"url": "https://wiki.ros.org/cassandra_ros", "package": "cassandra_ros", "package_summary": [], "package_details": ["partitioner is required to retrieve requested data ordered, otherwise it will appear. For more information, have look on the documentation on", "8003/1", "Then change the Cassandra partitioner to \"", "\", which can be set in", "partitioner: org.apache.cassandra.dht.", "The option -f hinders Cassandra to start a deamon in backgroud, for more information and help visit :", "Check the following link:", "How does it work? If you take a look into cassandra_ros/lib ... you will see a couple of files in the form of", "_'format'.py, which are all descendants of", "_.py. And each of them overwrites the methods:", "As you could see so far, you only work with the single class of", ". In fact, this class inherits those methods, required for encoding and decoding of messages, and only those of the required parent class. If you are seeking for more information, have a look at the follwing link:", "If you want to analyze your data by using CQL, the", ", you will have to generate at first secondary indexes. Because this might be expensive and not required for every part of a message, this has to be done manually, as follows:", "For more information on CQL, check the following website:"]},
{"url": "https://wiki.ros.org/innok_heros_description", "package": "innok_heros_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/joystick_sdl", "package": "joystick_sdl", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lj_laser", "package": "lj_laser", "package_summary": [], "package_details": ["The", "package is a localizing jockey for the Large Maps Framework", "(", ") that computes place dissimilarities based on a", "360-degree", "."]},
{"url": "https://wiki.ros.org/lkh_solver", "package": "lkh_solver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/aras_visual_servo_camera", "package": "aras_visual_servo_camera", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/featurenav_base", "package": "featurenav_base", "package_summary": [], "package_details": ["provides base class for feature-based navigation for the Large Maps Framework (", "). Feature-based navigation implement the base functionalities of two jockeys. The first one, the learning jockey learns a path while the robot is driving externally. The learned path is a series of image descriptors with extra information. The second one, the navigating jockey can then drive the robot and follow this path."]},
{"url": "https://wiki.ros.org/lama_interfaces", "package": "lama_interfaces", "package_summary": [], "package_details": ["provides the interfaces to the database as ROS services for the Large Maps Framework (", ").", "provides the interfaces to the database as ROS services.", "The data storage is realized through a database. All databases supported by Python sqlalchemy can be used. The default database is an SQLite database which will be save as", ". The environment is represented as a directed graph, where vertices are points of interest such as crossings. Descriptors can be associated to vertices and edges, they give some information about the environment, so that jockeys can localize or drive the robot. Any ROS message can be saved as descriptor after a trivial implementation of two services (srv files), one to write the descriptor into the database and one to retrieve it. Other variable types can use the", "message type. Descriptor storage occurs either in binary or clear-text mode.", "The first node that should be used when working with the LaMa Framework is", ":", "This node will run several services:", ",", ",", ", and", ", which are described in further sections.", "This service of type", "is used for all actions over vertices and edges in the map.", "This service of type", "is used to generate two services for each descriptor type, one to write the descriptor into the database and one to retrieve it. Descriptor storage occurs either in binary or clear-text mode (specified through the", "service attribute. The name of these two services will be the name of the interface (", "attribute) to which \"", "\" or \"", "\" are added.", "For example, to create a clear-text interface for", "in C++:", "To add a database interface in Python, one can either use the", "service or call the equivalent Python function. For example, for a \"", "\" descriptor with binary storage:", "The services", "and", "provide direct access to the graph vertices or edges. These functionalities are provided by the", ", which should be preferred."]},
{"url": "https://wiki.ros.org/lama_msgs", "package": "lama_msgs", "package_summary": [], "package_details": ["contains messages that represent places for the Large Maps Framework (", ").", "contains messages that represent places. These messages are used as descriptors for vertices.", "Newly proposed, mistyped, or obsolete package. Could not find package \"lama_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/lama_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/ardrone2islab", "package": "ardrone2islab", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/local_map", "package": "local_map", "package_summary": [], "package_details": ["provides a simple local cost map for several jockeys for the Large Maps Framework (", "). The map is centered on the frame of the laser range finder on which it is based but its orientation is fixed.", "The image shows the map in player on the left and the local map obtained from the LaserScan (red dots) on the right. The robot's orientation is approximately 45\u00b0 but the map's orientation is fixed."]},
{"url": "https://wiki.ros.org/crossing_detector", "package": "crossing_detector", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"crossing_detector\" in rosdoc: /var/www/docs.ros.org/en/api/crossing_detector/manifest.yaml", "The", "package implements a method to recognize a crossing, i.e. a place from where the robot can take clearly distinctive paths. It is part of the Large Maps Framework (", ").", "The computation is based on a costmap such as those provided by the", "package, a", "message, or a", "message. It is meant to be used in the form of a class instance but two nodes are provided that compute a", "from a", "or a", ", respectively, as a service.", "Packages", "and", "use the functionalities provided by the", "package and can be used as example."]},
{"url": "https://wiki.ros.org/kobuki_led_controller", "package": "kobuki_led_controller", "package_summary": [], "package_details": ["Python library to control", "LEDs."]},
{"url": "https://wiki.ros.org/aras_visual_servo_gazebo", "package": "aras_visual_servo_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lama_common", "package": "lama_common", "package_summary": [], "package_details": ["provides functionalities to convert messages of the", "package to other ROS messages and to visualize these messages in rviz. It belongs to the Large Maps Framework (", ").", "provides functionalities to convert messages of the", "package to other ROS messages and to visualize these messages in", "."]},
{"url": "https://wiki.ros.org/lost_comms_recovery", "package": "lost_comms_recovery", "package_summary": [], "package_details": [": Instead of relying on this this feature, you're better off with motor control software that sets zero velocity after a certain amount of time not receiving any new commands.", "If move_base is not running when communication failure occurs then motors and joysticks are set to zero by publishing a zero", "message and a zero", "message."]},
{"url": "https://wiki.ros.org/glkh_solver", "package": "glkh_solver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jaco_gazebo", "package": "jaco_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/homer_gui", "package": "homer_gui", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/image_publisher", "package": "image_publisher", "package_summary": [], "package_details": ["provides a node/nodelets for publishing image as a ROS image topic."]},
{"url": "https://wiki.ros.org/imu_complementary_filter", "package": "imu_complementary_filter", "package_summary": ["Filter which fuses angular velocities, accelerations, and (optionally) magnetic readings from a generic IMU device into a quaternion to represent the orientation of the device wrt the global frame. Based on the algorithm by Roberto G. Valenti etal. described in the paper \"Keeping a Good Attitude: A Quaternion-Based Orientation Filter for IMUs and MARGs\" available at http://www.mdpi.com/1424-8220/15/8/19302 ."], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/image_transport_plugins", "package": "image_transport_plugins", "package_summary": ["A set of plugins for publishing and subscribing to sensor_msgs/Image topics\n    in representations other than raw pixel data. For example, for viewing a\n    stream of images off-robot, a video codec will give much lower bandwidth\n    and latency. For low frame rate tranport of high-definition images, you\n    might prefer sending them as JPEG or PNG-compressed form."], "package_details": ["contains plugins to", "for sending", "topics in compressed representations. Its contents include:", "These transports will only be available if the plugins are built on your system! On Ubuntu, they are included in the", "deb for each distribution. If building from source, you must explicitly build the", "stack."]},
{"url": "https://wiki.ros.org/image_cb_detector", "package": "image_cb_detector", "package_summary": ["Provide a node that extracts checkerboard corners from ROS images.\n    This package is still experimental and unstable.\n    Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/laser_cb_detector", "package": "laser_cb_detector", "package_summary": ["Extracts checkerboard corners from a dense laser snapshot.\n     This package is experimental and unstable. Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/image_transport", "package": "image_transport", "package_summary": ["image_transport should always be used to subscribe to and publish images. It provides transparent\n     support for transporting images in low-bandwidth compressed formats. Examples (provided by separate\n     plugin packages) include JPEG/PNG compression and Theora streaming video."], "package_details": ["should always be used to publish and subscribe to images. At this basic level of usage, it is very similar to using ROS Publishers and Subscribers. Using", "instead of the ROS primitives, however, gives you great flexibility in how images are communicated between nodes.", "publishers advertise individual ROS", "for each available transport - unlike ROS Publishers, which advertise a single topic. The topic names follow a standard naming convention, outlined below. Note, however, that all code interfaces take only a \"base topic\" name (to which the transport type is automatically appended); typically you should not directly reference the transport-specific topic used by a particular plugin.", "does not yet support Python, though it is on the", ". If you need to interface a Python node with some compressed image transport, try interposing a", "node.", "publishers are used much like ROS Publishers, but may offer a variety of specialized transport options (JPEG compression, streaming video, etc.). Different subscribers may request images from the same publisher using different transports.", "publishers advertise individual ROS", "for each available transport - unlike ROS Publishers, which advertise a single topic. The topic names follow a standard naming convention, outlined below. Note, however, that all code interfaces take only a \"base topic\" name; typically you should not directly reference the transport-specific topic used by a particular plugin.", "publishers have no independent parameters, but plugins are permitted to make use of the", "for configuration options, e.g. bit rate, compression level, etc. See the plugin package documentation.", "subscribers are used much like", "'s", ", but may use a specialized transport to receive images.", "may be used to specify a different namespace for parameter lookup. This is useful to remap", "into a separate namespace to allow different transports for different image subscriptions. The node writer may even specify a parameter name other than", ", although this is discouraged for the sake of consistency. Nodes that subscribe to image topics should document what parameter(s) control transport, especially if different from", ".", "itself does not make use of the", ". Plugins may read or set plugin-specific parameters, however.", "lists the declared image transport options across all ROS packages and attempts to determine whether they are currently available for use (packages built, plugins able to be loaded properly, etc.).", "When working with images we often want specialized transport strategies, such as using image compression or streaming video codecs.", "provides classes and nodes for transporting images in arbitrary over-the-wire representations, while abstracting this complexity so that the developer only sees", "messages.", "Specialized transports are provided by plugins.", "itself provides only", "transport so as not to impose unnecessary dependencies on client packages. Other transports will only be available if they are built on your system. On Ubuntu, the", "debians include the", "and", "transports provided by the", "stack.", "For complete examples of publishing and subscribing to images using", ", see the", ".", "If you have implemented a new transport option in a public repository and would like to see it added to this list, please email our", ".", "ROS Publishers and Subscribers are used to transport messages of any type.", "offers publishers and subscribers specialized for images. Because they encapsulate complicated communication behavior,", "publishers and subscribers have a public ROS API as well as a C++ code API. Please see the separate", "documentation for C++ usage. The ROS API is documented below.", "C++:", "(", "),", "(", ")", "The raw", "is published on the base topic, just as with using a normal", ". If additional plugins are available, they advertise subtopics of the base topic, conventionally of the form", ". For example, using plugins for", "and", "transports, with a base topic of", ", the topics would be:", "Publisher plugin parameters give subscribers hooks to configure the publisher-side encoding to suit the needs on the client side. Lookup therefore occurs in the public namespace defined by", ", rather than the private namespace of the publishing node. Note that these parameters are a shared resource, controlling the behavior observed by all subscribers to the image topic.", "C++:", "(", "),", "(", ")", "A", "instance is created with a \"base topic\" name and the name of the transport to use. It subscribes to the transport-specific ROS topic associated with the base topic. For example, if the base topic is", ", the subscribed topics for transports", "and", "are respectively:", "If this parameter is not set, the transport from the", "argument of", "is used.", "Subscriber plugins are permitted to make use of the", "for configuration options, e.g. video post-processing level. See the plugin package documentation.", "Subscriber plugin parameters configure the behavior of one particular subscriber. They affect how the data received is interpreted (decoded). This differs from publisher plugin parameters, which are a shared resource affecting the data sent to all subscribers. The namespace used for parameter lookup is again specified through", ", defaulting to the private namespace of the subscribing node."]},
{"url": "https://wiki.ros.org/libntcan", "package": "libntcan", "package_summary": ["This package wraps the libntcan to use it as a ros dependency."], "package_details": []},
{"url": "https://wiki.ros.org/jaco_msgs", "package": "jaco_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/image_proc", "package": "image_proc", "package_summary": ["Single image rectification and color processing."], "package_details": []},
{"url": "https://wiki.ros.org/image_view", "package": "image_view", "package_summary": ["A simple viewer for ROS image topics. Includes a specialized viewer\n  for stereo + disparity images."], "package_details": []},
{"url": "https://wiki.ros.org/joint_states_settler", "package": "joint_states_settler", "package_summary": ["Provides a node that reports how long a subset of joints has been\n     settled. That is, it calculates how long a set of joints has remained\n     within a specified threshold. This package is experimental and unstable.\n     Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/image_pipeline", "package": "image_pipeline", "package_summary": ["image_pipeline fills the gap between getting raw images from a camera driver and higher-level vision processing."], "package_details": ["The", "stack is designed to process raw camera images into useful inputs to vision algorithms: rectified mono/color images, stereo disparity images, and stereo point clouds. Components include:", "The image pipeline will work with any conforming ROS camera driver node. See", "for cameras already supported in ROS. The minimal requirements for such a node are:", "Camera drivers normally have parameters (exposure, gain, etc.) that you can configure at runtime.", "has runtime-configurable stereo processing parameters of its own. The", "is useful for tweaking your configuration to get best results."]},
{"url": "https://wiki.ros.org/ir_trans_drivers", "package": "ir_trans_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/imu_drivers", "package": "imu_drivers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libphidgets", "package": "libphidgets", "package_summary": ["This package wraps the libphidgets to use it as a ros dependency"], "package_details": ["The following doc might be significantly outdated. Please consider contributing to update it."]},
{"url": "https://wiki.ros.org/kdl_conversions", "package": "kdl_conversions", "package_summary": ["Conversion functions between KDL and geometry_msgs types."], "package_details": []},
{"url": "https://wiki.ros.org/laser_drivers", "package": "laser_drivers", "package_summary": [], "package_details": ["contains a", "for Leuze rotoScan ROD-4 laser range-finders."]},
{"url": "https://wiki.ros.org/kdl", "package": "kdl", "package_summary": [], "package_details": ["See the", "The \"rosmake\" command checks out code from the KDL svn repository (see", ").", "KDL is a 3rd party library that is part of the Orocos project", "."]},
{"url": "https://wiki.ros.org/mk", "package": "mk", "package_summary": ["A collection of .mk include files for building ROS architectural elements.\n    Most package authors should use cmake .mk, which calls CMake for the build of the package.\n    The other files in this package are intended for use in exotic situations that mostly arise when importing 3rdparty code."], "package_details": ["when using", "to find the", "-package, the", "needs to be set accordingly. Thus, you should have a dependency to", "in your", ", as this provides the respective", "that set this.", "Most packages, and all stacks, use CMake to build. But every package must provide a", "if it does any building.  The following files are provided to simplify the", "in most packages, and all stacks:", "Use these files by including them, as explained in the", "and", ".", "For a 3rdparty package that pulls code from an tarball (or equivalent downloadable file), you should use", ", like so:", "The following variables should be defined prior to including", ":", "After including", ", you can make targets depend on the", "file; it will be created (and updated) after the tarball has been downloaded, unpacked, and (optionally) patched.", "Some packages that use", ":", "For a 3rdparty package that pulls code from an SVN repository, you should use", ", like so:", "The following variables should be defined prior to including", ":", "After including", ", you can make your targets depend on the", "file; it will be created after the working copy is checked out and (optionally) patched.", "Some packages that use", ":", "Similar to", ", there are also:", "These are based on", ", so you can generally use them by substituting the appropriate three-letter abbreviation for", ".", "svn checkouts are both slow and more prone to downtime.  A hybrid approach using the tarball for distribution, and a fancy makefile can be done with a script like the", "package", "This uses the svn_checkout script to build the tarball when developing, but most users simply use the tarball."]},
{"url": "https://wiki.ros.org/monocam_settler", "package": "monocam_settler", "package_summary": ["Listens on a ImageFeatures topic, and waits for the data to settle.\n     This package is experimental and unstable.\n     Expect its APIs to change."], "package_details": []},
{"url": "https://wiki.ros.org/image_common", "package": "image_common", "package_summary": ["Common code for working with images in ROS."], "package_details": []},
{"url": "https://wiki.ros.org/knowrob_common", "package": "knowrob_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/knowrob_omics", "package": "knowrob_omics", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/jackal_firmware", "package": "jackal_firmware", "package_summary": [], "package_details": ["The", "package distributes", "'s proprietary firmware binary from Clearpath Robotics.", "See", "for details, and", "for flashing instructions."]},
{"url": "https://wiki.ros.org/imu_filter_madgwick", "package": "imu_filter_madgwick", "package_summary": ["Filter which fuses angular velocities, accelerations, and (optionally) magnetic readings from a generic IMU device into an orientation. Based on code by Sebastian Madgwick, http://www.x-io.co.uk/node/8#open_source_ahrs_and_imu_algorithms."], "package_details": ["Use GitHub to", ". [", "]", "The", "package is used to filter and fuse raw data from IMU devices. It fuses angular velocities, accelerations, and (optionally) magnetic readings from a generic IMU device into an orientation quaternion, and publishes the fused data on the", "topic. The package has been tested using the raw data output of a Phidgets IMU (Spatial 3/3/3) device. The package is a wrapper of Sebastian Madgwick's IMU filter [1].", "Two drivers are available:", "and", ". Their parameters and topics are identical.", "[1]"]},
{"url": "https://wiki.ros.org/libg2o", "package": "libg2o", "package_summary": ["The libg2o library from http://openslam.org/g2o.html"], "package_details": ["See:"]},
{"url": "https://wiki.ros.org/json_prolog", "package": "json_prolog", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libndds51-dev", "package": "libndds51-dev", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/mod_vis", "package": "mod_vis", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kramdown", "package": "kramdown", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/moveit_docs", "package": "moveit_docs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libpcan", "package": "libpcan", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lizi", "package": "lizi", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/knowrob_mongo", "package": "knowrob_mongo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/lifecycle", "package": "lifecycle", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ias_knowledge_base", "package": "ias_knowledge_base", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/kinematics_base", "package": "kinematics_base", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/libraspberrypi-dev", "package": "libraspberrypi-dev", "package_summary": [], "package_details": ["If you're creating additional documentation for a package or stack, feel free to structure them however you like, but please keep them within the namespace of your package (e.g. \"ros.org/wiki/my_package/more_details\")", "Once you save that page, it will have a \"Create Tutorial\" button that you can use to create new tutorial pages which will be automatically indexed and easier for users to find. Also the", "page outlines how to write a tutorial.", "If none of these cover your situation, you can create a blank page"]},
{"url": "https://wiki.ros.org/audio_common_msgs", "package": "audio_common_msgs", "package_summary": ["Messages for transmitting audio via ROS"], "package_details": ["See", "for usage."]},
{"url": "https://wiki.ros.org/audio_play", "package": "audio_play", "package_summary": ["Outputs audio to a speaker from a source node."], "package_details": ["See", "for usage."]},
{"url": "https://wiki.ros.org/baxter_maintenance_msgs", "package": "baxter_maintenance_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_gazebo", "package": "baxter_gazebo", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_object_database", "package": "asr_object_database", "package_summary": ["This package is used to store and provide objects and their information which can be used by other packages like object recognizers"], "package_details": ["There are several services this package offers to access the object models which are stored in the", "directory located at the base path of it. Inside this directory in", "there are subdirectories which group the objects together based on their usage (mostly depending on the recognizer which is used to detect them in a scene). Take note that groups and their objects within can only be queried by services if they are declared in config.xml in the", "directory. This doesn't apply for example to the environment objects, which are only used for visualization purposes by other packages; they can be accessed by specifying the path to them directly without any service call."]},
{"url": "https://wiki.ros.org/asctec_hl_firmware", "package": "asctec_hl_firmware", "package_summary": [], "package_details": ["You need to flash the HLP with a custom firmware (", ") which is provided in this package. Flash the HLP following the instructions in the AscTec", "."]},
{"url": "https://wiki.ros.org/asr_ros_uri", "package": "asr_ros_uri", "package_summary": ["The asr_ros_uri package delivers functionality equally to resource_finder.\n    With one exception: It doesn't load the resource into memory but just delivers the uri path to a given file or a file path for a given uri."], "package_details": ["The functionality is similar to that of", "with the exception that this package does not load the given resource into memory and just delivers the uri path to a given file or the file path for a given uri.", "See", "on how to use the provided functions."]},
{"url": "https://wiki.ros.org/aws_ros1_common", "package": "aws_ros1_common", "package_summary": ["Common utilities for ROS1 nodes using Amazon Web Services"], "package_details": ["This is the common library for all AWS", "ROS1 packages.", "The source code is released under an", "."]},
{"url": "https://wiki.ros.org/aruco_detect", "package": "aruco_detect", "package_summary": ["Fiducial detection based on the aruco library"], "package_details": ["(", ", default: 7)", "There are two categories of ROS", "that can be used to configure the", "node: general and detection.", "The", "used in the library are paramaters of the", "node.  They can also be set via", "."]},
{"url": "https://wiki.ros.org/baxter_sim_controllers", "package": "baxter_sim_controllers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_rapidxml", "package": "asr_rapidxml", "package_summary": ["This package contains a Ros wrapper for RapidXML (version 1.13)"], "package_details": ["This package contains a ROS-Wrapper for the", "(version 1.13).", "Add this package to the list of dependencies of your project and then you can use the rapidxml library as it is stated in its", "."]},
{"url": "https://wiki.ros.org/asr_resources_for_vision", "package": "asr_resources_for_vision", "package_summary": ["This package holds bits and pieces that are related to the acquisition of color and depth-image data streams with robot heads. \n    Currently, it contains a hierarchy of launch scripts to start up simultaneous data acquisition from complex setups of vision sensors as encountered on robot heads \n    (e.g. RGB-D in combination with a color camera or a stereo camera setup)."], "package_details": ["The launch system of the kinect uses", "and", "to process the data and the scripts in", "are used to call those nodes with the correct parameters.", "Kinect", "camera", "Stereo camera", "For more information on the image processing parameters and the general functionality check out the", "/", "packages."]},
{"url": "https://wiki.ros.org/angles", "package": "angles", "package_summary": ["This package provides a set of simple math utilities to work\n        with angles. The utilities cover simple things like\n        normalizing an angle and conversion between degrees and\n        radians. But even if you're trying to calculate things like\n        the shortest angular distance between two joint space\n        positions of your robot, but the joint motion is constrained\n        by joint limits, this package is what you need. The code in\n        this package is stable and well tested. There are no plans for\n        major changes in the near future."], "package_details": ["The best place to find out how to use this package is the"]},
{"url": "https://wiki.ros.org/asr_next_best_view", "package": "asr_next_best_view", "package_summary": ["This package estimates Next-Best-Views as well as configurations (target positions and orientations) for a robot, where it is most likely to find and recognize searched objects the poses of which have, e.g., been predicted by means of ISM trees."], "package_details": ["This tool uses an iterative generate-and-test algorithm. Each iteration results in a", ", the algorithm stops if the", "of two consecutive iteration steps have almost no improvement. The idea of the", "is that it tells you where it is most probable that objects will be found.", "The following images describe basic concepts to understand the next_best_view node:", "In each iteration step, views are generated and then rated. The view with the best rating is chosen as NextBestView for that iteration step.", "To get a set of viewports from a set of positions and orientations, the cross product between those two sets is used. The resulting set of viewports is filtered by world and hypotheses information (MapHelper and CameraModelFilter class).", "The following two images show the orientation and position sampling. Each arrow on the sphere shows the endposition of one direction vector which starts in the center of the sphere. The red rectangle limits the space sampling area. All hexagon corners and the center of the rectangle are used to generate viewports.", "The NextBestViewCalculator class manages all modules.", "To find a NextBestView, we must first call the SetAttributedPointCloud and SetInitRobotState service calls, then we can use the GetNextBestView service call to get our NextBestView. SetAttributedPointCloud sets and visualizes the pointcloud as shown above in the second and third image, triggerFrustumVisualization is used to display the blue frustum which can be seen above in the first image.", "To invalidate hypotheses in a frustum, call the UpdatePointCloud service call with the camera pose.", "Just run", "to get the next_best_view node running for the simulation or", "to get it running in a real environment."]},
{"url": "https://wiki.ros.org/audio_common", "package": "audio_common", "package_summary": ["Common code for working with audio in ROS"], "package_details": ["Note: This stack is downloadable in debian package format as part of the", "package."]},
{"url": "https://wiki.ros.org/baxter_examples", "package": "baxter_examples", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_core_msgs", "package": "baxter_core_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_description", "package": "baxter_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/baxter_tools", "package": "baxter_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/aws_common", "package": "aws_common", "package_summary": ["Common AWS SDK utilities, intended for use by ROS packages using the AWS SDK"], "package_details": ["This is the common library for all AWS", "packages.", "The source code is released under", "."]},
{"url": "https://wiki.ros.org/asr_sick_lms_400", "package": "asr_sick_lms_400", "package_summary": ["This package is used to access the sick lms400 laser range-finder. It contains all necessary functionality to communicate with the sensor via rosmessages."], "package_details": ["(string)", "(string)", "(int)", "(int)", "(int)", "(int)", "(int)", "(double)", "(int)", "(bool)", "(int)", "A", "is required to use this package.", "_/laser_scan_ ("]},
{"url": "https://wiki.ros.org/actionlib_msgs", "package": "actionlib_msgs", "package_summary": ["actionlib_msgs defines the common messages to interact with an\n     action server and an action client.  For full documentation of\n     the actionlib API see\n     the", "package."], "package_details": []},
{"url": "https://wiki.ros.org/astra_launch", "package": "astra_launch", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/asr_robot_model_services", "package": "asr_robot_model_services", "package_summary": ["This package provides services to perform calculations related to the mild's kinematic model."], "package_details": ["- with", ",", "as the 2D position of the robot's base,", "as the robot's rotation on the 2D map and", ",", "as the angles of the PTU unit -", "Considering this simplified version of the kinematic chain, an optimization algorithm provided by the", "package is used to find an optimal solution for pan and tilt angles, as well as the base rotation.", "The goal is to find a camera pose (and a corresponding view frustum - red), that faces the center of the target view frustum (black) in the same distance", "while minimizing the angle deviation", "as much as possible.", "Given the position of the target view frustum center", ", the camera distance to the center", ", the projected distance between tilt joint and camera center point", "as well as the tilt joint's constant height above ground", ", the tilt angle can be determined.", "Once a solution for the tilt angle has been found, the position of", "can be calculated directly.", "A more detailed description of how this problem is being solve can be found here", ".", "Starting the", "for the", "robot model:", "Starting the", "for the", "robot model:", "This file specifies the names of key frames in the robot's kinematic chain.", "See", "for an overview over the mild's kinematic chain.", "The functionality for the pose correction is described here:"]},
{"url": "https://wiki.ros.org/axis_camera", "package": "axis_camera", "package_summary": ["Python ROS drivers for accessing an Axis camera's MJPG\n    stream. Also provides control for PTZ cameras."], "package_details": ["ROS camera driver for", ".", "Parameters are resolved starting with the driver's private namespace. If desired, they may be defined in some containing namespace. That is useful for sharing parameters with the", "node.", "The", "must already be running before any of these example commands.", "While you can run the driver in the ROS root namespace, the image pipeline prefers running each camera in its own subordinate namespace. These examples use the", "namespace. With multiple cameras, use something unique to the device, like the camera name.", "Pass the network host name and password of the camera on the command line, assuming the default username (\"root\"). This example uses the", "local", "address, alternatively one could provide the static IP address for which the camera is configured.", "This publishes two topics:", "and", ".", "To see the raw image, run", "in another terminal this way:", "The", "parameter is necessary, because the camera is actually publishing a motion JPEG stream, via the ROS", "message.", "Wide-angle network camera lenses generally exhibit significant intrinsic distortion. For robotics work, it is very helpful to calibrate each camera and use", "to provide rectified output.", "Since the driver produces compressed motion JPEG, and", "expects raw", "data, an extra step is needed to convert the data stream:", "To see the rectified color image, run", "in another terminal this way:", "The", "parameter is not needed in this case, because image_proc publishes its output using", ".", "Then, in a third terminal, run", ":", "Then, follow the instructions in the", ".", "The resulting calibration parameters will be stored in", ", which resolves to", "in this example (assuming $ROS_HOME points to the default", "directory). The next time the driver runs on the same machine it should automatically pick up the existing calibration information in that same location.", "You can store the calibration elsewhere by setting", "appropriately for the driver. For example, to store it in a package named", ", append this to the driver's argument list:", "See", "for details."]},
{"url": "https://wiki.ros.org/baxter_interface", "package": "baxter_interface", "package_summary": [], "package_details": ["Since", "API Doc is", "."]},
{"url": "https://wiki.ros.org/baxter_sim_io", "package": "baxter_sim_io", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/async_web_server_cpp", "package": "async_web_server_cpp", "package_summary": ["Asynchronous Web/WebSocket Server in C++"], "package_details": []},
{"url": "https://wiki.ros.org/actionlib_tutorials", "package": "actionlib_tutorials", "package_summary": ["The actionlib_tutorials package"], "package_details": ["actionlib_tutorials is a series of tutorials for using the", "client API. You can browse these tutorials by installing", "and", "-ing to the", "package, i.e."]},
{"url": "https://wiki.ros.org/airbus_ssm_plugin", "package": "airbus_ssm_plugin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/battery_monitor_rmp", "package": "battery_monitor_rmp", "package_summary": [], "package_details": ["The", "package uses the feedback provided by the RMP to monitor the segway batteries and then uses espeak to tell the user if a battery is getting low. It also publishes this information.", "To install the", "package, you can choose to either install from source, or from the Ubuntu package:", "The", "package contains a", "file. This file launches an instance of the", ". To launch these nodes the following command can be used:", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/audio_capture", "package": "audio_capture", "package_summary": ["Transports audio from a source to a destination. Audio sources can come\n      from a microphone or file. The destination can play the audio or save it\n      to an mp3 file."], "package_details": ["See", "for usage."]},
{"url": "https://wiki.ros.org/ecl_config", "package": "ecl_config", "package_summary": ["These tools inspect and describe your system with macros, types \n     and functions."], "package_details": ["When autodetection fails (you have a very embedded board, or your toolchain has been patched together in a very non-standard way) there is provision to manually supply details via the", "macro. Refer to the", ".", "Checking for", ":"]},
{"url": "https://wiki.ros.org/cob_cartesian_controller", "package": "cob_cartesian_controller", "package_summary": ["This package provides nodes that broadcast tf-frames along various (model-based) Cartesian paths (e.g. Linear, Circular).\n    The tf-frames are interpolated using a given velocity profile (e.g. Ramp, Sinoid) and can be used as targets for the cob_frame_tracker/cob_twist_controller."], "package_details": []},
{"url": "https://wiki.ros.org/ecl_containers", "package": "ecl_containers", "package_summary": ["The containers included here are intended to extend the stl containers.\n    In all cases, these implementations are designed to implement\n    c++ conveniences and safety where speed is not sacrificed. \n\n    Also includes techniques for memory debugging of common problems such\n    as buffer overruns."], "package_details": ["See the programs in the", "and", "subdirectories."]},
{"url": "https://wiki.ros.org/cob_teleop", "package": "cob_teleop", "package_summary": ["Teleop node"], "package_details": ["This package uses a joystick or keyboard for teleoperation of Care-O-bot. To use this package you need either a real Care-O-bot or a simulated one (see", ").", "The", "package provides both, a configurable node for teleoperation by joystick or by keyboard.", "To be able to use the joystick the", "has to be pressed all the time, as soon as the button is released a stop will be send to all hardware components. Have a look at the following image to see which buttons command which components.", "For", ": Hold the", "button and use the base", "and", "axis to move the base.", "For", ": Hold the", "button and the", "or", "neck button, then use the", "or", "axis to move the torso.", "For", ": Hold the", "button and the", "button, then use the", "axis to move the tray.", "For", ": Hold the", "button and one of the", "buttons, then use the", "or", "axis to move the selected arm joints."]},
{"url": "https://wiki.ros.org/class_loader", "package": "class_loader", "package_summary": ["The class_loader package is a ROS-independent package for loading plugins during runtime and the foundation of the higher level ROS \"pluginlib\" library. class_loader utilizes the host operating system's runtime loader to open runtime libraries (e.g. .so/.dll files), introspect the library for exported plugin classes, and allows users to instantiate objects of said exported classes without the explicit declaration (i.e. header file) for those classes."], "package_details": ["is a ROS-independent package that allows one to dynamically load exported C++ classes during runtime from a runtime library (i.e. .so/.dll file) and create objects of those classes. What makes a class loaded through", "different from just linking against a runtime library and using classes from it is that your code does not require the definition of the class (i.e. the header file for the class) in your client code. Classes loaded in this fashion are also often called", ".", "is used in the implementation of the higher-level ROS package", "which is the encouraged method for loading plugins in the ROS", "ecosystem.", "is simple to use and requires linking against a single library (", ").", "as of version 1.9 and class_loader HIGHLY discourage linking applications directly against libraries containing plugins. Often times users will place plugins into libraries along side code intended to directly be linked. Other times they want to be able to use classes as plugins as well as directly use them without a", ". This was fine in previous versions of pluginlib, but as version 1.9, pluginlib sits on top of class_loader for plugin loading which cannot handle this.", "It is important to note that the", "can only inspect classes and create objects of those classes if those classes are registered to be exportable.  For any classes you want to export, make sure to have a declaration of the following macro for each class within your source (.cpp) files:", "where", "refers to the name of the class to be exported and", "refers to the name of the class from which it is derived. Though you do not need the definition of the Derived class in the code that will load the class, you still need to have a definition to its base class so as to be able to use the plugin. Notice in the code examples that when introspecting the library via", "or creating a plugin via", "that both methods require a template type argument indicating the base class. If the correct base class is not given, the class will not be seen or instantiable by the", ". It is ok to have classes with different base classes registered or even register the same class multiple times with different bases in the same library and transitively the same", ". Just note the base class argument must be provided at compile time via a template argument for methods where it matters.", "Once you have built all your source files using the macro, you can package the object files into a runtime library and then load that library via the", ".", "All methods to", "and", "are thread safe. The use of templates allows for all types to be statically verified and it is impossible to load an invalid plugin with an incompatible interface. This is a powerful concept in guaranteeing the integrity of plugins at both compile and runtime which is of course very important in robotics.", "When one uses the", "to create and destroy plugins, it results in the opening and closing of the runtime libraries containing those plugins. When a runtime library is loaded by an operating system, symbols in the host executable that are stubs to the runtime library are resolved. When the library is unloaded, the symbols at those corresponding memory addresses are unavailable as the code has been removed from executable's address space and [possibly] unloaded from memory. If one attempts to use symbols that are unresolved, it leads to a runtime link error. This means if I create an object from a class defined within a runtime library, I then unload the library, and then I try to use the object...things will go bad.", "In the example code above, the library is loaded and unloaded by", "automatically, though", "provides methods for explicitly loading and unloading the underlying library (", "and", "respectively). The", "is smart in that it will automatically load a library when created and unload it when the", "goes out of scope. One may wonder why the load and unload methods are then exposed. In order to understand that, we must first understand the", "'s on-demand (lazy) load/unload mode.", "The", "constructor provides an optional boolean flag (", ") to indicate if the", "is to perform on-demand (lazy) loading of a library as needed and automatically closing it after the last plugin in created by it is destroyed. By default, this flag is set to false. When set to false, the", "loads the library at construction time and unloads it at destruction time. In on-demand mode, the library is only opened when the first plugin is created via", "and unloaded when the only remaining plugin created by the", "is destroyed. This mode is helpful when we want to minimize the number of libraries loaded in memory.", "It is often useful, particularly in on-demand mode, to control when the library is loaded and unloaded. One can force this by calling", ". When one calls", "and", ", the library is forcefully loaded into memory and cannot be unloaded automatically by the system until", "is called. This allows multiple threads sharing the same", "to force a shared library, even if it's open in on-demand mode, to stay in memory until it's done. This is not a thread safety issue, but rather one for performance to prevent a library from continuously being loaded/unloaded if a thread is going to need it heavily for some period of time and wants to guarantee the library stays in memory.", "A", "allows one to create objects in the form of", "values so as to provide automatic cleanup of objects. Another one of the important reasons this is implemented is so that the user cannot unload the library prematurely. The user is free to create unmanaged objects via the alternate", "method, but this will prevent the", "from stopping the user on unloading the library when there are still objects in memory. This is because the", "cannot be aware of the state of unmanaged instances.", "Many", "methods will raise an exception of base class type", "if an error occurs. The subclasses of", "are defined in", "and indicate the various problems. These include:", "The", "is designed to be bound only to a single runtime library. Often it is convenient to have multiple libraries open and be able to load/unload classes from them through a uniform interface. That is why the class", "is provided. This class provides as an almost identical interface to", "but allows one to bind several libraries to a single loader object. Internally, the", "is just a manager for a collection of", "objects.", "The issue is that the way class_loader implements plugin introspection is by having plugin", "automatically register themselves when the library is opened. This is not how pluginlib prior to version 1.9 operated. However, the problem is is that when you directly link an executable against a library with plugins, when that program starts up, all the plugin factories will be created outside the scope of a", ". See", "for more details.", "For those interested in understanding the internals of", ", go to the", "page."]},
{"url": "https://wiki.ros.org/control_box_rst", "package": "control_box_rst", "package_summary": ["The control_box_rst package provides C++ libraries for predictive control, \n               direct optimal control, optimization and simulation."], "package_details": ["Use GitHub to", ". [", "]", "The project's wiki is located at", "."]},
{"url": "https://wiki.ros.org/depth_image_proc", "package": "depth_image_proc", "package_summary": ["Contains nodelets for processing depth images such as those\n     produced by OpenNI camera. Functions include creating disparity\n     images and point clouds, as well as registering (reprojecting)\n     a depth image into another camera frame."], "package_details": ["has found a new home in", ". In Electric it resided in", ".", "provides basic processing for depth images, much as", "does for traditional 2D images. The two packages are complementary; for example, you can (and should!) rectify your depth image before converting it to a point cloud.", "See", "for details on depth image representation. The REP recommends that, wherever possible, producers and consumers of depth data use depth images (of type", ") instead of", ".", "All nodelets (besides", ") in this package support both standard floating point depth images and OpenNI-specific", "depth images. Thus when working with OpenNI cameras (e.g. the Kinect), you can save a few CPU cycles by using the", "raw topics instead of the", "topics.", "For an example of", "in practice, examine the contents of", "."]},
{"url": "https://wiki.ros.org/comp_spatial", "package": "comp_spatial", "package_summary": [], "package_details": ["This package is part of the", "knowledge processing system."]},
{"url": "https://wiki.ros.org/cob_command_gui", "package": "cob_command_gui", "package_summary": ["This package provides a simple GUI for operating Care-O-bot."], "package_details": ["To use this package you don't need any hardware, but it is intended to be used with either a real Care-O-bot or a simulated one (see", "or", ").", "The", "package provides a configurable node for operating different hardware parts of Care-O-bot. The command_gui uses the functionalities of the", "package.", "The parameters of the command_gui are  defined in", "and", "and loaded in the parameter server."]},
{"url": "https://wiki.ros.org/camera_info_manager_py", "package": "camera_info_manager_py", "package_summary": ["Python interface for camera calibration information.\n\n    This ROS package provides a CameraInfo interface for Python camera\n    drivers similar to the C++ camera_info_manager package."], "package_details": [": a driver can now handle more than one camera, using a different", "with the CameraInfoManager class instance of each device.", "It provides a Python module for camera drivers to manage the", "required by the", ".", "The API includes a camera name, which is written when", "is saved and checked when data are loaded, with a warning logged if the name read does not match.", "Camera driver authors should refer to the", "for syntax details and recommendations for assigning camera names.", "The location for getting and saving calibration data is expressed by Uniform Resource Locator (URL). These URLs are commonly used in the APIs of this package and may also contain substitution variables to refer to common locations. Please see the", "for supported URLs, file formats and substitution variables, which include", "and the camera name,", ".", "This package does not read ROS parameters directly. Where appropriate, we recommend that drivers provide a", "parameter for the URL string passed to CameraInfoManager.", "Open a link from", "in the top-right corner of this web page."]},
{"url": "https://wiki.ros.org/diffdrive_gazebo_plugin", "package": "diffdrive_gazebo_plugin", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "For installation instructions, see", "."]},
{"url": "https://wiki.ros.org/concert_scheduler_requests", "package": "concert_scheduler_requests", "package_summary": [], "package_details": ["This package was renamed from", ". The older version is now", "."]},
{"url": "https://wiki.ros.org/bwi_msgs", "package": "bwi_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"bwi_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/bwi_msgs/manifest.yaml", "This package collects ROS messages, services and actions that are specific to the Building-Wide Intelligence project of the University of Texas at Austin.  It simplifies the dependencies between various", "repository components."]},
{"url": "https://wiki.ros.org/dbw_mkz_twist_controller", "package": "dbw_mkz_twist_controller", "package_summary": ["Twist (speed and angular rate) controller for brake/throttle/steering"], "package_details": []},
{"url": "https://wiki.ros.org/cob_gazebo_ros_control", "package": "cob_gazebo_ros_control", "package_summary": ["This package contains a specialization of the gazebo_ros_control plugin.\n    The cob_gazebo_ros_control plugin allows Multi-HardwareInterface-Support."], "package_details": []},
{"url": "https://wiki.ros.org/diagnostic_msgs", "package": "diagnostic_msgs", "package_summary": ["This package holds the diagnostic messages which provide the\n    standardized interface for the diagnostic and runtime monitoring\n    systems in ROS. These messages are currently used by\n    the", "Stack, which provides libraries for simple ways to set and access\n    the messages, as well as automated ways to process the diagnostic\n    data.\n\n    These messages are used for long term logging and will not be\n    changed unless there is a very important reason."], "package_details": ["The", "package in the", "stack assists in sending diagnostics", "There are several ways to view diagnostics in the", "package in the", "stack."]},
{"url": "https://wiki.ros.org/bwi_tools", "package": "bwi_tools", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/depthimage_to_laserscan", "package": "depthimage_to_laserscan", "package_summary": ["depthimage_to_laserscan"], "package_details": ["projected on top of the", ".", "Note the", "overlayed in color on the", ".  Red is close to camera, purple is far from camera.", "Top down view of the", "."]},
{"url": "https://wiki.ros.org/dynamixel_msgs", "package": "dynamixel_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/cob_footprint_observer", "package": "cob_footprint_observer", "package_summary": ["The cob_footprint_observer package adjusts the footprint of the robot based on the setup (e.g. arm and/or tray)."], "package_details": ["The", "only works with rectangular footprints.", "The", "observes the setup of the Care-O-Bot (including arm and tray) and inflates the footprint to contain the arm and the tray.", "It allows for reading the adjusted footprint using either the", "service or the published", "topic.", "To use this package you need either need a real or a simulated Care-O-Bot (see", "and", "respectively).", "The", "package provides a configurable node for checking and adjusting the footprint based on the current setup."]},
{"url": "https://wiki.ros.org/cob_dashboard", "package": "cob_dashboard", "package_summary": ["cob_dashboard is a modified version of [[pr2_dashboard]]."], "package_details": []},
{"url": "https://wiki.ros.org/concert_service_teleop", "package": "concert_service_teleop", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/bond", "package": "bond", "package_summary": ["A bond allows two processes, A and B, to know when the other has\n    terminated, either cleanly or by crashing.  The bond remains\n    connected until it is either broken explicitly or until a\n    heartbeat times out."], "package_details": []},
{"url": "https://wiki.ros.org/concert_service_admin", "package": "concert_service_admin", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/bondcpp", "package": "bondcpp", "package_summary": ["C++ implementation of bond, a mechanism for checking when\n    another process has terminated."], "package_details": ["Use GitHub to", ". [", "]", "bondcpp is an implementation of", "in C++.  To use bondcpp, please see the example below as well as the", "."]},
{"url": "https://wiki.ros.org/calibration_launch", "package": "calibration_launch", "package_summary": ["This package contains a collection of launch files that can be helpful in configuring\n    the calibration stack to run on your robot."], "package_details": []},
{"url": "https://wiki.ros.org/concert_msgs", "package": "concert_msgs", "package_summary": ["Shared communication types for the concert framework."], "package_details": []},
{"url": "https://wiki.ros.org/cob_camera_sensors", "package": "cob_camera_sensors", "package_summary": ["For more information read the readme.htm file located in"], "package_details": ["The", "package is a collection of ROS compatible drivers for the cameras installed on Care-O-bot 3. These include two color cameras (either of type", "or", ") and one", "time-of-flight sensor from Mesa Imaging or the", "sensor. All camera types are supported for Windows and Linux. To enable Windows compatibility, remove all", "flags from", "located at", ". The two Prosilica GC1380CH are natively supported by ROS with the", "package. The binaries of the", "package are executed within the related launch files. The same holds for the Kinect whose driver is located in the", "package.", "Setting the camera parameters for the", "and", "is different from the suggested ROS standard. Instead of setting all parameters within the ROS launch file, camera specific parameters are set within IPA specific configuration files. This originates from IPA internal requirements to maintain backward compatibility to existing components. The ROS launch file only holds parameters related to the camera setup (e.g. specifying the used camera types) and a link to the IPA internal configuration file.", "In order to launch the camera nodes, do the following (Replace", "with your personal Care-O-bot identifier)", "For quitting do not close the viewer window, but hit", "on your console", "For quitting do not close the viewer window, but hit", "on your console", "The IPA configuration file is located at", "in a folder related to your sensor setup e.g.", "or", ". The configuration is XML-based. It holds one XML-tag for each camera e.g.", "for a AVT Pike C145 camera. The number within the tag-name is used to differentiate several camera of the same type. Here is an excerpt from the IPA configuration file of one of our Care-O-bots.", "Camera intrinsics may be set for each camera within the designated tags. The information is later published with the images using the ROS", "from the", "package. The user has the possibility of specifying different intrinsic for one camera. This is related to stereo vision, where intrinsics are optimize to fit to another camera. Within the ROS node that publishes camera images, the non-optimized intrinsic are published with the images. Extrinsic specify the rotation and translation relative to another camera. These parameters are not yet published and for IPA internal usage only.", "For each camera there is also a related", "tag. This is also related to backward compatibility issues and not used within ROS. Originally, it provided support for loading saved image data from disk and using it as if it came from a real camera device. However, ROS already provides more sophisticated means to record and play back data using", "and", ".", "ROS launch files are located in", "and hold information about the overall sensor setup not related to a specific camera. There is a launch file to start each camera independently (", ") and a launch file to start all Care-O-bot cameras at once (", "). Before you can start these launch files, you have to specify your robot id via", "for example. Each launch file specifies the location of the related IPA configuration file and the used color camera or time-of-flight camera type. The robot specific launch and configuration files are located in the", "folders. The following camera types are supported:", "The Prosilica GC1380CH color camera is supported through the ROS", "package. To get more information, have a look at their tutorial. The camera specific launch files have an additional parameter specifying the camera's ID which is related to the number within the tag-name in the IPA configuration file e.g.", ".", "A detailed guide for configuring and starting the stereo pair of", "cameras can be found in the", ".", "A detailed guide for configuring and starting the stereo pair of", "cameras can be found in the", ".", "Instructions for the usage of the Swissranger 3000 or 4000 sensor mounted on the Care-O-Bot can be found at", ".", "Instructions for the usage of the Microsoft Kinect sensor mounted on the Care-O-Bot can be found at", "."]},
{"url": "https://wiki.ros.org/dynamixel_driver", "package": "dynamixel_driver", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/concert_service_msgs", "package": "concert_service_msgs", "package_summary": ["Messages used by official rocon services."], "package_details": []},
{"url": "https://wiki.ros.org/control", "package": "control", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/brics_actuator", "package": "brics_actuator", "package_summary": ["Message defined in the BRICS project"], "package_details": []},
{"url": "https://wiki.ros.org/collada_parser", "package": "collada_parser", "package_summary": ["This package contains a C++ parser for the Collada robot\n    description format. The parser reads a Collada XML robot\n    description, and creates a C++ URDF model. Although it is possible\n    to directly use this parser when working with Collada robot\n    descriptions, the preferred user API is found in the urdf package."], "package_details": ["The code API for this package is for internal use only.  Please use the", "package instead."]},
{"url": "https://wiki.ros.org/dwb_local_planner", "package": "dwb_local_planner", "package_summary": ["Plugin based local planner implementing the nav_core2::LocalPlanner interface."], "package_details": []},
{"url": "https://wiki.ros.org/console_bridge", "package": "console_bridge", "package_summary": [], "package_details": ["console_bridge", "Mirza Shah (", "), Ioan Sucan (", ")", "Ioan Sucan (", ")", "is a ROS-independent, pure CMake (i.e. non-catkin and non-rosbuild package) that provides logging calls that mirror those found in", ", but for applications that are not necessarily using ROS.", "Normally in ROS C++ code, developers can log data via", "using the macros ROS_DEBUG, ROS_INFO, ROS_WARN, and ROS_ERROR. These logging messages are not only outputted to the screen (depending on log level of course), but are also published to", "so that other ROS nodes can subscribe to them. Applications like", "and its predecessor", "provide graphical interfaces for seeing logs during application runtime.", "Once you use", ", the implementations of", "will simply become equivalent to", "respectively."]},
{"url": "https://wiki.ros.org/cob_twist_controller", "package": "cob_twist_controller", "package_summary": ["The main purpose of the cob_twist_controller is to convert target twists into joint velocities. \n  Therefore it makes use of several implemented inverse kinematics approaches at the first order differential level. \n  The inverse differential kinematics solver considers kinematic chain extensions, singularity robustness, \n  redundancy resolution and priority-based methods.\n  To avoid hardware destruction there is a limiter interface active as well. \n  Via parameter server users can dynamically configure the solving strategy."], "package_details": []},
{"url": "https://wiki.ros.org/control_msgs", "package": "control_msgs", "package_summary": ["control_msgs contains base messages and actions useful for\n    controlling robots.  It provides representations for controller\n    setpoints and joint and cartesian trajectories."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"control_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/control_msgs/manifest.yaml"]},
{"url": "https://wiki.ros.org/cob_control_mode_adapter", "package": "cob_control_mode_adapter", "package_summary": ["The cob_control_mode_adapter package provides a node that automatically loads respective ros_controllers depending on required control mode."], "package_details": []},
{"url": "https://wiki.ros.org/common_tutorials", "package": "common_tutorials", "package_summary": ["Metapackage that contains common tutorials"], "package_details": []},
{"url": "https://wiki.ros.org/bwi_services", "package": "bwi_services", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/compressed_image_transport", "package": "compressed_image_transport", "package_summary": ["Compressed_image_transport provides a plugin to image_transport for transparently sending images\n    encoded as JPEG or PNG."], "package_details": ["is a plugin package for", ". It enables any node using", "classes to publish and subscribe to compressed image topics. Compression format (JPEG or PNG) and quality can be changed on the fly.", "See", "for general instruction on using", ".", "is featured in the", "tutorial", ".", "Some cameras (particularly webcams) output their image data already in JPEG format. When writing a driver for such a camera, a quick and dirty approach is to simply copy the JPEG data into a", "message and publish it on a topic of the form", ". Then any ROS node using", "can subscribe to", "with transport", ", just as if", "were used on the publisher side. Of course, the other transport topics (including", "itself) will not be available."]},
{"url": "https://wiki.ros.org/driver_base", "package": "driver_base", "package_summary": ["A framework for writing drivers that helps with runtime reconfiguration, diagnostics and self-test.\n\n    This package is deprecated."], "package_details": ["This package is for internal use only. Its API is stable, but", "recommended for use by new packages."]},
{"url": "https://wiki.ros.org/collada_urdf", "package": "collada_urdf", "package_summary": ["This package contains a tool to convert Unified Robot Description Format (URDF) documents into COLLAborative Design Activity (COLLADA) documents.\n\n    Implements robot-specific COLLADA extensions as defined by\n    http://openrave.programmingvision.com/index.php/Started:COLLADA"], "package_details": ["The urdf_to_collada tool will convert", "files into COLLADA", "files."]},
{"url": "https://wiki.ros.org/clearpath_base", "package": "clearpath_base", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"clearpath_base\" in rosdoc: /var/www/docs.ros.org/en/api/clearpath_base/manifest.yaml"]},
{"url": "https://wiki.ros.org/cob_light", "package": "cob_light", "package_summary": ["This package contains scripts to operate the LED lights on Care-O-bot."], "package_details": ["The", "package provides a node that connects to the light hardware board and offers a message interface over", ". The current state of the light is published as a", "."]},
{"url": "https://wiki.ros.org/dnn_detect", "package": "dnn_detect", "package_summary": ["DNN based detection"], "package_details": ["A camera node, such as", "needs to be running", "Then", "can be launched:"]},
{"url": "https://wiki.ros.org/capabilities", "package": "capabilities", "package_summary": ["Package which implements capabilities, including code to parse capability interface specs, to parse capability provider specs, and implement the capability server."], "package_details": ["There are tutorials located here:", "The provided (Python) API can be used to discover local packages which define one or more of the spec files defined by this package, load them, and interact with them. It also provides an API to discover what capabilities are provided by a", "running on a remote machine, which is useful for tools like the", "plugin.", "This package provides the", "ROS node which loads all capability spec files from packages on the", "and provides a ROS interface for querying and running those capabilities.", "The", "is documented in the CodeAPI (linked to on the right)."]},
{"url": "https://wiki.ros.org/dynamicvoronoi", "package": "dynamicvoronoi", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/bwi_interruptable_action_server", "package": "bwi_interruptable_action_server", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/concert_service_gazebo", "package": "concert_service_gazebo", "package_summary": [], "package_details": ["An example is available in the", "package."]},
{"url": "https://wiki.ros.org/cob_relayboard", "package": "cob_relayboard", "package_summary": ["cob_relayboard"], "package_details": []},
{"url": "https://wiki.ros.org/csm", "package": "csm", "package_summary": ["This is a ROS 3rd-party wrapper", "of Andrea Censi's CSM package. \n\n    From", ":"], "package_details": ["Please submit your tickets through", "(requires github account) or by emailing the maintainers."]},
{"url": "https://wiki.ros.org/costmap_prohibition_layer", "package": "costmap_prohibition_layer", "package_summary": [], "package_details": ["If used in combination with a local costmap, make sure that the global-frame parameter of the local costmap coincides with global costmap's parameter.", "Furthermore, the global-frame should be fixed (e.g. /map and not /odom), since currently no coordinate transformations are performed internally.", "The costmap2D from ros is able to add plugins (see", ").", "In step two you see how to add the YAML file to the parameters. If you're doing this in the launch file of the move base, you should load them into the namespace", ". The underlayed namespace (", "should accord with the plugin name, defined in the next step:", "In step three it is described how to add the plugin itself.", "For this plugin you have to add:"]},
{"url": "https://wiki.ros.org/cob_phidgets", "package": "cob_phidgets", "package_summary": ["cob_phidgets"], "package_details": ["Make sure your user is in the group \"dialout\" with", "."]},
{"url": "https://wiki.ros.org/compressed_depth_image_transport", "package": "compressed_depth_image_transport", "package_summary": ["Compressed_depth_image_transport provides a plugin to image_transport for transparently sending\n    depth images (raw, floating-point) using PNG compression."], "package_details": ["is a plugin package for", ". It enables any node using", "classes to publish and subscribe to compressed depth image/map topics. Compression parameters can be changed on the fly using the dynamic_reconfigure package.", "works only with floating-point or 16-bit integer encoded depth images.", "See", "for general instruction on using", ".", "works similar to", "which is featured in the", "tutorial", "."]},
{"url": "https://wiki.ros.org/depthcloud_encoder", "package": "depthcloud_encoder", "package_summary": [], "package_details": ["The depthcloud encoded images can be streamed to a web browser with the help of the", "package. In order to increase the dynamic range of the streamed depth image, it is split into two individual frames that encode the captured depth information from 0 to 3 meters and from 3 to 6 meters, respectively. Furthermore, compression artifacts are reduced by filling areas of unknown depth information with interpolated sample data. A binary mask is used to detect and omit these samples during decoding. Once this video stream is received by the web browser, it is assigned to a WebGL texture object which allows for fast rendering of the point cloud on the GPU. Here, a vertex shader is used to reassemble the depth and color data followed by generating a colored point cloud. In addition, a filter based on local depth variance is used to further reduce the impact of video compression distortion.", "Source code is available at", ".", "Please send bug reports to the", ". Feel free to contact us at any point with questions and comments."]},
{"url": "https://wiki.ros.org/diagnostic_common_diagnostics", "package": "diagnostic_common_diagnostics", "package_summary": ["diagnostic_common_diagnostics"], "package_details": []},
{"url": "https://wiki.ros.org/concert_service_indoor_2d_map_prep", "package": "concert_service_indoor_2d_map_prep", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/calibration", "package": "calibration", "package_summary": ["Provides a toolchain running through the robot calibration process. This\n     involves capturing calibration data, estimating parameters, and\n     then updating the URDF."], "package_details": ["Documentation is coming for setting up your own robot. See", "or", "package for an example", "Please report bugs at:"]},
{"url": "https://wiki.ros.org/concert_master", "package": "concert_master", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/camera1394", "package": "camera1394", "package_summary": [], "package_details": ["This package provides a ROS interface for digital cameras meeting the", "using", ", which supports", ". Of the thousands of IIDC models, we are accumulating a", "with this driver.", "It works with the ROS", "like other streaming", ".", "For help, please check", ". If your question is not answered, open a new one with the", "tag, so we can see it and respond.", "To report problems or request new features:", "The", "driver was first released with ROS C-Turtle. That API is stable.", "Additional features have been added since. They are all compatible with the previous release, except for the default", "value.", "By default,", "requires the message timestamps for both images to match exactly, which the", "driver cannot do. The Diamondback release of", "provided a solution for this problem (enhancement", ").", "The", "had some significant limitations. Some have been removed in later releases. Please check the specific documentation for that release, if you are still using ROS C-Turtle.", "For each supported feature there is a corresponding", "parameter providing user control. Different cameras handle these controls in various ways.", "When setting an IIDC feature to a specific value, it is necessary to set the corresponding control state to", "(3), otherwise the corresponding value will be ignored unless the device is already in the", "state when the driver starts.", "For example, to set", "to 256 on the command line:", "Many IIDC cameras use", "to provide color information. For cameras of this type, set", "to an appropriate", "value, and select the correct", ". If the", "is", ", all", "images are monochrome.", "Best performance is likely to come from using the default", "method while running", "and", "nodelets both in a single process (see the", "example below).", "In both cases the", "image stream is compatible with the ROS", ".", "Format7 parameters specify image size, position and pixel format. Some Format7 modes may provide binning, combining groups of hardware pixels into a single image pixel. The Format7 Region of Interest (ROI) selects a rectangular subset from the full hardware image. These options sometimes allow the camera to send images at a faster rate. (The", "parameter has no effect in Format7.)", "With an available", "selected, a number of Format7-specific parameters", "be supported, depending on the device:", "All these parameters are ignored when", "is not one of the Format7 options.", "This driver publishes the same topics and provides the same parameters as the", "version.", "Run a standalone", ", this behaves almost the same as running", ".", "For that, see the following example.", "To run the driver nodelet and", "all in a single address space with zero-copy message passing between those nodelets, use a", "like this:", "Depending on specific needs, some of the", "nodelets could be omitted. But, they do not incur much overhead when not being used."]},
{"url": "https://wiki.ros.org/bond_core", "package": "bond_core", "package_summary": ["A bond allows two processes, A and B, to know when the other has\n    terminated, either cleanly or by crashing. The bond remains\n    connected until it is either broken explicitly or until a\n    heartbeat times out."], "package_details": [": the bond packages are now part of bond_core.  In previous releases, they were part of", ".", "Groovy and above, please use the infrastructure at:"]},
{"url": "https://wiki.ros.org/calibration_estimation", "package": "calibration_estimation", "package_summary": ["Runs an optimization to estimate the a robot's kinematic parameters. This package is a\n    generic rewrite of pr2_calibration_estimation."], "package_details": []},
{"url": "https://wiki.ros.org/bwi_mapper", "package": "bwi_mapper", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/catkin_virtualenv", "package": "catkin_virtualenv", "package_summary": ["Bundle python requirements in a catkin package via virtualenv."], "package_details": ["See", "for package documentation."]},
{"url": "https://wiki.ros.org/bwi_logging", "package": "bwi_logging", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/catkin", "package": "catkin", "package_summary": ["Low-level build system macros and infrastructure for ROS."], "package_details": ["Catkin is included by default when ROS is installed. Catkin can also be installed from source or prebuilt packages. Most users will want to use the prebuilt packages, but installing it from source is also quite simple.", "For an explanation of the design goals and design decisions, in addition to the rationale for why Catkin (\"", "\") was created, see the", "page.", "If you are using a ROS binary distribution (Groovy or higher) on Ubuntu then you can install catkin with", ":", "If you are", "on Ubuntu you can install", "from", "via pip.", "See", "See the external", "containing:", "See"]},
{"url": "https://wiki.ros.org/cob_script_server", "package": "cob_script_server", "package_summary": ["The cob_script_server package provides a simple interface to operate Care-O-bot. It can be used via the python API or the actionlib interface."], "package_details": ["This package was created to be used with Care-O-bot but is not limited to one specific robot. It can be used for a real robot as well as for a simulated one (see", ").", "This package provides all methods as a python API (see", "). The table below shows a summary of the most important commands and their parameters.", "Each of the above function (except", ", which returns the keyboard input) returns a handle which offers the following commands.", "you can access all script_server commands in an ipython terminal with the prefix", ", e.g.", "All functions from the python API are also available as", "calls.", "All the parameters that are loaded in the name space /script_server are defined in .yaml files in the package", ".", "Tutorials can be found on the", "."]},
{"url": "https://wiki.ros.org/code_coverage", "package": "code_coverage", "package_summary": ["CMake configuration to run coverage"], "package_details": []},
{"url": "https://wiki.ros.org/cob_description", "package": "cob_description", "package_summary": ["This package contains the description (mechanical, kinematic, visual,\n  etc.) of the Care-O-bot robot. The files in this package are parsed and used by\n  a variety of other components. Most users will not interact directly\n  with this package."], "package_details": ["In the package", "you can find for each robot the urdf file that load the component descriptions together."]},
{"url": "https://wiki.ros.org/common_rosdeps", "package": "common_rosdeps", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/distance_field", "package": "distance_field", "package_summary": [], "package_details": ["Further details are available in the", "."]},
{"url": "https://wiki.ros.org/camera_calibration", "package": "camera_calibration", "package_summary": ["camera_calibration allows easy calibration of monocular or stereo\n     cameras using a checkerboard calibration target."], "package_details": ["will work with any camera driver node satisfying the standard ROS camera interface. See the", ".", "supports the following options:", "This package uses OpenCV camera calibration, described", ".  For detailed information on the parameters produced by the calibration, see", ".", "For pinhole type cameras this package names the distortion model as", "or", ", depending on number of parameters used. See", "For fisheye type cameras this package uses", "distortion model but names it as", ".", "For fisheye type cameras this package uses", "distortion model with the  name", ", according to", ".", "There are tutorials on how to run the calibration tool for", "and", "cameras.", "To run the", "node for a monocular camera using an 8x6 chessboard with 108mm squares:", "To run the", "node for a stereo camera:", "By default, the", "assumes that stereo cameras are triggered to capture images simultaneously, and that matching image pairs have identical timestamps. This is the ideal situation, but requires hardware support.", "To enable approximate timestamp matching, give the", "option. This permits a \"slop\" of 0.01s between image pairs. If you still don't see a display window, or it is sporadically updated, try increasing the slop.", "To use multiple checkerboards, give multiple", "and", "options for additional boards. Make sure the boards have different dimensions, so the calibration system can tell them apart."]},
{"url": "https://wiki.ros.org/diagnostics", "package": "diagnostics", "package_summary": ["diagnostics"], "package_details": ["The diagnostics toolchain is built around the", "topic. On this topic, hardware drivers and devices publish", "messages with the device names, status and specific data points.", "The", "and", "packages allow nodes to collect and publish diagnostics data. The", "can categorize and analyze diagnostics at runtime. Operators and developers can view the diagnostics data using the", "package. The", "package can convert diagnostics logs to CSV files for examination and after-the-fact analysis.", "To collect and publish diagnostics data, nodes can use tools in the", "package. The updater allows nodes, especially hardware drivers, to collect and publish diagnostics data. Using the tools in the updated package, drivers can monitor frequency and connection status. The", "package uses the", "to perform a self test on a driver, using a special service call.", "The", "package contains tools for categorizing and analyzing diagnostics at runtime. Using a plug-in model, a diagnostic aggregator can be configured for different types of robots to allow simple analysis of diagnostics. It is easy to summarize hundreds of diagnostic items into just a few categories. The diagnostic aggregator plug-ins can allow developers to give users easy to understand messages for common problems.", "The", "package contains the", "tool which displays the processed data from a", "in graphical form.", "For robots without a", ", the", "package contains a simple monitor that displays data from the", "topic.", "The tools in", "allow users to convert diagnostics bag files into one or more CSV files for plotting or viewing with off-the-shelf spreadsheet software. The", "tool allows the bag file to be converted into several CSV files, with each diagnostic status name made into its own file.", "Further information will be found in the", "."]},
{"url": "https://wiki.ros.org/cob_frame_tracker", "package": "cob_frame_tracker", "package_summary": ["The cob_frame_tracker package contains nodes that publish Twist commands based on the distance to the desired tf frame target."], "package_details": []},
{"url": "https://wiki.ros.org/control_toolbox", "package": "control_toolbox", "package_summary": ["The control toolbox contains modules that are useful across all controllers."], "package_details": ["This package contains several C++ classes useful in writing controllers, and so the main documentation can be found on the", "."]},
{"url": "https://wiki.ros.org/diagnostic_updater", "package": "diagnostic_updater", "package_summary": ["diagnostic_updater contains tools for easily updating diagnostics. it is commonly used in device drivers to keep track of the status of output topics, device status, etc."], "package_details": ["A working example of a diagnostic_updater can be found in", ". This example goes through some of the most common uses of an updater.", "The", "class eases the pain of filling out a", "message. It handles setting the summary, possibly with", "-type formatting of the message field, and setting of key-value pairs with type-conversion and formatting of the values. It also has facilities for merging multiple", "messages without losing information in the status message.", "The", "class manages a set of diagnostic update functions, and their periodic publication.", "Monitoring a topic's frequency, a common diagnostics feature, and the validity of its timestamps can be done using pre-packaged diagnostic update functions. A", "wraps a Publisher and standard diagnostics that relate to it in a single class.", "Topics with expected frequency lower than 1 Hz are supported. However,", "will report the", "task in WARNING state for the periods when no message came. If you want to work around this limitation and report the timestamp status as OK in the empty periods, you have to manually create a task of type", "and use it together with a", "task instead of the", "."]},
{"url": "https://wiki.ros.org/dynamic_reconfigure", "package": "dynamic_reconfigure", "package_summary": ["The dynamic_reconfigure package provides a means to update parameters\n    at runtime without having to restart the node."], "package_details": []},
{"url": "https://wiki.ros.org/camera_calibration_parsers", "package": "camera_calibration_parsers", "package_summary": ["camera_calibration_parsers contains routines for reading and writing camera calibration parameters."], "package_details": ["contains C++ functions for reading and writing camera parameters. These are mainly used internally by camera drivers and camera calibration tools, but the formats are human-readable.", "For usage, see the", "."]},
{"url": "https://wiki.ros.org/ecl_converters", "package": "ecl_converters", "package_summary": ["Some fast/convenient type converters, mostly for char strings or strings.\n     These are not really fully fleshed out, alot of them could use the addition for\n     the whole range of fundamental types (e.g. all integers, not just int, unsigned int).\n     \n     They will come as the need arises."], "package_details": []},
{"url": "https://wiki.ros.org/cpswarm_msgs", "package": "cpswarm_msgs", "package_summary": [], "package_details": ["This package depends on the", ".", "This work is supported by the European Commission through the", "under grant no. 731946."]},
{"url": "https://wiki.ros.org/cob_srvs", "package": "cob_srvs", "package_summary": ["This Package contains Care-O-bot specific service definitions."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"cob_srvs\" in rosdoc: /var/www/docs.ros.org/en/api/cob_srvs/manifest.yaml"]},
{"url": "https://wiki.ros.org/dynamixel_sdk", "package": "dynamixel_sdk", "package_summary": ["This package is wrapping version of ROBOTIS Dynamixel SDK for ROS. The ROBOTIS Dynamixel SDK, or SDK, is a software development library that provides Dynamixel control functions for packet communication. The API is designed for Dynamixel actuators and Dynamixel-based platforms."], "package_details": ["This package wraps the", "to be available for ROS. The ROBOTIS Dynamixel SDK is a software development library that provides Dynamixel control functions for packet communication. The API is designed for Dynamixel actuators and Dynamixel-based platforms."]},
{"url": "https://wiki.ros.org/cob_sound", "package": "cob_sound", "package_summary": ["This package implements a sound play module using text2wave and aplay through python."], "package_details": ["By default", "is used.", "For", "you need to buy a license key.", "Download and install voice. Adopted from", ".", "* apply fix for Ubuntu > 12.04", "* Register voice with license (you need to buy a license from", ", for IPA robots ask UHR or FMW for license key)"]},
{"url": "https://wiki.ros.org/common_msgs", "package": "common_msgs", "package_summary": ["common_msgs contains messages that are widely used by other ROS packages.\n    These includes messages for\n    actions (", "),\n    diagnostics (", "),\n    geometric primitives (", "),\n    robot navigation (", "),\n    and common sensors (", "), such as laser range finders, cameras, point clouds."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"actionlib_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/actionlib_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"diagnostic_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/diagnostic_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"geometry_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/geometry_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"nav_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/nav_msgs/manifest.yaml", "Newly proposed, mistyped, or obsolete package. Could not find package \"sensor_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/sensor_msgs/manifest.yaml", "This is a summary of the", "and", "types available in the various ROS", "in the", "stack. For more documentation, please see the relevant package.", "Please see", "for documentation on the standard units of measure and coordinate conventions followed here.", "Please see the", "."]},
{"url": "https://wiki.ros.org/ecl_exceptions", "package": "ecl_exceptions", "package_summary": ["Template based exceptions - these are simple and practical\n     and avoid the proliferation of exception types. Although not\n     syntatactically ideal, it is convenient and eminently practical."], "package_details": ["If outside ros, you will also need to link to", ".", "These are in", "."]},
{"url": "https://wiki.ros.org/ecl_build", "package": "ecl_build", "package_summary": ["Collection of cmake/make build tools primarily for ecl development itself, but also\n     contains a few cmake modules useful outside of the ecl."], "package_details": []},
{"url": "https://wiki.ros.org/cob_base_drive_chain", "package": "cob_base_drive_chain", "package_summary": ["This package contains classes that are able to control the platform of the Care-O-Bot. This means to establish a CAN communication to drive and steering motors of the platform and later send motion commands and receive motor information."], "package_details": ["To keep the communication with the Care-O-Bot platform variable (as different motors or CAN-hardware could be used),", "implements the communication to different motors through a generic interface", "and for different CAN modules through", ". The used CAN module is specified in an .ini-File, as well as motor-specific parameters. Each motor-object is loaded with appropriate parameters and during initialization each wheel is homed.", "After initialization, the user can easily command the platform using the provided functions of", "like", ".", "It is implemented in", "and again provided to the ROS network via services. To use the Elmo Recorder without the services, you can use the interface of", "directly as desribed below.", "There are two other levels of \u201cuser\u201d-interfaces, to keep the drive interface-classes slight. The function", "basically is just a wrapper function for the main Elmo-Recorder interface in", ". With these arguments you can control all of the Recorders features.", "specifies the general task, you are going to set up:", "To avoid that effect, the user only has to start-up the read-out process. From then, the transfer process is running autonomously, triggered by the receive of data packets, which are led to the appropriate functions after having been fetched from the CAN-buffer. During such a segmented SDO transfer, the data is collected in the", "collection class. It also holds some SDO-transfer-specific features like the state of the transmission. When receiving the last segment of a transfer, the collected data is handed to an adequate processing function. In our case, it's", ". Finally, the collected data is saved to a file; you also could imagine of keeping it temporarily in a variable to give the calling function the opportunity to process the data itself.", "How to read out data from the Elmo Recorder is described in", "."]},
{"url": "https://wiki.ros.org/cirkit_waypoint_navigator", "package": "cirkit_waypoint_navigator", "package_summary": [], "package_details": ["An example of using the packages can be seen in", ".", "This package sequentially navigates a robot via", "by sending waypoints generated by", "."]},
{"url": "https://wiki.ros.org/boost_numpy", "package": "boost_numpy", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/calibration_msgs", "package": "calibration_msgs", "package_summary": ["This package defines messages for storing calibration samples\n     to be used in full robot calibration procedures. This package\n     is still unstable. Expect the messages to change."], "package_details": []},
{"url": "https://wiki.ros.org/convex_decomposition", "package": "convex_decomposition", "package_summary": ["Convex Decomposition Tool for Robot Model"], "package_details": ["This is a thirdparty package with", "."]},
{"url": "https://wiki.ros.org/driver_common", "package": "driver_common", "package_summary": ["The driver_common stack contains classes and tools that are useful\n    throughout the driver stacks. It currently contains:\n\n    driver_base: A base class for sensors to provide a consistent state machine\n    (retries, error handling, etc.) and interface\n\n    timestamp_tools: Classes to help timestamp hardware events"], "package_details": [": the", "package (formerly part of this stack) became a separate stack.", "Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/bwi_planning", "package": "bwi_planning", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]", "This package is now", ". A newer version is now in the", "package:"]},
{"url": "https://wiki.ros.org/diagnostic_aggregator", "package": "diagnostic_aggregator", "package_summary": ["diagnostic_aggregator"], "package_details": ["The", "contains a ROS node,", ", that listens to", "messages on the", "topic, processes and categorizes the data, and republishes on", ". The", "loads \"Analyzer\" plugins to perform the diagnostics processing and categorization. The configuration and setup for each diagnostic aggregator is specific to each robot and can be determined by users or developers.", "The two analyzers in this package,", "and", ", hold and categorize diagnostic messages. They're useful for categorizing components or systems. They can warn when an item is stale, but do not do additional analysis of the diagnostics. Other analyzers can be loaded as plugins by the", "on startup.", "The aggregated diagnostic output can be displayed in the", "tool. The", "displays these messages in a hierarchical format. To determine the hierarchy, the diagnostic aggregator prepends diagnostic status names with a path, joined with \"/\". For example:", "This shows how an", "might categorize and analyze diagnostics data from a simple robot.", "Using the diagnostic aggregator, we can move these diagnostic messages into easy to understand categories to display in our", ". To do this, just prepend the name of the category to the status names, and separate them with \"/\".", "The", "will load analyzers to store and process the diagnostic data. Each analyzer inherits from the base class", ". Analyzers must be in packages that depend directly on", "and", ".", "The base analyzer class is the pure virtual", "class. All derived classes must implement these methods:", "Analyzers can choose the error state for any", "message they analyze and report. Generally, the \"parent\" of an analyzer has an error state of the maximum of its children, but some analyzers may have more advanced methods.", "The analyzers are responsible for correctly setting the names of each item they analyze. The", "does not do any checking or enforcement of the diagnostic status name hierarchy.", "Users can create Analyzers to load as plugins for different robots. See the tutorial", "for details.", "For a full tutorial, see the tutorial", ".", "Under each sub namespace under", ", a different analyzer is configured. Analyzers can be robot specific, or they can be general purpose ones like the", ".", "Each analyzer needs a special parameter,", ", in the namespace. The", "parameter gives the", "the class name of the", ".", "The", "parameter (publish rate of", ") is optional, and defaults to 1.0. The", "is prepended to all", "output, and defaults to \"\" (empty string).", "To look for an example of an aggregator in use, look in the \"diagnostic_aggregator/demo\" directory. Users specify each", "in the private parameter space of the", ", then start the node.", "In the", "package, the two analyzer types provided:", "and", ". The", "can be used to categorize and track stale items. The", "categorizes analyzers themselves, allowing users to \"sub-categorize\" analyzers.", "The", "class is useful for categorizing diagnostics data. It's mostly used for a particular device or category, like a Hokuyo node or EtherCAT devices. It can be configured to analyze almost any set of diagnostics data.", "For a full tutorial on the", ", see", "The", "can load a group of analyzers as a sub group. This can be useful for analyzing a group of similar items, like 4 different cameras. The", "can use any type of analyzer as one of the sub-analyzers.", "The above example can analyze the instruments on a PR2. The", "uses the parameter", "to prepend to all output names. In the above example,", "All sub-analyzers should go under the", "namespace of the", ". They should be specified in the same way that any diagnostic analyzer would be specified.", "Note: The diagnostic aggregator uses the", "internally, which is why this is very similar to setting up a diagnostic aggregator.", "The", "is a subclass of the", ". It will \"match\" any item that the", "matches, but will discard the items and not report it.", "The", "will simply ignore all parameters in its namespace, and not match or report anything.", "The difference between this and the", "above is that since the", "doesn't match anything, anything that it is ignoring will be reported in \"Other\". The", "will suppress any output from anything that it matches.", "PR2 robots use the", "and the", "for diagnostic display. The launch files in \"pr2_bringup/pr2.launch\" contain the configuration file for the", ".", "The \"diagnostic_aggregator/demo\" directory has an example of an", "used for testing and demonstrations."]},
{"url": "https://wiki.ros.org/dbw_pacifica_description", "package": "dbw_pacifica_description", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/carl_dynamixel", "package": "carl_dynamixel", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"carl_dynamixel\" in rosdoc: /var/www/docs.ros.org/en/api/carl_dynamixel/manifest.yaml", "The", "package is a package which launches the correct nodes and controllers from the 'dynamixel_motors' package. It also has a sensor_msgs/JointState publisher.", "The", "package contains a", "This file launches an instance of the", "and", "nodes from the 'dynamixel_motor' metapackage. It also launches the 'back_joints_node' and", ", as well as the", "node for velocity commands. To launch these nodes, the following command can be used:", "The id for the servo can be found from the 'motor_states/<port>' topic", "Please send bug reports to the", ". Feel free to contact me at any point with questions and comments."]},
{"url": "https://wiki.ros.org/cob_object_detection_msgs", "package": "cob_object_detection_msgs", "package_summary": ["This package contains message type definitions for object detection"], "package_details": []},
{"url": "https://wiki.ros.org/ecl_command_line", "package": "ecl_command_line", "package_summary": ["Embeds the TCLAP library inside the ecl. This is a very convenient\n     command line parser in templatised c++."], "package_details": []},
{"url": "https://wiki.ros.org/catch_ros", "package": "catch_ros", "package_summary": ["ROS integration for the Catch unit test framework"], "package_details": []},
{"url": "https://wiki.ros.org/ecl_devices", "package": "ecl_devices", "package_summary": ["Provides an extensible and standardised framework for input-output devices."], "package_details": ["If outside ros, you will also need to link against", ".", "These are in", "."]},
{"url": "https://wiki.ros.org/cmvision", "package": "cmvision", "package_summary": ["Node for fast color blob detection"], "package_details": ["The above command will bring up an interface that provides a means for graphically selecting desired colors for blobs.", "displays values for", "and", "which can be used in a colors file.", "Blob parameters are specified to", "using two components:", "Example", "for detecting a", "RWI B21r", "Multiple blob colors can be specified in the same file by adding lines under", "and", "."]},
{"url": "https://wiki.ros.org/cyberglove", "package": "cyberglove", "package_summary": [], "package_details": ["This node publishes", "/jointState messages on two topics for the raw and calibrated values. The two topics are", "and", "The calibration file is loaded from  the", "/param/cyberglove.cal file. To change which file you want to use, you can simply edit the parameter", "of the", "file.", "A calibration process is available in the", "plugin of the", ".", "The standard Cyberglove connected to the serial port has been tested, as well as the bluetooth version of the cyberglove. To use the bluetooth version, you need to pair it with your computer. A good howto is available on the", "."]},
{"url": "https://wiki.ros.org/catkin_pip", "package": "catkin_pip", "package_summary": ["Catkin macros to allow using pure python packages in usual catkin workspaces with normal python workflow."], "package_details": []},
{"url": "https://wiki.ros.org/bfl", "package": "bfl", "package_summary": ["This package contains a recent version of the Bayesian Filtering\n  Library (BFL), distributed by the Orocos Project.  For stability\n  reasons, this package is currently locked to revision 31655 (April\n  19, 2010), but this revision will be updated on a regular basis to\n  the latest available BFL trunk.  This ROS package does not modify\n  BFL in any way, it simply provides a convenient way to download and\n  compile the library, because BFL is not available from an OS package\n  manager.  This ROS package compiles BFL with the Boost library for\n  matrix operations and random number generation."], "package_details": ["This is a third party package with", "."]},
{"url": "https://wiki.ros.org/camera_info_manager", "package": "camera_info_manager", "package_summary": ["This package provides a C++ interface for camera calibration\n     information.  It provides CameraInfo, and handles SetCameraInfo\n     service requests, saving and restoring the camera calibration\n     data."], "package_details": [": the URL may now contain substitution variables, including the camera name and", ".", "class", ": the global", "class is no longer available, use", "instead.", ": a new", "method allows the caller to set", "parameters directly.", "It provides a C++ class used by many camera drivers to manage the", "required by the", ".", "For camera drivers written in Python, the", "package provides a similar interface.", "For ROS Diamondback, this package moved to the", "stack. For C Turtle, it was part of", ".", "In ROS Diamondback the", "class moved to the", "namespace. For compatibility with ROS C Turtle, the global", "class name is still supported. It is deprecated in Electric Emys and removed in Fuerte.", "The API includes a camera name, which is written when", "is saved, and checked when data are loaded, with a warning logged if the name read does not match.", "Camera driver authors should refer to the", "for syntax details and recommendations for assigning camera names.", "The location for getting and saving calibration data is expressed by Uniform Resource Locator (URL). These URLs are commonly used in the APIs of this package and may also contain substitution variables to refer to common locations. Please see the", "for supported URLs, file formats and substitution variables.", "This package does not read ROS parameters directly. Where appropriate, we recommend  that drivers provide a", "parameter for the URL string passed to CameraInfoManager.", "For compatibility with C Turtle, the global", "class name was still supported, but it was", "in Electric.", "The camera_info_manager is used in the", "driver.  Search for", "in the source code to see where the CameraInfoManager class is used. In particular, note the handling of Header time stamps and transform frame IDs."]},
{"url": "https://wiki.ros.org/cob_trajectory_controller", "package": "cob_trajectory_controller", "package_summary": ["This package provides a trajectory controller which controlls velocities for a chain of joints. This controller can be used e.g. with [[schunk_powercube_chain]]."], "package_details": []},
{"url": "https://wiki.ros.org/dynamixel_controllers", "package": "dynamixel_controllers", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/bwi_planning_common", "package": "bwi_planning_common", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/costmap_converter", "package": "costmap_converter", "package_summary": ["A ros package that includes plugins and nodes to convert occupied costmap2d cells to primitive types."], "package_details": ["(", ", default: 0.4)", "(", ", default: 0.4)", "(", ", default: 0.4)", "(", ", default: 0.4)", "This package defines an", "interface and provides some plugins for converting occupied cells of", "to geometric primitives. This primitives (points, lines, polygons) represent obstacles in the map.", "It is intendend for nodes that incorporate obstacles (e.g. in navigation) and do not rely on cost cells, but consider obstacles defined by shapes in the plane (e.g. polygons).", "The costmap is still favorable in conjunction with", "since it fuses multiple range sensors with a global static map and some filtering might be applied.", "A naive approach to further incorporate the costmap is to take each occupied cell as point-obstacle. However, by integrating the costmap_converter interface the costmap is converted continuously during runtime and if desired the conversion is invoked in a separate thread.", "For that purpose the internal", "node (", ") might be employed. Currently, parameters are hardcoded. These are going to be substituted with changeble parameters in an upcoming release. Before then please inspect the source code for further details."]},
{"url": "https://wiki.ros.org/comp_temporal", "package": "comp_temporal", "package_summary": [], "package_details": ["This package is part of the", "knowledge processing system."]},
{"url": "https://wiki.ros.org/blob", "package": "blob", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/camera_drivers", "package": "camera_drivers", "package_summary": [], "package_details": [": each camera driver formerly included here now resides in its own separate stack. For backwards compatibility, those stacks are listed as", "dependencies, but external dependencies should refer directly to the desired driver stack.", ": the camera_drivers metapackage is no longer supported. Update dependencies to refer to specific drivers, instead.", "To encourage compatibility between camera nodes, it is recommended that cameras provide one or both of the the following minimal APIs. The", "package provides a CameraPublisher class to help implementing this API. The", "package exports a CameraInfoManager C++ class that provides", "data and handles", "service requests."]},
{"url": "https://wiki.ros.org/cmake_modules", "package": "cmake_modules", "package_summary": ["A common repository for CMake Modules which are not distributed with CMake but are commonly used by ROS packages."], "package_details": []},
{"url": "https://wiki.ros.org/geometry2", "package": "geometry2", "package_summary": ["A metapackage to bring in the default packages second generation Transform Library in ros, tf2."], "package_details": ["This is a metapackage see", "for more detailed information."]},
{"url": "https://wiki.ros.org/geometry_experimental", "package": "geometry_experimental", "package_summary": ["The second generation Transform Library in ros.  This metapackage is deprecated, but is kept for backwards compatability."], "package_details": []},
{"url": "https://wiki.ros.org/head_action", "package": "head_action", "package_summary": [], "package_details": ["See", "for information on the controller that the head action communicates with.", "An example of using the head action on", "can be found on the video below.", "The joint trajectory action provides an action server (see", ") that takes in goals of the type", ".  It reports success when the head is pointed at the target."]},
{"url": "https://wiki.ros.org/eigen_stl_containers", "package": "eigen_stl_containers", "package_summary": ["This package provides a set of typedef's that allow\n  using Eigen datatypes in STL containers"], "package_details": []},
{"url": "https://wiki.ros.org/executive_smach", "package": "executive_smach", "package_summary": ["This metapackage depends on the SMACH library and ROS SMACH integration\n    packages."], "package_details": ["See", "for SMACH state classes with a variety of additional behaviors.", "On the", "you can find a number of easy examples. But if you are looking for some 'real' examples running SMACH:"]},
{"url": "https://wiki.ros.org/ecl_mobile_robot", "package": "ecl_mobile_robot", "package_summary": ["Contains transforms (e.g. differential drive inverse kinematics)\n    for the various types of mobile robot platforms."], "package_details": []},
{"url": "https://wiki.ros.org/gazebo_ros_control", "package": "gazebo_ros_control", "package_summary": ["gazebo_ros_control"], "package_details": []},
{"url": "https://wiki.ros.org/filters", "package": "filters", "package_summary": ["This library provides a standardized interface for processing data as a sequence \n    of filters.  This package contains a base class upon which to build specific implementations\n    as well as an interface which dynamically loads filters based on runtime parameters."], "package_details": [": filters is now a separate stack.  In previous releases, it was part of", ".", "(", ")", "(", ")", "(", ")", "(list(Filters))", ": A new simpler plugin macro is now recommended:", "Filters are closely linked to", ".  Please make sure that you are familiar with the", "before continuing.", "It is recommended to use a", "whenever using more than one instances of", ". However, you need to understand the base Filter C++ API first before using the Filter Chain API.", "The core of the", "Package is a templated base class", "which defines the external API to any filter.  The methods are", "and", ".  It also provides helper methods for a Filter implementation. To use a Filter simply instantiate it in your code.", "Filters are configured from parameters on the", ".  The configure method passes in the parameter namespace to read from of the Parameter Server.", "A Filter expects to find a map with three elements:", ",", "and", ".", "The", "class has been designed to facilitate dynamically loading a sequence of Filters based on runtime parameters.  The Filter Chain is configured from the", "just like Filters.  Based on the parameters the Filter Chain will dynamically load the Filters by their name.", "The public API looks just like the Filter API with", "and", "methods.", "Here's an example of a multi-channel filter chain for doubles.  To do a non-vector style use a", "and change", "and", "to type", ".", "Implementing a", "is simply a specific form of a dynamically loaded class for", ".", "This whole document refers simply to", "and", ".  However there are", "versions of both.  Instead of the templated data type,", ", they expect", "on the update calls.  And the configure method has one extra argument which is the number of channels expected(aka how many elements are expected in the", ")."]},
{"url": "https://wiki.ros.org/gennodejs", "package": "gennodejs", "package_summary": ["Javascript ROS message and service generators."], "package_details": ["This package generates the Javascript messages for ROS packages and is used by", "."]},
{"url": "https://wiki.ros.org/fanuc_experimental", "package": "fanuc_experimental", "package_summary": ["Experimental packages for Fanuc manipulators within ROS-Industrial."], "package_details": ["Use GitHub to", ". [", "]", "This repository is part of the", "program. It contains experimental packages that will be moved to the", "repository once they've received sufficient testing and review.", "Packages in distribution branches (ie:", ") may be expected to be compatible with the corresponding ROS distribution (ie: the", "branch is usable on Kinetic). In the absence of major differences between subsequent ROS releases, the", "branch may be expected to be compatible with the next release as well (ie:", "may be used on Melodic as long as no", "branch exists).", "Refer to the", "for more information on building catkin workspaces.", "See the", "page for more information.", "For questions related to the Fanuc support or ROS-Industrial in general, please contact the developers by posting a message in the", "on ROS Discourse."]},
{"url": "https://wiki.ros.org/hector_worldmodel_msgs", "package": "hector_worldmodel_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/freenect_stack", "package": "freenect_stack", "package_summary": ["A libfreenect-based ROS driver for the Microsoft Kinect"], "package_details": [", you need to blacklist the kernel module that gets loaded by default for the Kinect:", "The freenect_stack ROS driver supports USB 3.0, but users running Ubuntu 12.04 (precise) or older Ubuntu versions will have to patch their Kernel or upgrade to Kernel 3.4.2 or later to get this to work. See", "for more details.", "As mentioned in this thread", ", you need to forward all 3 devices (camera, motor, audio) to the VM for libfreenect to work properly."]},
{"url": "https://wiki.ros.org/gencpp", "package": "gencpp", "package_summary": ["C++ ROS message and service generators."], "package_details": []},
{"url": "https://wiki.ros.org/fcl", "package": "fcl", "package_summary": ["FCL: the Flexible Collision Library"], "package_details": ["Please see", "For more technical details, check out the", "More collision detection and proximity collision packages developed at UNC Chapel Hill are available in", "."]},
{"url": "https://wiki.ros.org/fake_joint_launch", "package": "fake_joint_launch", "package_summary": ["Collection of the launch files for fake_joint_driver."], "package_details": []},
{"url": "https://wiki.ros.org/eigen_conversions", "package": "eigen_conversions", "package_summary": ["Conversion functions between:\n      - Eigen and KDL\n      - Eigen and geometry_msgs."], "package_details": []},
{"url": "https://wiki.ros.org/ecl_geometry", "package": "ecl_geometry", "package_summary": ["Any tools relating to mathematical geometry. \n     Primarily featuring polynomials and interpolations."], "package_details": ["If outside ros, you will also need to link to", ".", "There are quite a few useful tools also in eigen's geometry module. You can use these directly from eigen or via the", "package."]},
{"url": "https://wiki.ros.org/four_wheel_steering_msgs", "package": "four_wheel_steering_msgs", "package_summary": ["ROS messages for robots using FourWheelSteering."], "package_details": []},
{"url": "https://wiki.ros.org/hrpsys", "package": "hrpsys", "package_summary": [], "package_details": ["As a 3rd party package to ROS we need some extra chores to release. Discussed", ". NOTE for 2 different repositories are involved:"]},
{"url": "https://wiki.ros.org/grizzly_msgs", "package": "grizzly_msgs", "package_summary": [], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"grizzly_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/grizzly_msgs/manifest.yaml", "Included as well in this package is a helper to assist with using", "messages in conjunction with Eigen. See the", "."]},
{"url": "https://wiki.ros.org/grasping_msgs", "package": "grasping_msgs", "package_summary": ["Messages for describing objects and how to grasp them."], "package_details": []},
{"url": "https://wiki.ros.org/fetch_navigation", "package": "fetch_navigation", "package_summary": ["Configuration and launch files for running ROS navigation on Fetch."], "package_details": []},
{"url": "https://wiki.ros.org/gazebo_dev", "package": "gazebo_dev", "package_summary": ["Provides a cmake config for the default version of Gazebo for the ROS distribution."], "package_details": []},
{"url": "https://wiki.ros.org/ecl_sigslots", "package": "ecl_sigslots", "package_summary": ["Provides a signal/slot mechanism (in the same vein as qt sigslots, \n     boost::signals etc for intra-process communication. These include \n     some improvements - they do not need a preprocessor, are fully type safe,\n     allow for simple connections via a posix style string identifier \n     and are multithread-safe."], "package_details": ["You will also need to link to", "."]},
{"url": "https://wiki.ros.org/euslisp", "package": "euslisp", "package_summary": ["EusLisp is an integrated programming system for the\n  research on intelligent robots based on Common Lisp and\n  Object-Oriented programming"], "package_details": ["Documentation is available", ".", "Use trac to report", "or", "."]},
{"url": "https://wiki.ros.org/graph_msgs", "package": "graph_msgs", "package_summary": ["ROS messages for publishing graphs of different data types"], "package_details": ["See", "for full documentation."]},
{"url": "https://wiki.ros.org/hokuyo_node", "package": "hokuyo_node", "package_summary": [], "package_details": [":", ":", "Image credit:", "On the UTM-30LX, unless the", "option is selected, the hokuyo_node will limit the angular range to values that are known to work. The angular range limit depends on the firmware version, and is proportional to the", "parameter.", "The", "and", "programs can be used to get information about a hokuyo laser scanner. Each of them can be invoked in a human readable way:", "The", "program can be used to get the hardware ID of a Hokuyo device given its port. Combined with udev, this allows a consistent device name to be given to each device, even if the order in which they are plugged in varies. The following udev rule should work universally on any ROS system:"]},
{"url": "https://wiki.ros.org/geometric_shapes", "package": "geometric_shapes", "package_summary": ["Generic definitions of geometric shapes and bodies."], "package_details": []},
{"url": "https://wiki.ros.org/household_objects_database_msgs", "package": "household_objects_database_msgs", "package_summary": [], "package_details": ["This package is", ". You probably want to use", "where some have been moved to. See also", ".", "This package defines the ROS API for the household objects database. For the API documentation as well as details on the database, see the", "package page."]},
{"url": "https://wiki.ros.org/ecl_linear_algebra", "package": "ecl_linear_algebra", "package_summary": ["Ecl frontend to a linear matrix package (currently eigen)."], "package_details": ["Using ros eigen now, but you can also opt to use the internal", "."]},
{"url": "https://wiki.ros.org/genmsg", "package": "genmsg", "package_summary": ["Standalone Python library for generating ROS message and service data structures for various languages."], "package_details": ["See the"]},
{"url": "https://wiki.ros.org/eml", "package": "eml", "package_summary": ["This is an implementation of the EtherCAT master protocol for the PR2 robot based on the work done at Flanders' Mechatronics Technology Centre."], "package_details": []},
{"url": "https://wiki.ros.org/fanuc", "package": "fanuc", "package_summary": ["ROS-Industrial support for Fanuc manipulators (metapackage)."], "package_details": []},
{"url": "https://wiki.ros.org/fetch_driver_msgs", "package": "fetch_driver_msgs", "package_summary": ["Messages for the fetch_drivers package"], "package_details": []},
{"url": "https://wiki.ros.org/ecto", "package": "ecto", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ecl_time", "package": "ecl_time", "package_summary": ["Timing utilities are very dependent on the system api provided for their use.\n\tThis package provides a means for handling different timing models. Current support\n\t\n\t- posix rt : complete.\n\t- macosx : posix timers only, missing absolute timers.\n\t- win : none."], "package_details": ["Many of the classes/methods in this package have many characteristics in common with the", "package - in fact they are almost identical. It was made before ros came about and is kept in the ecl for both legacy reasons and because it is still sometimes useful outside a ros runtime environment (particularly when cross-compiling).", "If outside ros, you will also need to link to", "."]},
{"url": "https://wiki.ros.org/hector_mapping", "package": "hector_mapping", "package_summary": ["hector_mapping is a SLAM approach that can be used without odometry as well as on platforms that exhibit roll/pitch motion (of the sensor, the platform or both). It leverages the high update rate of modern LIDAR systems like the Hokuyo UTM-30LX and provides 2D pose estimates at scan rate of the sensors (40Hz for the UTM-30LX). While the system does not provide explicit loop closing ability, it is sufficiently accurate for many real world scenarios. The system has successfully been used on Unmanned Ground Robots, Unmanned Surface Vehicles, Handheld Mapping Devices and logged data from quadrotor UAVs."], "package_details": ["available", ".", "To use", ", you need a source of", "data (for example a Hokuyo UTM-30LX LIDAR or bagfiles). The node uses", "for transformation of scan data, so the LIDAR does not have to be fixed related to the specified base frame. Odometry data is not needed."]},
{"url": "https://wiki.ros.org/gazebo_ros_pkgs", "package": "gazebo_ros_pkgs", "package_summary": ["Interface for using ROS with the", "simulator."], "package_details": ["gazebo_ros_pkgs is a set of ROS packages that provide the necessary interfaces to simulate a robot in the", "3D rigid body simulator for robots. It integrates with ROS using ROS messages, services and dynamic reconfigure."]},
{"url": "https://wiki.ros.org/humanoid_nav_msgs", "package": "humanoid_nav_msgs", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/ecl_formatters", "package": "ecl_formatters", "package_summary": ["The formatters here simply format various input types to a specified\n   text format. They can be used with most streaming types (including both\n   ecl and stl streams)."], "package_details": ["Typically c/c++ libraries bundle streaming and formatting within the same tool (printf, iostream, ...). This tends to make them cumbersome for simple tasks. The formatter classes in this package externalise the formatting task from the io manipulation (which is usually just (u)char manipulation), This increases the efficiency of low level operations whilst also maintaining type safety. They typically do this by making use of the lower level functionality provided by", ".", "The formatter classes can be used standalone, with stl streams or with", ".", "If outside of ros, you will also need to link to", ".", "Each standard formatter is a template specialisation of the form", "where the available input types are:"]},
{"url": "https://wiki.ros.org/hector_gazebo_plugins", "package": "hector_gazebo_plugins", "package_summary": ["hector_gazebo_plugins provides gazebo plugins from Team Hector. Currently it contains a 6wd differential drive plugin, an IMU sensor plugin, an earth magnetic field sensor plugin, a GPS sensor plugin and a sonar ranger plugin."], "package_details": ["is a replacement for the", "plugin in package", ". It simulates an Inertial Measurement Unit (IMU) affected by Gaussian noise and low-frequency random drift. The orientation returned mimics a simple Attitude and Heading Reference System (AHRS) using the (erroneous) rates and accelerations.", "simulates a GNSS (Global Navigation Satellite System) receiver which is attached to a robot. It publishs", "messages with the robot's position and altitude in WGS84 coordinates. The reference point that corresponds to the origin of the gazebo frame can be configured using the XML parameters. The conversion between gazebo coordinates and WGS84 is done using a simple", ", which is accurate enough if you do not go far away from the configured reference point and if you do not want to use the plugin for polar regions.", "This plugin simulates a 3-axis magnetometer like PNI Corp's", ". Like for the GPS plugin, the orientation of the gazebo frame can be specified via the referenceHeading parameter. Declination, inclination and field magnitude have to be configured depending on your location on earth. The default parameters are valid for Europe and North America without magnitude information (normalized vector). Check", "for exact parameters.", "The", "plugin is a ROS controller for gazebo's built-in ray sensor. The value returned as sonar range is the minimum of all rays, as a sonar ranger returns the distance corresponding to the first echo returned from a object within it's field of view. The behavior of this controller plugin depends mainly on the parameters of the sensor it is attached to.", "The <controller:hector_gazebo_ros_sonar> tag is only valid within a surrounding", "tag. You should use the macro defined in", "in package", "to include a sonar sensor to your model.", "You can find some more plugins useful for aerial vehicles in package", "."]},
{"url": "https://wiki.ros.org/gazebo_plugins", "package": "gazebo_plugins", "package_summary": ["Robot-independent Gazebo plugins for sensors, motors and dynamic reconfigurable components."], "package_details": []},
{"url": "https://wiki.ros.org/hector_nav_msgs", "package": "hector_nav_msgs", "package_summary": ["hector_nav_msgs contains messages and services used in the hector_slam stack."], "package_details": []},
{"url": "https://wiki.ros.org/ee_cart_imped_msgs", "package": "ee_cart_imped_msgs", "package_summary": [], "package_details": ["See the", "for the message and action definitions."]},
{"url": "https://wiki.ros.org/fzi_icl_core", "package": "fzi_icl_core", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/genrb", "package": "genrb", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/graft", "package": "graft", "package_summary": ["Graft is not yet finished. It's intended to be a full replacement to\n    robot_pose_ekf, including native absolute references, and arbitrary\n    topic configuration.\n\n    If you try to use Graft now, please note that not all parameters are\n    configured and you will not always see a change in behavior by\n    modifying the parameters."], "package_details": []},
{"url": "https://wiki.ros.org/geometry", "package": "geometry", "package_summary": [], "package_details": ["Use GitHub to", ". [", "]"]},
{"url": "https://wiki.ros.org/fetch_moveit_config", "package": "fetch_moveit_config", "package_summary": ["An automatically generated package with all the configuration and launch files for using the fetch_urdf with the MoveIt Motion Planning Framework"], "package_details": []},
{"url": "https://wiki.ros.org/gps_common", "package": "gps_common", "package_summary": ["GPS messages and common routines for use in GPS drivers"], "package_details": ["This package is a space to stage messages and common GPS-processing routines that are undergoing a standardization process. Its contents will probably be moved into", "once they've matured.", "gps_common defines two common messages for GPS drivers to output:", "and", ".", "See", "for an example of a sender node that uses this package's messages."]},
{"url": "https://wiki.ros.org/fetch_gazebo", "package": "fetch_gazebo", "package_summary": ["Gazebo package for Fetch."], "package_details": []},
{"url": "https://wiki.ros.org/genjava", "package": "genjava", "package_summary": [], "package_details": ["See the", "tutorial for more information."]},
{"url": "https://wiki.ros.org/ecl_utilities", "package": "ecl_utilities", "package_summary": ["Includes various supporting tools and utilities for c++ programming."], "package_details": []},
{"url": "https://wiki.ros.org/ee_cart_imped_action", "package": "ee_cart_imped_action", "package_summary": [], "package_details": ["The ee_cart_imped_action is a node that provides an action interface for the", "node.  Specifically, it allows tracking trajectories that involve force control and sending goals and cancel signals to the controller.  The action can also put constraints on the trajectory and aborts trajectory execution when the constraints are violated.  All interaction with the", "package should be done through this action interface.", "For more videos, look at the", ".", "Example configuration (from", "/pr2_arms_cart_imped_controller.yaml):", "The EECartImpedAction provides an", "that takes in goals of the type", "and publishes feedback of the type", ".", "In general, interaction with the action server should take place through an action client.  To facilitate this process, we have written C++ and python wrappers around the", "and included them in the package.  To use the these clients, look at their code APIs", "or the", "."]},
{"url": "https://wiki.ros.org/gazebo_ros", "package": "gazebo_ros", "package_summary": ["Provides ROS plugins that offer message and service publishers for interfacing with", "through ROS.\n    Formally simulator_gazebo/gazebo"], "package_details": [": This package replaces", "in ROS Hydro", "See"]},
{"url": "https://wiki.ros.org/fetch_teleop", "package": "fetch_teleop", "package_summary": ["Teleoperation for fetch and freight."], "package_details": []},
{"url": "https://wiki.ros.org/ecl_streams", "package": "ecl_streams", "package_summary": ["These are lightweight text streaming classes that connect to standardised\n     ecl type devices."], "package_details": ["If outside ros, you will also need to link to", "."]},
{"url": "https://wiki.ros.org/geographic_msgs", "package": "geographic_msgs", "package_summary": ["ROS messages for Geographic Information Systems."], "package_details": ["Newly proposed, mistyped, or obsolete package. Could not find package \"geographic_msgs\" in rosdoc: /var/www/docs.ros.org/en/api/geographic_msgs/manifest.yaml", "Map points, features and segments all have universally unique identifier names (", "), using", "messages.", "Each UUID is stored as an array of unsigned bytes. UUID generation is up to the programmer, but the intent is for matching features within a domain such as Open Street Map to yield the same UUID.  The", "package provides C++ and Python interfaces for generating them: use the", "method on a URL constructed from the map source.", "Here,", "is the decimal representation of the integer OSM node, way, or", "relation ID without leading zeros.", "The", "service takes a map URL and optional", ", returning a", ",", "The map contains a", "vector and a", "vector. Each point or feature is identified by a", ", and optional", "properties describing their roles.", "Not all way points in a map are drivable by any particular vehicle. Some delimit buildings, rivers, or property boundaries. The", "message represents drivable paths as a directed graph using a", "vector and a", "vector. Each segment represents an edge from one point to another. Unless the path is one-way, another segment will point in the opposite direction."]},
{"url": "https://wiki.ros.org/face_recognition", "package": "face_recognition", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/hls_lfcd_lds_driver", "package": "hls_lfcd_lds_driver", "package_summary": ["ROS package for LDS(HLS-LFCD2).\n    The LDS (Laser Distance Sensor) is a sensor sending the data to Host for the simultaneous localization and mapping (SLAM). Simultaneously the detecting obstacle data can also be sent to Host. HLDS(Hitachi-LG Data Storage) is developing the technology for the moving platform sensor such as Robot Vacuum Cleaners, Home Robot, Robotics Lawn Mower Sensor, etc."], "package_details": ["360 Laser Distance Sensor 'HLS-LFCD-LDS' (a.k.a. LDS-01) is a 2D laser scanner capable of sensing 360 degrees that collects a set of data around the robot to use for SLAM (Simultaneous Localization and Mapping) and Navigation. The LDS-01 is used for TurtleBot3 Burger, Waffle and Waffle Pi models. It supports USB interface(USB2LDS) and is easy to install on a PC. It supports UART interface for embedded baord. This hls_lfcd_lds_driver package is a driver for LDS-01."]},
{"url": "https://wiki.ros.org/genpy", "package": "genpy", "package_summary": ["Python ROS message and service generators."], "package_details": []},
{"url": "https://wiki.ros.org/gateway_msgs", "package": "gateway_msgs", "package_summary": ["Messages used by the gateway model."], "package_details": []},
{"url": "https://wiki.ros.org/geneus", "package": "geneus", "package_summary": ["EusLisp ROS message and service generators."], "package_details": []},
{"url": "https://wiki.ros.org/geometry_msgs", "package": "geometry_msgs", "package_summary": ["geometry_msgs provides messages for common geometric primitives\n    such as points, vectors, and poses. These primitives are designed\n    to provide a common data type and facilitate interoperability\n    throughout the system."], "package_details": []},
{"url": "https://wiki.ros.org/handle_detector", "package": "handle_detector", "package_summary": [], "package_details": ["This requires an openni-compatible device, and has only been tested with an Asus Xtion Pro.", "If you like this package and use it in your own work, please cite our", ".", "For the given point cloud file (", "), the output in rviz should look like this:", "If you like this package and use it in your own work, please cite our", ":", "Andreas ten Pas and Robert Platt.", "International Symposium on Experimental Robotics (ISER), Morocco, June 2014."]},
{"url": "https://wiki.ros.org/ee_cart_imped_control", "package": "ee_cart_imped_control", "package_summary": [], "package_details": ["The controller is an open-loop Jacobian-transpose force controller.  At every point on the trajectory the desired stiffness or desired wrench is converted into a Cartesian force/wrench vector and ultimately into a joint torque vector using the transpose of the arm's instantaneous Jacobian matrix.  No guarantee is made to the", "of the applied force/wrench/impedance because this is an open-loop controller.  There is currently not adequate feedback on the arm to determine the applied force/wrench/impedance.  Joint stiction, joint position limits,  motor torque limits, and sometimes the arm configuration (at a singularity, for example) will cause the applied force/wrench/impedance to deviate from the desired values.  Generally, unless the arm is at a singularity or a joint is at its limit, the", "of the force/wrench/impedance will be correct.", "This controller should never be used directly; rather, all interaction with it should take place through the", ".", "In this video, the PR2 first moves its gripper to the center of its body and then applies a constant force in the", "direction (towards/away from the robot).  As you can see, the force is light so the human can easily stop the motion.  However, with no intervention, the robot hand will continue to move as far in the", "direction as it can go.  There is no sense of trying to achieve a goal in this direction.  This type of control is useful if you wish to exert a constant force against something.", "In this video, the PR2 first moves its gripper to the center of its body and then tries to extend the gripper about 25 cm farther away, but with low stiffness in the", "direction (towards/away from the robot).  Since the stiffness is low, it is easy for a human to move the hand away from the center of the body in the", "direction and it returns slowly.  In the", "and", "directions, however, where the stiffness is set to the maximum, it takes a lot of strength to displace the gripper and it returns very quickly to its set point.", "For even more videos, see the", ".", "Example configuration (from", "/pr2_arms_cart_imped_controller.yaml):"]},
{"url": "https://wiki.ros.org/gazebo", "package": "gazebo", "package_summary": [], "package_details": [".", "Also, pure", "questions (without", "involved) should be asked on its", "."]},
{"url": "https://wiki.ros.org/ecto_ros", "package": "ecto_ros", "package_summary": [], "package_details": []},
{"url": "https://wiki.ros.org/gl_dependency", "package": "gl_dependency", "package_summary": ["This encapsulates the GL dependency for a specific ROS distribution and its Qt version"], "package_details": []},
{"url": "https://wiki.ros.org/frontier_exploration", "package": "frontier_exploration", "package_summary": [], "package_details": ["(", ")", "Please check the", "for common problems, or open an", "if still unsolved.", "The best way to try", "is using the demo provided in", ", see the", ".", "The", "package provides a", "layer plugin", ", and", "client/server nodes", "and", ".", "The provided nodes can be used to demo the functionality of the costmap layer by executing a frontier exploration task bounded by a user-defined polygon area. Layer", "can certainly be used for more complex exploration tasks, functionality is exposed through two", ":", "and", ".", "To run this demo on your host, see", "section.", "Also, this video is an example of", "integrated with", "(", ").", "At this point the demo robot should start moving", ".", "If you just want to start taking advantage of the functionality of this package,", "helps.", "If you like to understand a little more in depth, generally, when launched", "will spin until it receives an exploration goal. To submit a goal:", "Once the server receives a goal, it will create the initial exploration map, start processing sensor/costmap data, and issuing", "action goals. By default, the exploration task will explore all areas within boundary (whether previously visited or not). Sample launch files for several use cases are provided below.", "When running the action server/client without a global", "information source, enable the", "parameter to dynamically resize the map based on the action goal's polygon boundary. Error messages thrown up by", "regarding the sensor being outside of map bounds will occur when the robot is traveling outside the exploration boundary. These can be safely ignored, and could be suppressed using", "configuration files.", "If not using", "(e.g. running unbounded exploration), make sure the costmap is configured with a large enough height/width.", "Sample launch file:", "When running the action server/client with a global", "information source (either from", "or", "), the exploration costmap will match size/resolution to the external map source map loaded by the static layer, so it is important to disable the", "parameter and that the", "of the exploration costmap matches that of the external /map.", "When exploring with", ", you must also disable", "to prevent the node from re-exploring known areas.", "Sample launch file:", "The", "node executes exploration actions for any connected clients. It uses a", "object to keep track of the exploration progress, and creates movement goals for", "as necessary."]},
{"url": "https://wiki.ros.org/epos_driver", "package": "epos_driver", "package_summary": [], "package_details": ["Package includes C library (", ") to control the EPOS motor control from maxon motor (", ") using a GNU/Linux system and ROS wrapper."]},
{"url": "https://wiki.ros.org/find_object_2d", "package": "find_object_2d", "package_summary": ["The find_object_2d package"], "package_details": ["Simple Qt interface to try OpenCV implementations of SIFT, SURF, FAST, BRIEF and other feature detectors and descriptors. Using a webcam, objects can be detected and published on a ROS topic with ID and position (pixels in the image). This package is a ROS integration of the", "application.", "Visit", "for some tutorials.", "Kinect v2 example (you will need", "package and", "):"]},
{"url": "https://wiki.ros.org/genlisp", "package": "genlisp", "package_summary": ["Common-Lisp ROS message and service generators."], "package_details": []},
{"url": "https://wiki.ros.org/fiducial_slam", "package": "fiducial_slam", "package_summary": ["ROS node to build a 3D map of fiducials and estimate robot pose from fiducial transforms"], "package_details": [",", "and", "specify the translation of the fiducial from the origin in meters, and", ",", ", and", "specify its orientation in degrees. The fields", "and", "represent how good the pose estimate is considered to be, and how many observations were used to generate it.", "is a list of the ids of fiducials that have been observed at the same time as the current fiducial.", "The coordinate frame used is the", "frame, which is relative to the floor, so markers of the ceiling will have been rotated.  The supplied launch files specify the map file as", "."]},
{"url": "https://wiki.ros.org/gscam", "package": "gscam", "package_summary": ["A ROS camera driver that uses gstreamer to connect to\n    devices such as webcams."], "package_details": ["is meant as a simple approach to using a webcam in ROS that maximizes compatibility.", "leverages", ", a multimedia framework similar to DirectShow. Specifically: Gstreamer can be used to build up multimedia \"pipelines\" consisting of sources, sinks, and filters.  For example: a v4l webcam", "might be", "by an upscaler before being sent to the screen (a", "). Alternately, a mp4 file might act as a source and be filtered into an avi file as a sink. There are many possibilities.  For an overview see:", ".", "can attach itself to a specially formatted pipeline. Provided this pipeline is processing RGB video,", "will rebroadcast the video over as", "a standard ROS image transport", "a ROS Camera. Since Gstreamer is compatibile with almost every video capture standard under Linux (and many on OSX),", "makes ROS defacto compatible with almost every Linux webcam or video system available. Moreover, because there are a number of Gstreamer filters for processing video (e.g. white-balancing, cropping, etc.) gscam allows for a more advanced video processing even with cheaper webcams.", "expects an environmental variable,", ", to contain a gstreamer", "pipeline definition for it to launch. There is one important restriction:", "is fully compatible with the ROS Camera interface and can be calibrated to provided rectified images. For details, see the appropriate ROS documentation on the", "wiki page.", "If you see a \"Processing...\" message, it means", "is happily publishing.", "You need to set the TF frame via the", "service described above."]},
{"url": "https://wiki.ros.org/gazebo_msgs", "package": "gazebo_msgs", "package_summary": ["Message and service data structures for interacting with Gazebo from ROS."], "package_details": ["See"]},
{"url": "https://wiki.ros.org/ecl_threads", "package": "ecl_threads", "package_summary": ["This package provides the c++ extensions for a variety of threaded \n     programming tools. These are usually different on different \n     platforms, so the architecture for a cross-platform framework\n     is also implemented."], "package_details": ["If outside ros, you will also need to link to", "."]},
{"url": "https://wiki.ros.org/fs100_motoman", "package": "fs100_motoman", "package_summary": [], "package_details": ["Source:", "The fs100_motoman package was created together with the Technical University of Denmark (DTU), Institute for Automation and Control (", "). The reason for this package was to provide an easy way to continuously stream a trajectory to the FS100 controller, to enable real-time sensor based control.", "Use github to report a bug and view current issues."]},
{"url": "https://wiki.ros.org/geometry_tutorials", "package": "geometry_tutorials", "package_summary": ["Metapackage of geometry tutorials ROS."], "package_details": ["See", "."]},
{"url": "https://wiki.ros.org/freenect_launch", "package": "freenect_launch", "package_summary": ["Launch files for freenect_camera to produce rectified, registered\n    or disparity images.  Also produce point clouds and registered\n    point clouds.  Based on the openni_launch package."], "package_details": ["contains a few modifications from", "apart from running the libfreenect based driver. These are documented below.", "This package contains launch files for using a Microsoft Kinect using the libfreenect library. This folder replicates the API offered by", "in an effort to maintain maximum compatibility with the OpenNI driver. Differences are mentioned below.", "To use this package, please refer to", "and", "documentation. The migration guide to/from the OpenNI driver is documented", ".", "There are a few additional launch files in", "that demonstrate running a different constellation of nodelets. This is useful for launching the minimum set of required processing nodelets, as well as avoid unnecessary warnings during launch. For example:"]},
{"url": "https://wiki.ros.org/geodesy", "package": "geodesy", "package_summary": ["Python and C++ interfaces for manipulating geodetic coordinates."], "package_details": ["All C++ symbols defined by this package reside in the", "namespace.", "This is the base type for communicating geodetic information between ROS nodes, using", "and", "messages.", "All Python modules defined by this package reside in the", "namespace."]},
{"url": "https://wiki.ros.org/hey5_description", "package": "hey5_description", "package_summary": [], "package_details": []}
]
